---
layout: default
permalink: Dialects/ShapeDialect
parent: Dialect Definitions
title: "'shapex' Dialect"
---

<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'shapex' Dialect
{: .no_toc }


A dialect of helper ops for shapifying computations.

1. TOC
{:toc}

## Operation definition

### `shapex.cast_compatible_shape` (Shape::CastCompatibleShapeOp)

Casts and asserts that one or more shapes are compatible.

Syntax:

```
operation ::= `shapex.cast_compatible_shape` operands `:` type(operands) `->` type($result) attr-dict
```


In the most general case, each operand and the result can have different
shapes, so long as:
  a) The operand shapes are co-compatible (known dimensions are equal
     or unknown).
  b) The result shape is at least as general as the operand shapes.

TODO: This op is currently very conservative, statically verifying that
all of the shapes are strictly the same.

Usage:
  %0 = shape.cast_compatible_shape %1, ... %3 :
      !shape.ranked_shape<...>...

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Ranked shape type

### `shapex.const_ranked_shape` (Shape::ConstRankedShapeOp)

A constant ranked_shape.

Syntax:

```
operation ::= `shapex.const_ranked_shape` attr-dict `:` type($result)
```


Holds a RankedShape value. Note that it is only legal to store a constant
RankedShape that is fully static, as anything more specific should be
in the type, not have dims represented as const SSA values.

Usage:
  %0 = shape.const_ranked_shape : !shape.ranked_shape<[1,2]>

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Ranked shape type

### `shapex.from_extent_tensor` (Shape::FromExtentTensorOp)

Convert a tensor of extents to a ranked shape.

Convert a rank-1 tensor of integers to a !shapex.ranked_shape.

Examples:
%t0 = "shapex.from_dimension_tensor"(%rs0)
  : (tensor<3xi32>)
  -> !shapex.ranked_shape<[?,?,?],i32>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`extent_tensor` | a 1D tensor of extents of index or signless integer values

#### Results:

| Result | Description |
| :----: | ----------- |
`shape` | Ranked shape type

### `shapex.gather_extents` (Shape::GatherExtentsOp)

Gather extents across shapes.

Gathers extents across the !shapex.ranked_shape's in `shapes`.

This op conceptually performs the following operation:
1. The extents of all shapes in `shapes` are concatenated together into
   a single list.
2. The resulting shape is constructed by extracting extents from the
   combined list according to `indices`.
In pseudocode:
```
shapes = ... # a list of lists of extents
# Example: shapes = [[3,-1],[2,7]]
extents = [extent for extent in shape for shape in shapes]
# Example: extents = [3,-1,2,7]
# or to use another terminology: `extents = flatmap(shapes)`
results = [extents[index] for index in indices]
```

A large class of shape manipulations can be canonicalized into this op,
including:
- taking slices of shapes
- concatenating shapes
- permuting shapes
The intuition behind this op is that eventually each extent will be
exploded into its own SSA value. At which point, this op merely becomes
and identification of each SSA value of the output extents with an
SSA value of the input extents.
This op has the useful property that is closed under composition with
itself, thus allowing an arbitrarily complex subgraph consisting of just
this op to be folded together.

Some examples of shape transfer functions captured with this op:

- Taking the last two extents of a shape:
  - [d0,d1,d2,d3] indices=[2,3] -> [d2,d3]
- Concatenating three shapes:
  - [d0,d1] [d2,d3] [d4,d5] indices=[0,1,2,3,4,5] -> [d0,d1,d2,d3,d4,d5]
- Shape transfer function for transpose with permutation [0,2,1]:
  - [d0,d1,d2] indices=[0,2,1] -> [d0,d2,d1]
- Shape transfer function for outer product of a vector with itself:
  - Initial state: [d0] [d1] indices=[0,1] -> [d0,d1]
  - Canonicalized to a single-operand op after observing that both inputs
    are the same !shapex.ranked_shape value: [d0] indices=[0,0] -> [d0,d0]
- Shape transfer function for matmul with a batch dimension on the LHS:
  - [d0,d1,d2] [d4,d5] indices=[0,1,2,5] -> [d0,d1,d2,d5]

This op is somewhat inspired by the LLVM `shufflevector` instruction.

Possible future pretty syntax for single-arg case:
%rs = shapex.gather_extents %0[0,2,1] : !shapex.ranked_shape<[5,6,7]>
Consider a pretty syntax for "concat":
%rs = shapex.gather_extents concat(%0, %1) : !shapex.ranked_shape<[5,6,7]>, !shapex.ranked_shape<[8,9]>


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`indices` | DenseIntElementsAttr | 64-bit signless integer elements attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`shapes` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Ranked shape type

### `shapex.get_ranked_shape` (Shape::GetRankedShapeOp)

Gets the RankedShape associated with the given Tensor.

Syntax:

```
operation ::= `shapex.get_ranked_shape` $operand attr-dict `:` type($operand) `->` type($shape)
```


Early in compilation, this op is used to resolve the RankedShape from an
arbitrary tensor value. It will typically be converted later to a
RankedShape loaded from an appropriate computation.

Getting the RankedShape of a statically shaped tensor will canonicalize
to a static_ranked_shape op and will never cause a further SSA dependency.

Usage:
  %0 = shape.get_ranked_shape %arg0 : tensor<2x?xf32> ->
      !shape.ranked_shape<[2,?]>  // based on index type
  %0 = shape.get_ranked_shape %arg0 : tensor<2x?xf32> ->
      !shape.ranked_shape<[2,?],i32>  // explicit dim type

Canonicalization: This op includes a canonicalization pattern such that
if its operand is supplied by a tie_shape op, then it will replace itself
with the tie_shape's shape() operand. In this way, a function with all
shapes materialized and tied to intermediate tensors should canonicalize
to contain no get_ranked_shape ops.

Any get_ranked_shape on a fully static shape will canonicalize to a const
with unit value:
  %0 = constant_ranked_shape : !shape.ranked_shape<[1,2],i32>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | tensor of any type values

#### Results:

| Result | Description |
| :----: | ----------- |
`shape` | Ranked shape type

### `shapex.make_ranked_shape` (Shape::MakeRankedShapeOp)

Makes a ranked_shape from individual dims.

Syntax:

```
operation ::= `shapex.make_ranked_shape` $dynamic_dimensions `:` functional-type($dynamic_dimensions, $shape) attr-dict
```


Given a list of SSA values holding compatible dims, makes a corresponding
ranked_shape.

Usage:
  %0 = shape.make_ranked_shape %dim0, %dim1 : (i32, i32) ->
      !shape.ranked_shape<[?,?,128]>

Note that the type of the dims is is implied by the dim type of the result.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`dynamic_dimensions` | index or signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
`shape` | Ranked shape type

### `shapex.ranked_broadcast_in_dim` (Shape::RankedBroadcastInDimOp)

Broadcasts dimensions from the input into the result.

Usage:
  %0 = shape.ranked_broadcast_in_dim [...] (%operand, %result_shp) :
      tensor<...xf32>, !shape.ranked_shape<...xi32>

  Note that the result type will be a RankedTensorType with dims from
  %result_shp and the element type from %operand.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`broadcast_dimensions` | DenseIntElementsAttr | 64-bit signless integer elements attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | ranked tensor of any type values
`result_shape` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ranked tensor of any type values

### `shapex.ranked_broadcast_shape` (Shape::RankedBroadcastShapeOp)

Broadcasts operands to a result shape.

Applies numpy broadcasting semantics to shape operands.

Usage:
  %0 = shape.ranked_broadcast_shape %shp0, %shp1 :
      !shape.ranked_shape<...>, !shape.ranked_shape<...>

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`lhs_broadcast_dimensions` | DenseIntElementsAttr | 64-bit signless integer elements attribute
`rhs_broadcast_dimensions` | DenseIntElementsAttr | 64-bit signless integer elements attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lhs` | Ranked shape type
`rhs` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | Ranked shape type

### `shapex.ranked_dim` (Shape::RankedDimOp)

Gets a dimension value from a ranked_shape.

Static dimensions will fold to constants.

Usage:
  %0 = shape.const ranked_shape : !shape.ranked_shape<[1,2]>
  %1 = shape.ranked_dim %0[0] : !shape.ranked_shape<[1,2]> -> i32

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`index` | IntegerAttr | arbitrary integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`shape` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer

### `shapex.ranked_dims` (Shape::RankedDimsOp)

Gets all dimension values from a ranked_shape.

Syntax:

```
operation ::= `shapex.ranked_dims` $shape `:` type($shape) `->` type($result) attr-dict
```


Static dimensions will fold to constants.

Usage:
  %0 = shape.const ranked_shape : !shape.ranked_shape<[1,2]>
  %1, %2 = shape.ranked_dims %0 : !shape.ranked_shape<[1,2]> -> (i32, i32)

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`shape` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer

### `shapex.tie_shape` (Shape::TieShapeOp)

Ties a tensor and a shape together.

Syntax:

```
operation ::= `shapex.tie_shape` operands attr-dict `:` type($operand) `,` type($shape)
```


Ties a specific tensor and its shape together in the IR, allowing further
conversions to re-associate the two. This has no runtime implication and
will be removed late in conversion.

Usage:
  %0 = shape.tie_shape %1, %2 : tensor<...>, shape.ranked_shape<...>

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | any type
`shape` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | any type

### `shapex.to_extent_tensor` (Shape::ToExtentTensorOp)

Convert a ranked shape to a tensor of extents.

Convert a !shapex.ranked_shape to a rank-1 tensor of integers.

Examples:
%t0 = "shapex.to_extent_tensor"(%rs0)
  : (!shapex.ranked_shape<[3,?,5]>)
  -> tensor<3xi32>
The resulting tensor will, for example, have elements [3,4,5] if the
dynamic dimension is 4 at runtime.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`shape` | Ranked shape type

#### Results:

| Result | Description |
| :----: | ----------- |
`extent_tensor` | a 1D tensor of extents of index or signless integer values
