---
layout: default
permalink: Dialects/HALDialect
parent: Dialect Definitions
title: "'hal' Dialect"
---

<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'hal' Dialect
{: .no_toc }


A dialect representing operations against the IREE HAL.


This can be thought of as a Vulkan-like model with all of the graphics bits
chopped out.

The type set is limited to those that can be represented in the IREE HAL
design: buffers and views, synchronization primitives like semaphores, and
and command buffers. The intent is that if a device could implement the HAL
interface the sequencer ops could run on that device, such as being able to
run on a GPU via indirect command buffers.

Though this is mostly a 1:1 mapping to the iree::hal API there are some
methods omitted as they are not likely to be needed in IR. It's assumed that
either sequencer interfaces will encapsulate the logic (such as device
resolution) or that certain features are unsafe to expose to user-defined
input.

1. TOC
{:toc}

## Type definition

### allocator

Allocates buffers for a particular device memory space.

### buffer

A memory buffer with a specific memory_type that is used to describe the
capabilities and behavior of the backing memory of the buffer. Buffers may
be any mix of host-accessible, host-coherent, or device-accessible for
various usages. Depending on these memory types the buffers may be mapped
for access on the host as memory though certain restrictions may be imposed.

### buffer_view

A shaped and typed buffer reference. This just wraps an existing hal.buffer
with its associated metadata to make it easier to pass across ABI
boundaries. In most cases buffer views can be elided entirely by the
compiler and they'll only be seen when calling external functions.

### command_buffer

Asynchronous command buffer recording interface. Commands are recorded by
the implementation for later submission to command queues.

### descriptor_set

Descriptor set.

### descriptor_set_layout

Descriptor set layout.

### device

Logical device instance.

### event

Events are used for defining synchronization scopes within CommandBuffers.
An event only exists within a single CommandBuffer and must not be used
across CommandBuffers from the same device or others.

### executable

A prepared and ready-to-dispatch executable.

### executable_cache

A cache of prepared executables for a particular device.
Caches may be shared across multiple devices from the same driver or
specific to individual devices. Caches may persist prepared executables
across process launches or reprepare them each run. Callers should assume
that the cache is a no-op and the returned Executables only live for as long
as the cache does.

### executable_layout

An executable layout describing the descriptor sets and push constants used.

### ring_buffer

Ringbuffer used for transient buffer allocation.

### semaphore

Synchronization mechanism for host->device, device->host, host->host,
and device->device notification. Semaphores behave like Vulkan timeline
semaphores (or D3D12 fences) and contain a monotonically increasing
uint64_t payload. They may be waited on any number of times even if they
have already been signaled for a particular value. They may also be waited
on for a particular value prior to the signal for that value.

## Operation definition

### `hal.variable.load.indirect` (IREE::HAL::VariableLoadIndirectOp)

loads a value from a global variable

Syntax:

```
operation ::= `hal.variable.load.indirect` $variable attr-dict `:` type($variable) `->` type($result)
```


Returns a copy of the variable value.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`variable` | ptr<index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore>

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore

### `hal.allocator.allocate.const` (IREE::HAL::AllocatorAllocateConstOp)

constant buffer allocation operation

Syntax:

```
operation ::= `hal.allocator.allocate.const` $allocator `,` $memory_types `,` $buffer_usage attr-dict-with-keyword `:`
              type($result) `=` $value
```


Allocates a buffer from the allocator with the given constant contents.
The buffer contents cannot change after the the point of allocation and in
most cases should be cached so that the buffer is not reallocated
repeatedly.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`memory_types` | ::mlir::IntegerAttr | valid MemoryType
`buffer_usage` | ::mlir::IntegerAttr | valid BufferUsage
`value` | ::mlir::ElementsAttr | constant vector/tensor attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.allocator.allocate` (IREE::HAL::AllocatorAllocateOp)

empty buffer allocation operation

Syntax:

```
operation ::= `hal.allocator.allocate` $allocator `,` $memory_types `,` $buffer_usage `,` $allocation_size
              attr-dict-with-keyword `:` type($result)
```


Allocates a buffer of the given size from the allocator.
The size of the buffer returned may be larger than the requested size if the
allocator has specific alignment requirements or minimum allocation sizes.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`memory_types` | ::mlir::IntegerAttr | valid MemoryType
`buffer_usage` | ::mlir::IntegerAttr | valid BufferUsage

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`allocation_size` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.allocator.compute_offset` (IREE::HAL::AllocatorComputeOffsetOp)

buffer view indices to byte offset computation operation

Syntax:

```
operation ::= `hal.allocator.compute_offset` $allocator `,` `shape` `=` `[` $shape `]` `,` `element_type` `=`
              $element_type `,` `indices` `=` `[` $indices `]` attr-dict
```


Computes an element byte offset within a buffer produced by the allocator.
This returns the same value as `hal.buffer_view.compute_offset`.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`element_type` | ::mlir::IntegerAttr | element type attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`shape` | index
`indices` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index

### `hal.allocator.compute_range` (IREE::HAL::AllocatorComputeRangeOp)

buffer view byte range computation operation

Syntax:

```
operation ::= `hal.allocator.compute_range` $allocator `,` `shape` `=` `[` $shape `]` `,` `element_type` `=`
              $element_type `,` `indices` `=` `[` $indices `]` `,` `lengths` `=` `[`
              $lengths `]` attr-dict
```


Computes a byte range within a buffer for one or more elements.
This returns the same value as `hal.buffer_view.compute_range`.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`element_type` | ::mlir::IntegerAttr | element type attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`shape` | index
`indices` | index
`lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index
`length` | index

### `hal.allocator.compute_size` (IREE::HAL::AllocatorComputeSizeOp)

buffer allocation size computation operation

Syntax:

```
operation ::= `hal.allocator.compute_size` $allocator `,` `shape` `=` `[` $shape `]` `,` `element_type` `=`
              $element_type attr-dict
```


Computes the byte size required for a buffer of the given shape and type.
This returns the same value as `hal.buffer_view.byte_length`.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`element_type` | ::mlir::IntegerAttr | element type attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator
`shape` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer.allocator` (IREE::HAL::BufferAllocatorOp)

buffer allocator accessor operation

Syntax:

```
operation ::= `hal.buffer.allocator` $buffer `:` type($result) attr-dict
```


Returns the allocator this buffer was allocated from.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer` | buffer

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | allocator

### `hal.buffer.copy_data` (IREE::HAL::BufferCopyDataOp)

buffer-to-buffer copy operation

Syntax:

```
operation ::= `hal.buffer.copy_data` operands attr-dict
```


Copies data from the provided source_buffer into the buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source_buffer` | buffer
`source_offset` | index
`target_buffer` | buffer
`target_offset` | index
`length` | index

### `hal.buffer.fill` (IREE::HAL::BufferFillOp)

buffer fill operation

Syntax:

```
operation ::= `hal.buffer.fill` operands attr-dict
```


Fills the target buffer with the given repeating value.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`target_buffer` | buffer
`target_offset` | index
`length` | index
`pattern` | 32-bit signless integer

### `hal.buffer.load` (IREE::HAL::BufferLoadOp)

buffer element load operation

Syntax:

```
operation ::= `hal.buffer.load` $source_buffer `[` $source_offset `]` `:` type($result) attr-dict
```


Loads a value from a buffer by mapping it.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source_buffer` | buffer
`source_offset` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point or vector of any type values

### `hal.buffer.read_data` (IREE::HAL::BufferReadDataOp)

buffer-to-heap read operation

Syntax:

```
operation ::= `hal.buffer.read_data` operands attr-dict `:` type($target_buffer)
```


Reads a block of byte data from the resource at the given offset.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source_buffer` | buffer
`source_offset` | index
`target_buffer` | mutable_byte_buffer
`target_offset` | index
`length` | index

### `hal.buffer.store` (IREE::HAL::BufferStoreOp)

buffer element store operation

Syntax:

```
operation ::= `hal.buffer.store` $value `,` $target_buffer `[` $target_offset `]` `:` type($value) attr-dict
```


Stores a value into a buffer by mapping it.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | index or signless integer or floating-point or vector of any type values
`target_buffer` | buffer
`target_offset` | index

### `hal.buffer.subspan` (IREE::HAL::BufferSubspanOp)

buffer subspan operation

Syntax:

```
operation ::= `hal.buffer.subspan` operands attr-dict `:` type($result)
```


Returns a reference to a subspan of the buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source_buffer` | buffer
`source_offset` | index
`length` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.buffer_view.buffer` (IREE::HAL::BufferViewBufferOp)

buffer view buffer accessor

Syntax:

```
operation ::= `hal.buffer_view.buffer` $buffer_view `:` type($result) attr-dict
```


Returns the buffer backing this view's contents.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer

### `hal.buffer_view.byte_length` (IREE::HAL::BufferViewByteLengthOp)

buffer view buffer byte length accessor

Syntax:

```
operation ::= `hal.buffer_view.byte_length` $buffer_view `:` type($result) attr-dict
```


Returns the allocated size of a shaped buffer view in bytes.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.compute_offset` (IREE::HAL::BufferViewComputeOffsetOp)

buffer view indices to byte offset computation operation

Syntax:

```
operation ::= `hal.buffer_view.compute_offset` $buffer_view `,` `indices` `=` `[` $indices `]` attr-dict
```


Computes an element byte offset within a buffer view.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view
`indices` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index

### `hal.buffer_view.compute_range` (IREE::HAL::BufferViewComputeRangeOp)

buffer view byte range computation operation

Syntax:

```
operation ::= `hal.buffer_view.compute_range` $buffer_view `,` `indices` `=` `[` $indices `]` `,` `lengths` `=` `[`
              $lengths `]` attr-dict
```


Computes a byte range within a buffer for one or more elements.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view
`indices` | index
`lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`offset` | index
`length` | index

### `hal.buffer_view.const` (IREE::HAL::BufferViewConstOp)

buffer view constant initializer

Syntax:

```
operation ::= `hal.buffer_view.const` $allocator `,` $memory_types `,` $buffer_usage `:` type($result)
              attr-dict-with-keyword `=` $value
```


Pseudo-op for allocating a constant buffer view. Expands to a buffer
allocation and a buffer view wrapper.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`memory_types` | ::mlir::IntegerAttr | valid MemoryType
`buffer_usage` | ::mlir::IntegerAttr | valid BufferUsage
`value` | ::mlir::ElementsAttr | constant vector/tensor attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`allocator` | allocator

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer_view

### `hal.buffer_view.create` (IREE::HAL::BufferViewCreateOp)

buffer view reference initializer

Syntax:

```
operation ::= `hal.buffer_view.create` $buffer `,` `shape` `=` `[` $shape `]` `,` `element_type` `=` $element_type
              `:` type($result) attr-dict
```


Creates a reference to a buffer with a particular shape and element type.
The buffer is not copied and both the original and view references must be
synchronized. This makes it easier to associate commonly-carried metadata
along with the contents.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`element_type` | ::mlir::IntegerAttr | element type attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer` | buffer
`shape` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer_view

### `hal.buffer_view.dim` (IREE::HAL::BufferViewDimOp)

buffer view dimension value query

Syntax:

```
operation ::= `hal.buffer_view.dim` $buffer_view `,` $index attr-dict `:` type($result)
```


Returns the value of the given dimension.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`index` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.dims` (IREE::HAL::BufferViewDimsOp)

buffer view multi-value dimension query

Syntax:

```
operation ::= `hal.buffer_view.dims` $buffer_view attr-dict `:` type($result)
```


Returns each dimension value of the buffer view.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.rank` (IREE::HAL::BufferViewRankOp)

buffer view rank query

Syntax:

```
operation ::= `hal.buffer_view.rank` $buffer_view attr-dict `:` type($result)
```


Returns the rank of the buffer view.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index

### `hal.buffer_view.subview` (IREE::HAL::BufferViewSubviewOp)

buffer view subview initializer

Syntax:

```
operation ::= `hal.buffer_view.subview` $buffer_view `,` `indices` `=` `[` $indices `]` `,` `lengths` `=` `[`
              $lengths `]` `:` type($result) attr-dict
```


Returns a view into a another buffer view. The buffer is not copied and both
the original and sliced references must be synchronized.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer_view` | buffer_view
`indices` | index
`lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | buffer_view

### `hal.buffer.write_data` (IREE::HAL::BufferWriteDataOp)

heap-to-buffer write operation

Syntax:

```
operation ::= `hal.buffer.write_data` operands attr-dict `:` type($source_buffer)
```


Writes a block of byte data into the resource at the given offset.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`source_buffer` | byte_buffer or mutable_byte_buffer
`source_offset` | index
`target_buffer` | buffer
`target_offset` | index
`length` | index

### `hal.check_success` (IREE::HAL::CheckSuccessOp)

raises a global failure if a status is not 'ok'

Syntax:

```
operation ::= `hal.check_success` $status (`,` $message^)? attr-dict
```


When the status is not 'ok' this signals a runtime failure that causes the
entire active invocation - and possibly *all* in-flight and pending
invocations - to fail with the given status. The status will be propagated
back via the available runtime error handling mechanisms such as semaphores
or synchronous invocation results.

As the IREE execution model is deeply pipelined it's possible that failures
have a latency between when they are emitted and when the application can
observe the failure. It's also possible that other work that is in-flight
or pending when the failure occurs will complete.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`message` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`status` | 32-bit signless integer

### `hal.command_buffer.begin` (IREE::HAL::CommandBufferBeginOp)

command buffer recording begin operation

Syntax:

```
operation ::= `hal.command_buffer.begin` $command_buffer attr-dict
```


Resets and begins recording into the command buffer, clearing all previously
recorded contents.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer

### `hal.command_buffer.bind_descriptor_set` (IREE::HAL::CommandBufferBindDescriptorSetOp)

command buffer descriptor set binding operation

Syntax:

```
operation ::= `hal.command_buffer.bind_descriptor_set` $command_buffer `,` $executable_layout `,` `set` `=` $set `,`
              $descriptor_set (`,` `offsets` `=` `[` $dynamic_offsets^ `]`)?
              attr-dict-with-keyword
```


Binds a descriptor set to the given set number. The provided descriptor set
must not be modified once bound to a command buffer.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`set` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable_layout` | executable_layout
`descriptor_set` | descriptor_set
`dynamic_offsets` | index

### `hal.command_buffer.copy_buffer` (IREE::HAL::CommandBufferCopyBufferOp)

command buffer buffer copy recording operation

Syntax:

```
operation ::= `hal.command_buffer.copy_buffer` operands attr-dict
```


Copies a range of one buffer to another.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`source_buffer` | buffer
`source_offset` | index
`target_buffer` | buffer
`target_offset` | index
`length` | index

### `hal.command_buffer.create` (IREE::HAL::CommandBufferCreateOp)

command buffer allocation operation

Syntax:

```
operation ::= `hal.command_buffer.create` $device `,` $modes `,` $command_categories attr-dict-with-keyword `:`
              type($result)
```


Returns a command buffer from the device pool ready to begin recording.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`modes` | ::mlir::IntegerAttr | valid CommandBufferMode
`command_categories` | ::mlir::IntegerAttr | valid CommandCategory

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | command_buffer

### `hal.command_buffer.dispatch.indirect` (IREE::HAL::CommandBufferDispatchIndirectOp)

command buffer indirect dispatch recording operation

Syntax:

```
operation ::= `hal.command_buffer.dispatch.indirect` $command_buffer `,` $executable `,` `entry_point` `=` $entry_point `,`
              `workgroups` `=` $workgroups_buffer `[` $workgroups_offset `]` attr-dict
```


Dispatches an execution request with the dispatch parameters loaded from the
given buffer.

```mlir
hal.command_buffer.dispatch.indirect %cmd, %executable,
                                     entry_point = 0,
                                     workgroups = %buffer[%offset]
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`entry_point` | ::mlir::IntegerAttr | 32-bit integer ordinal attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable` | executable
`workgroups_buffer` | buffer
`workgroups_offset` | index

### `hal.command_buffer.dispatch` (IREE::HAL::CommandBufferDispatchOp)

command buffer dispatch recording operation

Syntax:

```
operation ::= `hal.command_buffer.dispatch` $command_buffer `,` $executable `,` `entry_point` `=` $entry_point `,`
              `workgroup_xyz` `=` `[` $workgroup_x `,` $workgroup_y `,` $workgroup_z `]`
              attr-dict
```


Dispatches an execution request.

```mlir
%x = constant 128 : index
%y = constant 32 : index
%z = constant 1 : index
hal.command_buffer.dispatch %cmd, %executable,
                            entry_point = 0,
                            workgroup_xyz = [%x, %y, %z]
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`entry_point` | ::mlir::IntegerAttr | 32-bit integer ordinal attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable` | executable
`workgroup_x` | index
`workgroup_y` | index
`workgroup_z` | index

### `hal.command_buffer.end` (IREE::HAL::CommandBufferEndOp)

command buffer recording end operation

Syntax:

```
operation ::= `hal.command_buffer.end` $command_buffer attr-dict
```


Ends recording into the command buffer.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer

### `hal.command_buffer.execution_barrier` (IREE::HAL::CommandBufferExecutionBarrierOp)

command buffer execution barrier recording operation

Defines a memory dependency between commands recorded before and after the
barrier.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`source_stage_mask` | ::mlir::IntegerAttr | valid ExecutionStage
`target_stage_mask` | ::mlir::IntegerAttr | valid ExecutionStage

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`memory_barriers` | MemoryBarrier
`buffer_barriers` | BufferBarrier

### `hal.command_buffer.fill_buffer` (IREE::HAL::CommandBufferFillBufferOp)

command buffer buffer fill recording operation

Syntax:

```
operation ::= `hal.command_buffer.fill_buffer` operands attr-dict
```


Fills the target buffer with the given repeating value.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`target_buffer` | buffer
`target_offset` | index
`length` | index
`pattern` | 32-bit signless integer

### `hal.command_buffer.push_constants` (IREE::HAL::CommandBufferPushConstantsOp)

command buffer push constants operation

Syntax:

```
operation ::= `hal.command_buffer.push_constants` $command_buffer `,` $executable_layout `,` `offset` `=` $offset `,`
              `values` `=` `[` $values `]` `:` `i32` attr-dict-with-keyword
```


Pushes an inline set of constants that can be accessed by subsequent
dispatches using a compatible executable layout.

Push constants are always 4-byte values and treated as opaque, meaning that
they may be bit-casted floats, bit-packed booleans, etc.

```mlir
hal.command_buffer.push_constants %cmd, %exe_layout,
                                  offset = 0,
                                  values = [%value0, %value1] : i32
hal.command_buffer.push_constants %cmd, %exe_layout,
                                  offset = 2,
                                  values = [%value2, %value3] : i32
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`offset` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable_layout` | executable_layout
`values` | 32-bit signless integer

### `hal.command_buffer.push_descriptor_set` (IREE::HAL::CommandBufferPushDescriptorSetOp)

command buffer descriptor set push binding operation

Pushes an inline-defined descriptor set to the command buffer.

```mlir
hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set = 0, bindings = [
  0 = (%buffer_0, %buffer_offset_0, %buffer_length_0),
  1 = (%buffer_1, %buffer_offset_1, %buffer_length_1),
  2 = (%buffer_2, %buffer_offset_2, %buffer_length_2)
]
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`set` | ::mlir::IntegerAttr | 32-bit signless integer attribute
`bindings` | ::mlir::ArrayAttr | 32-bit integer array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`command_buffer` | command_buffer
`executable_layout` | executable_layout
`binding_buffers` | buffer
`binding_offsets` | index
`binding_lengths` | index

### `hal.descriptor_set.create` (IREE::HAL::DescriptorSetCreateOp)

allocates a descriptor set from the device pool

Creates a DescriptorSet from the device pool.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`bindings` | ::mlir::ArrayAttr | 32-bit integer array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`set_layout` | descriptor_set_layout
`binding_buffers` | buffer
`binding_offsets` | index
`binding_lengths` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | descriptor_set

### `hal.descriptor_set_layout.create` (IREE::HAL::DescriptorSetLayoutCreateOp)

creates a descriptor set layout

Syntax:

```
operation ::= `hal.descriptor_set_layout.create` $device `,` $usage_type `,` `bindings` `=` $bindings attr-dict `:` type($result)
```


Creates a descriptor set layout that defines the bindings used within a set.
The same descriptor set layout may be shared with many different executable
layouts and by doing so some runtime binding overhead when switching between
executables that use the same set layouts can be reduced.

```mlir
%layout = hal.descriptor_set_layout.create %device, "PushOnly", bindings = [
  #hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">,
  #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Write">
] : !hal.descriptor_set_layout
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`usage_type` | ::mlir::IntegerAttr | IREE HAL DescriptorSetLayoutType
`bindings` | ::mlir::ArrayAttr | HAL descriptor set layout binding array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | descriptor_set_layout

### `hal.descriptor_set_layout.lookup` (IREE::HAL::DescriptorSetLayoutLookupOp)

descriptor set layout cache lookup pseudo-op

Syntax:

```
operation ::= `hal.descriptor_set_layout.lookup` $device `,` $usage_type `,` `bindings` `=` $bindings attr-dict `:` type($result)
```


Used during conversion to provide a placeholder for a globally cached and
possibly lazy-initialized descriptor set layout.

```mlir
%layout = hal.descriptor_set_layout.lookup %device, "PushOnly", bindings = [
  #hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">,
  #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Write">
] : !hal.descriptor_set_layout
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`usage_type` | ::mlir::IntegerAttr | IREE HAL DescriptorSetLayoutType
`bindings` | ::mlir::ArrayAttr | HAL descriptor set layout binding array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | descriptor_set_layout

### `hal.device.allocator` (IREE::HAL::DeviceAllocatorOp)

device allocator accessor operation

Syntax:

```
operation ::= `hal.device.allocator` $device attr-dict `:` type($result)
```


Returns the allocator that can be used to allocate buffers compatible with
the device.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | allocator

### `hal.device.match.id` (IREE::HAL::DeviceMatchIDOp)

returns true if the device ID matches the pattern

Syntax:

```
operation ::= `hal.device.match.id` $device `,` `pattern` `=` `[` $pattern `]` attr-dict
              `:` `(` type($device) `)` `->` type($result)
```


Pattern matches the device ID with the given wildcard pattern.
This can be used to conditionally evaluate device-specific code when the
device is not known at compile-time.

```mlir
%is_match = hal.device.match.id %device, pattern = ["vulkan-*"] : (!hal.device) -> i1
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`pattern` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 1-bit signless integer

### `hal.device.switch` (IREE::HAL::DeviceSwitchOp)

runtime device switch pseudo op

Switches between multiple regions based on the runtime device type.
The provided regions are matched against the runtime backend of the given
device and executed only when the device matches the conditions.

Conditions can match on wildcards and be folded to enable conditions that
have similar bodies to be folded. The patterns themselves are only matched
once at startup and then the results are cached; the runtime overhead is
equivalent to a normal switch statement. In cases where the compiler can
statically identify the device type entire cases can be folded away.

Supported conditions:
* `#hal.match...`: execute the region if the expression matches.

Supported match expressions:
* `#hal.match.always`: always matches; useful for defaults.
* `#hal.match.any<[...]>`: matches if any of the nested expressions match.
* `#hal.match.all<[...]>`: matches only if all of the nested expressions
  match.
* `#hal.device.match.id<"pattern*-?-*">`: matches against the device
  identifier. The pattern is evaluated with standard file path wildcards
  (`*` for zero or more characters and `?` for one character).

If more than one condition is satisfied the first listed will be chosen.
More specific conditions should be earlier in the set. If no condition is
matched but there are return values the switch will abort at runtime. It's
strongly recommend that all switches that return values end with a trailing
`#hal.match.always` condition to handle the fallthrough case.

Upon creation each condition region will have an empty entry block with the
specified operands available as arguments. Each region must be setup to
return the same types.

```mlir
%c0 = constant 0 : i32
%c1 = constant 1 : i32
%c2 = constant 2 : i32
%device = ... : !hal.device
%0 = hal.device.switch(%device : !hal.device) -> i32
  #hal.device.match.id<"vulkan-v1.?-*">(%c1a = %c1 : i32) {
    hal.return %c1a : i32
  },
  #hal.match.any<[#hal.device.match.id<"vmla">, #hal.device.match.id<"vulkan-*">]>(%c2a = %c2 : i32) {
    hal.return %c2a : i32
  },
  #hal.match.always(%c0a = %c0 : i32) {
    hal.return %c0a : i32
  }
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`conditions` | ::mlir::ArrayAttr | array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`args` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `hal.ex.defer_release` (IREE::HAL::ExDeferReleaseOp)



Syntax:

```
operation ::= `hal.ex.defer_release` $operand `:` type($operand) attr-dict
```



#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore

### `hal.ex.shared_device` (IREE::HAL::ExSharedDeviceOp)



Syntax:

```
operation ::= `hal.ex.shared_device` attr-dict `:` type($result)
```



#### Results:

| Result | Description |
| :----: | ----------- |
`result` | device

### `hal.ex.submit_and_wait` (IREE::HAL::ExSubmitAndWaitOp)



Syntax:

```
operation ::= `hal.ex.submit_and_wait` $device `,` $command_buffer attr-dict
```



#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`command_buffer` | command_buffer

### `hal.executable.binary_end` (IREE::HAL::ExecutableBinaryEndOp)

terminator pseudo-op for the executable binary op

Syntax:

```
operation ::= `hal.executable.binary_end` attr-dict
```



### `hal.executable.binary` (IREE::HAL::ExecutableBinaryOp)

compiled executable binary data

A compiled executable binary with an optional nested module containing the
IR prior to serialization (for debugging).

The `format` attribute specifies a four character code (FourCC) matching the
executable format in `iree/hal/executable_format.h`.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`format` | ::mlir::IntegerAttr | IREE HAL Executable format
`data` | ::mlir::DenseIntElementsAttr | 8-bit signless integer elements attribute

### `hal.executable_cache.create` (IREE::HAL::ExecutableCacheCreateOp)

creates an executable cache

Syntax:

```
operation ::= `hal.executable_cache.create` $device `,` `identifier` `=` $identifier
              attr-dict-with-keyword `:` type($result)
```


Caches may be shared across multiple devices from the same driver or
specific to individual devices. Caches may persist prepared executables
across process launches or re-prepare them each run. Callers should assume
that the cache is a no-op and the returned hal.executables only live for as
long as the cache does.

The term 'cache' here is rather optimistic - it's perfectly acceptable for
implementations to not cache at all and return new hal.executables for each
preparation (even for the same executable). Callers should expect such
behavior and try to retain the results of the preparation to reduce overhead
from re-preparing executables.

Currently caches are synchronous but the intent is to support asynchronous
compilation of multiple executables with semaphores used to indicate when
the executables are ready for use.

```mlir
%cache = hal.executable_cache.create %device, identifier = "some_guid" : !hal.executable_cache
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`identifier` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable_cache

### `hal.executable_cache.prepare` (IREE::HAL::ExecutableCachePrepareOp)

synchronously prepares an executable for use

Syntax:

```
operation ::= `hal.executable_cache.prepare` $executable_cache `,` `layout` `=` $executable_layout `,`
              `caching_mode` `=` $caching_mode `,` $executable
              attr-dict-with-keyword `:` type($result)
```


The provided spec and data will be used to either lookup a previously
prepared executable in the cache or prepare a new one.

Depending on the driver preparation may take a non-trivial amount of time
(such as when JITing/etc). As the cache is internally synchronized callers
can issue preparation requests from multiple threads - even for the same
executables - and calls will block until preparation completes.

```mlir
%exe = hal.executable_cache.prepare %executable_cache,
                                    layout = %layout,
                                    caching_mode = "AllowPersistentCaching|AllowOptimization",
                                    @executable : !hal.executable
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`caching_mode` | ::mlir::IntegerAttr | valid ExecutableCachingMode
`executable` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`executable_cache` | executable_cache
`executable_layout` | executable_layout

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable

### `hal.executable_cache.select_format` (IREE::HAL::ExecutableCacheSelectFormatOp)

selects the preferred format from the given list

Syntax:

```
operation ::= `hal.executable_cache.select_format` $executable_cache `,` `available_formats` `=` $available_formats
              attr-dict-with-keyword `:` type($result)
```


Returns the index of the preferred format of the cache from the given set or
-1 if none can be used. Preparation may still fail if the particular version
or features required by the executable are not supported.

```mlir
// Returns indices 0 or 1 if either of the two inputs are usable or -1 otherwise.
%index = hal.executable_cache.select_format %cache, available_formats = [1447906369 : i32, 123482395 : i32] : i32
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`available_formats` | ::mlir::ArrayAttr | HAL executable format array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`executable_cache` | executable_cache

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | 32-bit signless integer

### `hal.executable_end` (IREE::HAL::ExecutableEndOp)

terminator pseudo-op for the executable op

Syntax:

```
operation ::= `hal.executable_end` attr-dict
```



### `hal.executable.entry_point` (IREE::HAL::ExecutableEntryPointOp)

executable entry point declaration

An entry point exported by the executable with statically-available
information describing the IO interface it uses and other dispatch metadata.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`ordinal` | ::mlir::IntegerAttr | 32-bit integer ordinal attribute
`interface` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
`signature` | ::mlir::TypeAttr | any type attribute

### `hal.executable_layout.create` (IREE::HAL::ExecutableLayoutCreateOp)

creates an executable layout

Syntax:

```
operation ::= `hal.executable_layout.create` $device `,` `set_layouts` `=` `[` $set_layouts `]` `,`
              `push_constants` `=` $push_constants
              attr-dict-with-keyword `:` type($result)
```


Creates an executable layout from the given descriptor sets and push
constant required size. Executable layouts can be shared across any
executable that uses the same layout and push constant information. Sharing
the layout between executables will reduce runtime binding overhead and it
is often worth the cost to allow a small number of unused bindings in one
executable such that it can share layouts with others that will be scheduled
adjacent to it.

```mlir
%set0 = hal.descriptor_set_layout.create ...
%set1 = hal.descriptor_set_layout.create ...
%layout = hal.executable_layout.create %device,
                                       set_layouts = [%set0, %set1],
                                       push_constants = 3 : !hal.executable_layout
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`push_constants` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`set_layouts` | descriptor_set_layout

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable_layout

### `hal.executable_layout.lookup` (IREE::HAL::ExecutableLayoutLookupOp)

executable layout cache lookup pseudo-op

Syntax:

```
operation ::= `hal.executable_layout.lookup` $device `,` `set_layouts` `=` $set_layouts
              (`,` `push_constants` `=` $push_constants^)?
              attr-dict-with-keyword `:` type($result)
```


Used during conversion to provide a placeholder for a globally cached and
possibly lazy-initialized executable layout.

```mlir
%layout = hal.executable_layout.lookup %device, set_layouts = [
  [
    #hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">,
    #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Write">
  ]
] : !hal.executable_layout
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`set_layouts` | ::mlir::ArrayAttr | array attribute
`push_constants` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable_layout

### `hal.executable.lookup` (IREE::HAL::ExecutableLookupOp)

executable cache lookup pseudo-op

Syntax:

```
operation ::= `hal.executable.lookup` $device `,` $executable attr-dict `:` type($result)
```


Used during conversion to provide a placeholder for a globally cached and
possibly lazy-initialized executable.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`executable` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | executable

### `hal.executable` (IREE::HAL::ExecutableOp)

target-specific executable module

An executable module representing a target-specific compiled
kernel/shader/etc.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute

### `hal.executable.target_end` (IREE::HAL::ExecutableTargetEndOp)

terminator pseudo-op for the executable target op

Syntax:

```
operation ::= `hal.executable.target_end` attr-dict
```



### `hal.executable.target` (IREE::HAL::ExecutableTargetOp)

target executable IR

The target IR for the executable. This can be preserved for debugging but
is usually removed during transformation.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`target_backend` | ::mlir::StringAttr | string attribute

### `hal.interface.binding` (IREE::HAL::InterfaceBindingOp)

executable IO binding description

Defines an IO binding used to pass buffers into the executable for loads and
stores. These bindings will be mapped into descriptor sets by the scheduler
based on device support and usage within the command buffer.

Bindings are typeless and only indicate a resource that is made available to
executables. The types that can be loaded-from and stored-into the binding
buffers are provided to backends by way of the `hal.interface.load.*` and
`hal.interface.store.*` ops.

Bindings do not need to correlate 1:1 with entry point arguments/results and
in many cases will not. For example, the same binding may be used with
different offsets if the arguments were packed into a ringbuffer/arena by
the scheduler.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`set` | ::mlir::IntegerAttr | 32-bit signless integer attribute
`binding` | ::mlir::IntegerAttr | 32-bit signless integer attribute
`type` | ::mlir::IntegerAttr | IREE HAL DescriptorType
`access` | ::mlir::IntegerAttr | valid MemoryAccess

### `hal.interface_end` (IREE::HAL::InterfaceEndOp)

terminator pseudo-op for the executable interface op

Syntax:

```
operation ::= `hal.interface_end` attr-dict
```



### `hal.interface.load.constant` (IREE::HAL::InterfaceLoadConstantOp)

loads a constant value from the interface constant block

Syntax:

```
operation ::= `hal.interface.load.constant` `offset` `=` $offset attr-dict `:` type($result)
```


Loads a scalar constant value from an executable IO push constant block.
The value will be loaded from the given constant offset and will be
bitcast (possibly with truncation or zero-extension) to the result type.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`offset` | ::mlir::IntegerAttr | size_t

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point

### `hal.interface.load.tensor` (IREE::HAL::InterfaceLoadTensorOp)

loads a tensor from an executable IO binding

Syntax:

```
operation ::= `hal.interface.load.tensor` $binding `,` `offset` `=` $offset attr-dict `:` type($result)
```


Loads a tensor value from an executable IO binding. This is a pseudo op
that can be used to tie SSA tensor values in the IR to the bindings that
contain those tensors.

Note that because there may not be a 1:1 mapping between original tensor
arguments to the entry point function and the bindings in the interface the
backend must use the offset provided on this op to properly compute the base
address of the tensor data. The offset is in bytes relative to the base
binding address, irrespective of the type of the tensor loaded by this
operation.

The offset provided, if non-zero, will have an alignment compatible with the
tensor type represented. For example, a `tensor<16xf32>` will be aligned on
at least a 4 byte boundary.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`binding` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`offset` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ranked tensor of any type values

### `hal.interface` (IREE::HAL::InterfaceOp)

executable IO interface description

Defines a set of IO bindings and associated information required for the
scheduler to correctly dispatch the executable. Multiple executable binaries
can share the same interface to reduce the amount of scheduling code
generated, or a single executable binary can expose entry points with
multiple different interfaces to allow for runtime selection based on
supported device capabilities.

The design is modeled on the Vulkan binding model, which uses one or more
descriptor sets containing one or more bindings as part of its API. By using
the same representation here we can get toll-free lowering on the Vulkan and
SPIR-V side, and for other backends that may have simpler models the cost is
negligable (just an extra indirection during dispatch). For more information
on the Vulkan binding model see the documentation (which contains GLSL,
SPIR-V, and Vulkan API examples that directly map to our use here):
https://vulkan.lunarg.com/doc/view/1.0.33.0/linux/vkspec.chunked/ch13s02.html

For background as to how multiple descriptor sets are used by the scheduler
see: https://developer.nvidia.com/vulkan-shader-resource-binding

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`push_constants` | ::mlir::IntegerAttr | 32-bit signless integer attribute

### `hal.interface.store.tensor` (IREE::HAL::InterfaceStoreTensorOp)

stores a tensor in an executable IO binding

Syntax:

```
operation ::= `hal.interface.store.tensor` $operand `,` $binding `,` `offset` `=` $offset attr-dict `:` type($operand)
```


Stores a tensor value into an executable IO binding. This is a pseudo op
indicating that the value of the operand tensor should be stored into the
specified binding.

Note that because there may not be a 1:1 mapping between original tensor
arguments to the entry point function and the bindings in the interface the
backend must use the offset provided on this op to properly compute the base
address of the tensor data. The offset is in bytes relative to the base
binding address, irrespective of the type of the tensor loaded by this
operation.

The offset provided, if non-zero, will have an alignment compatible with the
tensor type represented. For example, a `tensor<16xf32>` will be aligned on
at least a 4 byte boundary.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`binding` | ::mlir::SymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operand` | ranked tensor of any type values
`offset` | index

### `hal.make_buffer_barrier` (IREE::HAL::MakeBufferBarrierOp)

temporary buffer barrier allocation operation

Syntax:

```
operation ::= `hal.make_buffer_barrier` $source_scope `,` $target_scope `,` operands attr-dict-with-keyword `:`
              type($result)
```


Allocates a temporary BufferBarrier struct that can be passed to the
command buffer barrier operations.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`source_scope` | ::mlir::IntegerAttr | valid AccessScope
`target_scope` | ::mlir::IntegerAttr | valid AccessScope

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`buffer` | buffer
`offset` | index
`length` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | BufferBarrier

### `hal.make_memory_barrier` (IREE::HAL::MakeMemoryBarrierOp)

temporary memory barrier allocation operation

Syntax:

```
operation ::= `hal.make_memory_barrier` $source_scope `,` $target_scope attr-dict-with-keyword `:` type($result)
```


Allocates a temporary MemoryBarrier struct that can be passed to the
command buffer barrier operations.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`source_scope` | ::mlir::IntegerAttr | valid AccessScope
`target_scope` | ::mlir::IntegerAttr | valid AccessScope

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | MemoryBarrier

### `hal.return` (IREE::HAL::ReturnOp)

return from a hal.device.switch region

Syntax:

```
operation ::= `hal.return` attr-dict ($operands^ `:` type($operands))?
```


Returns the given values from the region and back to the host code.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | any type

### `hal.semaphore.await` (IREE::HAL::SemaphoreAwaitOp)

asynchronous semaphore wait operation

Syntax:

```
operation ::= `hal.semaphore.await` $semaphore `,` `min_value` `=` $min_value attr-dict-with-keyword `:` type($status)
```


Yields the caller until the semaphore reaches or exceeds the specified
payload `min_value`. Returns the `status` of the semaphore after the wait,
with a non-zero value indicating failure.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore
`min_value` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`status` | 32-bit signless integer

### `hal.semaphore.create` (IREE::HAL::SemaphoreCreateOp)

semaphore allocation operation

Syntax:

```
operation ::= `hal.semaphore.create` $device `,` `initial_value` `=` $initial_value
              attr-dict-with-keyword `:` type($result)
```


Returns a semaphore from the device pool with the given initial value.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`device` | device
`initial_value` | index

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | semaphore

### `hal.semaphore.fail` (IREE::HAL::SemaphoreFailOp)

semaphore asynchronous failure operation

Syntax:

```
operation ::= `hal.semaphore.fail` $semaphore `,` `status` `=` $status attr-dict-with-keyword
```


Signals the semaphore with a failure. The `status` will be returned from
`hal.semaphore.query` and `hal.semaphore.signal` for the lifetime
of the semaphore.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore
`status` | 32-bit signless integer

### `hal.semaphore.query` (IREE::HAL::SemaphoreQueryOp)

semaphore payload value query

Syntax:

```
operation ::= `hal.semaphore.query` $semaphore attr-dict-with-keyword `:` type($status) `,` type($value)
```


Queries the current payload and returns a tuple of `(status, value)`.
As the payload is monotonically increasing it is guaranteed that
the value is at least equal to the previous result of a
`hal.semaphore.signal` call and coherent with any waits for a
specified value via `hal.semaphore.await`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore

#### Results:

| Result | Description |
| :----: | ----------- |
`status` | 32-bit signless integer
`value` | index

### `hal.semaphore.signal` (IREE::HAL::SemaphoreSignalOp)

semaphore payload value signal operation

Syntax:

```
operation ::= `hal.semaphore.signal` $semaphore `,` `value` `=` $new_value attr-dict-with-keyword
```


Signals the semaphore to the given payload value.
The call is ignored if the current payload value exceeds `new_value`.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`semaphore` | semaphore
`new_value` | index

### `hal.variable.address` (IREE::HAL::VariableAddressOp)

returns an address reference to a variable

Syntax:

```
operation ::= `hal.variable.address` $variable attr-dict `:` type($result)
```


Returns the address of a variable as a typed reference. Can be used with the
variable load and store indirect ops.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`variable` | FlatSymbolRefAttr | symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | ptr<index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore>

### `hal.variable.load` (IREE::HAL::VariableLoadOp)

loads a value from a global variable

Syntax:

```
operation ::= `hal.variable.load` $variable attr-dict `:` type($result)
```


Returns a copy of the variable value.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`variable` | FlatSymbolRefAttr | symbol reference attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`result` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore

### `hal.variable` (IREE::HAL::VariableOp)

stateful variable declaration

Declares a global variable that maintains its value across invocations.
The value is tied to the execution context of the module and different
contexts will have different variable storage.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`sym_name` | ::mlir::StringAttr | string attribute
`type` | ::mlir::TypeAttr | any type attribute
`is_mutable` | ::mlir::UnitAttr | unit attribute
`initializer` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute
`initial_value` | ::mlir::Attribute | any attribute

### `hal.variable.store.indirect` (IREE::HAL::VariableStoreIndirectOp)

stores a value into a global variable

Syntax:

```
operation ::= `hal.variable.store.indirect` $value `,` $variable attr-dict `:` type($value) `->` type($variable)
```


Stores a copy of the value into a variable.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore
`variable` | ptr<index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore>

### `hal.variable.store` (IREE::HAL::VariableStoreOp)

stores a value into a global variable

Syntax:

```
operation ::= `hal.variable.store` $value `,` $variable attr-dict `:` type($value)
```


Stores a copy of the value into a variable.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`variable` | FlatSymbolRefAttr | symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`value` | index or signless integer or floating-point or vector of any type values or allocator or buffer or buffer_view or command_buffer or descriptor_set or descriptor_set_layout or device or event or executable or executable_cache or executable_layout or ring_buffer or semaphore
