---
layout: default
permalink: ir-examples/mhlo-dot-dylib-llvm-aot
title: "mhlo-dot on dylib-llvm-aot"
parent: IR Conversion Examples
---

# mhlo-dot on dylib-llvm-aot
{: .no_toc }

This is an IR conversion example auto-generated by running `iree-opt`
over [mhlo-dot](https://github.com/google/iree/tree/main/iree/samples/ops/mhlo-dot.mlir).

### The command

```shell
iree-opt -iree-transformation-pipeline \
  -iree-hal-target-backends=dylib-llvm-aot \
  --print-ir-after-all \
  -mlir-disable-threading \
  -mlir-elide-elementsattrs-if-larger=8 \
  iree/samples/ops/mhlo-dot.mlir

```
### Input IR

```
func @dot(%lhs: tensor<32x1024xf32>, %rhs: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes { iree.module.export } {
  %0 = "mhlo.dot"(%lhs, %rhs) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}
```
### IR Dump After Canonicalizer
```
module  {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::mhlo::{anonymous}::LegalizeControlFlowPass
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::HLOToHLOPreprocessing
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After RemoveShapeConstraints
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ConvertShapeToShapex
```
module  {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::FlattenTuplesInCFGPass
```
module  {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Inliner
```
module  {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::LegalizeInputTypesPass
```
module  {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::MaterializeExportedReflectionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {f_partial = "I12!B9!d32d1024"}}, %arg1: tensor<1024x64xf32> {iree.reflection = {f_partial = "I12!B9!d1024d64"}}) -> (tensor<32x64xf32> {iree.reflection = {f_partial = "R10!B7!d32d64"}}) attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ExpandFunctionDynamicDimsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {f_partial = "I12!B9!d32d1024"}}, %arg1: tensor<1024x64xf32> {iree.reflection = {f_partial = "I12!B9!d1024d64"}}) -> (tensor<32x64xf32> {iree.reflection = {f_partial = "R10!B7!d32d64"}}) attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::MergeExportedReflectionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::TieDynamicShapesPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::MaterializeShapeCalculationsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::HoistShapeCalculations
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::PrePartitioningConversionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::DispatchabilityAnalysisPass
```
module  {
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::IdentifyDispatchRegions2Pass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::FoldCompatibleDispatchRegionsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::RematerializeDispatchConstantsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::OutlineDispatchRegionsPass
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::OutlineDispatchRegions2Pass
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::DeduplicateExecutablesPass
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::PostPartitioningConversionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::HoistUnstreamableOps
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::FormStreamsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::OutlineLargeConstantsPass
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After SymbolDCE
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::IdentifyConstantPoolsPass
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeConstantPoolBuffersPass
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After SymbolDCE
```
module  {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0 attributes {signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module  {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeInterfacesPass
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module  {
        func @dot_ex_dispatch_0() {
          %c0 = constant 0 : index
          %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
          %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
          %2 = call @dot_ex_dispatch_0_impl(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
          hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
          return
        }
        func private @dot_ex_dispatch_0_impl(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
          %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
          return %0 : tensor<32x64xf32>
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::PropagateConstantWorkgroupInfoPass
```
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
  module  {
    func @dot_ex_dispatch_0() {
      %c0 = constant 0 : index
      %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
      %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
      %2 = call @dot_ex_dispatch_0_impl(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
      return
    }
    func private @dot_ex_dispatch_0_impl(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      return %0 : tensor<32x64xf32>
    }
    hal.interface @legacy_io attributes {sym_visibility = "private"} {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::DeclareNumWorkgroupsFnPass
```
module  {
  func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)
  func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
    %c0 = constant 0 : index
    %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
    %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
    %2 = call @dot_ex_dispatch_0_impl(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
    return
  }
  func private @dot_ex_dispatch_0_impl(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After Canonicalizer
```
func private @dot_ex_dispatch_0_impl(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = call @dot_ex_dispatch_0_impl(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After Canonicalizer
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After Inliner
```
module  {
  func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)
  func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
    %c0 = constant 0 : index
    %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
    %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
    %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::TieDynamicShapesPass
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::TieDynamicShapesPass
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::MaterializeShapeCalculationsPass
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::MaterializeShapeCalculationsPass
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::HoistShapeCalculations
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::HoistShapeCalculations
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::DecomposeHLOClampPass
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After mlir::iree_compiler::{anonymous}::DecomposeHLOClampPass
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertHLOToLinalgOnTensorsPass
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertHLOToLinalgOnTensorsPass
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After LinalgFoldUnitExtentDims
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After LinalgFoldUnitExtentDims
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After Canonicalizer
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After Canonicalizer
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::FusionOfTensorOpsPass
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After mlir::iree_compiler::{anonymous}::FusionOfTensorOpsPass
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After CSE
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After CSE
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 {operand_result_index = 0 : i32} : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 {operand_result_index = 1 : i32} : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 {operand_result_index = 2 : i32} : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertHLOToLinalgOnBuffersPass
```
func private @dot_ex_dispatch_0__num_workgroups__(!shapex.ranked_shape<[32,1024]>, !shapex.ranked_shape<[1024,64]>, !shapex.ranked_shape<[32,64]>) -> (index, index, index)

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertHLOToLinalgOnBuffersPass
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %c0 = constant 0 : index
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %cst = constant 0.000000e+00 : f32
  linalg.fill(%0, %cst) : memref<32x64xf32>, f32
  linalg.matmul ins(%1, %2 : memref<32x1024xf32>, memref<1024x64xf32>) outs(%0 : memref<32x64xf32>)
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::LinalgTileAndDistributePass
```
module  {
  func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
    %c0 = constant 0 : index
    %3 = dim %0, %c0 : memref<32x1024xf32>
    %c1 = constant 1 : index
    %4 = dim %0, %c1 : memref<32x1024xf32>
    %c0_0 = constant 0 : index
    %5 = dim %1, %c0_0 : memref<1024x64xf32>
    %c1_1 = constant 1 : index
    %6 = dim %1, %c1_1 : memref<1024x64xf32>
    %c0_2 = constant 0 : index
    %7 = dim %2, %c0_2 : memref<32x64xf32>
    %c1_3 = constant 1 : index
    %8 = dim %2, %c1_3 : memref<32x64xf32>
    %c0_4 = constant 0 : index
    %c1_5 = constant 1 : index
    %c64 = constant 64 : index
    %c1_6 = constant 1 : index
    %9 = subi %c64, %c1_6 : index
    %10 = addi %3, %9 : index
    %11 = divi_signed %10, %c64 : index
    %c64_7 = constant 64 : index
    %c1_8 = constant 1 : index
    %12 = subi %c64_7, %c1_8 : index
    %13 = addi %6, %12 : index
    %14 = divi_signed %13, %c64_7 : index
    %c1_9 = constant 1 : index
    return %14, %11, %c1_9 : index, index, index
  }
  func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
    %cst = constant 0.000000e+00 : f32
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
    %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
    %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
    %9 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
    %10 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %11 = subview %0[%8, %10] [%9, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %12 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    linalg.fill(%12, %cst) {__internal_linalg_transform__ = "workgroup"} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>, f32
    linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>, memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>) outs(%11 : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>)
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::LegalizeNumWorkgroupsFnPass
```
module  {
  func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
    %c1 = constant 1 : index
    return %c1, %c1, %c1 : index, index, index
  }
  func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
    %cst = constant 0.000000e+00 : f32
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
    %workgroup_id_x = hal.interface.workgroup.id[0] : index
    %workgroup_id_y = hal.interface.workgroup.id[1] : index
    %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
    %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
    %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
    %9 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
    %10 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
    %11 = subview %0[%8, %10] [%9, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %12 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    linalg.fill(%12, %cst) {__internal_linalg_transform__ = "workgroup"} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>, f32
    linalg.matmul {__internal_linalg_transform__ = "workgroup"} ins(%5, %7 : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>, memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>) outs(%11 : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>)
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::TileAndVectorizeWorkgroups
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::TileAndVectorizeWorkgroups
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c64 = constant 64 : index
  %c0 = constant 0 : index
  %c4 = constant 4 : index
  %c32 = constant 32 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %9 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %11 = subview %0[%8, %10] [%9, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %12 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  linalg.fill(%12, %cst) {__internal_linalg_transform__ = "workgroup"} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>, f32
  scf.for %arg0 = %c0 to %4 step %c32 {
    scf.for %arg1 = %c0 to %c64 step %c32 {
      scf.for %arg2 = %c0 to %c1024 step %c32 {
        %13 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%4]
        %14 = subview %5[%arg0, %arg2] [%13, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
        %15 = subview %7[%arg2, %arg1] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %16 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%9]
        %17 = subview %11[%arg0, %arg1] [%16, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        scf.for %arg3 = %c0 to %13 step %c4 {
          scf.for %arg4 = %c0 to %c32 step %c4 {
            scf.for %arg5 = %c0 to %c32 step %c4 {
              %18 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%13, %arg3)
              %19 = subview %14[%arg3, %arg5] [%18, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
              %20 = subview %15[%arg5, %arg4] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg3)
              %22 = subview %17[%arg3, %arg4] [%21, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              linalg.matmul {__internal_linalg_transform__ = "vectorize"} ins(%19, %20 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>, memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>) outs(%22 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>)
            }
          }
        }
      }
    }
  }
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::PlanConvLoopOrderPass
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::PlanConvLoopOrderPass
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c64 = constant 64 : index
  %c0 = constant 0 : index
  %c4 = constant 4 : index
  %c32 = constant 32 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %9 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %11 = subview %0[%8, %10] [%9, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %12 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  linalg.fill(%12, %cst) {__internal_linalg_transform__ = "workgroup"} : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>, f32
  scf.for %arg0 = %c0 to %4 step %c32 {
    scf.for %arg1 = %c0 to %c64 step %c32 {
      scf.for %arg2 = %c0 to %c1024 step %c32 {
        %13 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%4]
        %14 = subview %5[%arg0, %arg2] [%13, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
        %15 = subview %7[%arg2, %arg1] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %16 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%9]
        %17 = subview %11[%arg0, %arg1] [%16, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        scf.for %arg3 = %c0 to %13 step %c4 {
          scf.for %arg4 = %c0 to %c32 step %c4 {
            scf.for %arg5 = %c0 to %c32 step %c4 {
              %18 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%13, %arg3)
              %19 = subview %14[%arg3, %arg5] [%18, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
              %20 = subview %15[%arg5, %arg4] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg3)
              %22 = subview %17[%arg3, %arg4] [%21, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              linalg.matmul {__internal_linalg_transform__ = "vectorize"} ins(%19, %20 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>, memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>) outs(%22 : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>)
            }
          }
        }
      }
    }
  }
  return
}

```
### IR Dump After LinalgLowerToLoops
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After LinalgLowerToLoops
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %9 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %11 = subview %0[%8, %10] [%9, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %12 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  scf.for %arg0 = %c0 to %4 step %c1 {
    scf.for %arg1 = %c0 to %c64 step %c1 {
      store %cst, %12[%arg0, %arg1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    }
  }
  scf.for %arg0 = %c0 to %4 step %c32 {
    scf.for %arg1 = %c0 to %c64 step %c32 {
      scf.for %arg2 = %c0 to %c1024 step %c32 {
        %13 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%4]
        %14 = subview %5[%arg0, %arg2] [%13, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
        %15 = subview %7[%arg2, %arg1] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %16 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%9]
        %17 = subview %11[%arg0, %arg1] [%16, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        scf.for %arg3 = %c0 to %13 step %c4 {
          scf.for %arg4 = %c0 to %c32 step %c4 {
            scf.for %arg5 = %c0 to %c32 step %c4 {
              %18 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%13, %arg3)
              %19 = subview %14[%arg3, %arg5] [%18, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
              %20 = subview %15[%arg5, %arg4] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg3)
              %22 = subview %17[%arg3, %arg4] [%21, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              scf.for %arg6 = %c0 to %18 step %c1 {
                scf.for %arg7 = %c0 to %c4 step %c1 {
                  scf.for %arg8 = %c0 to %c4 step %c1 {
                    %23 = load %19[%arg6, %arg8] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
                    %24 = load %20[%arg8, %arg7] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                    %25 = load %22[%arg6, %arg7] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                    %26 = mulf %23, %24 : f32
                    %27 = addf %25, %26 : f32
                    store %27, %22[%arg6, %arg7] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

```
### IR Dump After Canonicalizer
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After Canonicalizer
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %9 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %10 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %11 = subview %0[%8, %10] [%9, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %12 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  scf.for %arg0 = %c0 to %4 step %c1 {
    scf.for %arg1 = %c0 to %c64 step %c1 {
      store %cst, %12[%arg0, %arg1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    }
  }
  scf.for %arg0 = %c0 to %4 step %c32 {
    scf.for %arg1 = %c0 to %c64 step %c32 {
      scf.for %arg2 = %c0 to %c1024 step %c32 {
        %13 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%4]
        %14 = subview %5[%arg0, %arg2] [%13, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
        %15 = subview %7[%arg2, %arg1] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %16 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%9]
        %17 = subview %11[%arg0, %arg1] [%16, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        scf.for %arg3 = %c0 to %13 step %c4 {
          scf.for %arg4 = %c0 to %c32 step %c4 {
            scf.for %arg5 = %c0 to %c32 step %c4 {
              %18 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%13, %arg3)
              %19 = subview %14[%arg3, %arg5] [%18, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
              %20 = subview %15[%arg5, %arg4] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              %21 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%16, %arg3)
              %22 = subview %17[%arg3, %arg4] [%21, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              scf.for %arg6 = %c0 to %18 step %c1 {
                scf.for %arg7 = %c0 to %c4 step %c1 {
                  scf.for %arg8 = %c0 to %c4 step %c1 {
                    %23 = load %19[%arg6, %arg8] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
                    %24 = load %20[%arg8, %arg7] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                    %25 = load %22[%arg6, %arg7] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                    %26 = mulf %23, %24 : f32
                    %27 = addf %25, %26 : f32
                    store %27, %22[%arg6, %arg7] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

```
### IR Dump After CSE
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After CSE
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  scf.for %arg0 = %c0 to %4 step %c1 {
    scf.for %arg1 = %c0 to %c64 step %c1 {
      store %cst, %8[%arg0, %arg1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    }
  }
  scf.for %arg0 = %c0 to %4 step %c32 {
    scf.for %arg1 = %c0 to %c64 step %c32 {
      scf.for %arg2 = %c0 to %c1024 step %c32 {
        %9 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%arg0)[%4]
        %10 = subview %5[%arg0, %arg2] [%9, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
        %11 = subview %7[%arg2, %arg1] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %12 = subview %8[%arg0, %arg1] [%9, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        scf.for %arg3 = %c0 to %9 step %c4 {
          scf.for %arg4 = %c0 to %c32 step %c4 {
            scf.for %arg5 = %c0 to %c32 step %c4 {
              %13 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%9, %arg3)
              %14 = subview %10[%arg3, %arg5] [%13, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
              %15 = subview %11[%arg5, %arg4] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              %16 = subview %12[%arg3, %arg4] [%13, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
              scf.for %arg6 = %c0 to %13 step %c1 {
                scf.for %arg7 = %c0 to %c4 step %c1 {
                  scf.for %arg8 = %c0 to %c4 step %c1 {
                    %17 = load %14[%arg6, %arg8] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
                    %18 = load %15[%arg8, %arg7] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                    %19 = load %16[%arg6, %arg7] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                    %20 = mulf %17, %18 : f32
                    %21 = addf %19, %20 : f32
                    store %21, %16[%arg6, %arg7] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return
}

```
### IR Dump After SCFToStandard
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After SCFToStandard
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb1(%c0 : index)
^bb1(%9: index):  // 2 preds: ^bb0, ^bb5
  %10 = cmpi "slt", %9, %4 : index
  cond_br %10, ^bb2, ^bb6
^bb2:  // pred: ^bb1
  br ^bb3(%c0 : index)
^bb3(%11: index):  // 2 preds: ^bb2, ^bb4
  %12 = cmpi "slt", %11, %c64 : index
  cond_br %12, ^bb4, ^bb5
^bb4:  // pred: ^bb3
  store %cst, %8[%9, %11] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %13 = addi %11, %c1 : index
  br ^bb3(%13 : index)
^bb5:  // pred: ^bb3
  %14 = addi %9, %c1 : index
  br ^bb1(%14 : index)
^bb6:  // pred: ^bb1
  br ^bb7(%c0 : index)
^bb7(%15: index):  // 2 preds: ^bb6, ^bb32
  %16 = cmpi "slt", %15, %4 : index
  cond_br %16, ^bb8, ^bb33
^bb8:  // pred: ^bb7
  br ^bb9(%c0 : index)
^bb9(%17: index):  // 2 preds: ^bb8, ^bb31
  %18 = cmpi "slt", %17, %c64 : index
  cond_br %18, ^bb10, ^bb32
^bb10:  // pred: ^bb9
  br ^bb11(%c0 : index)
^bb11(%19: index):  // 2 preds: ^bb10, ^bb30
  %20 = cmpi "slt", %19, %c1024 : index
  cond_br %20, ^bb12, ^bb31
^bb12:  // pred: ^bb11
  %21 = affine.min affine_map<(d0)[s0] -> (32, -d0 + s0)>(%15)[%4]
  %22 = subview %5[%15, %19] [%21, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %23 = subview %7[%19, %17] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %24 = subview %8[%15, %17] [%21, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb13(%c0 : index)
^bb13(%25: index):  // 2 preds: ^bb12, ^bb29
  %26 = cmpi "slt", %25, %21 : index
  cond_br %26, ^bb14, ^bb30
^bb14:  // pred: ^bb13
  br ^bb15(%c0 : index)
^bb15(%27: index):  // 2 preds: ^bb14, ^bb28
  %28 = cmpi "slt", %27, %c32 : index
  cond_br %28, ^bb16, ^bb29
^bb16:  // pred: ^bb15
  br ^bb17(%c0 : index)
^bb17(%29: index):  // 2 preds: ^bb16, ^bb27
  %30 = cmpi "slt", %29, %c32 : index
  cond_br %30, ^bb18, ^bb28
^bb18:  // pred: ^bb17
  %31 = affine.min affine_map<(d0, d1) -> (4, d0 - d1)>(%21, %25)
  %32 = subview %22[%25, %29] [%31, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %33 = subview %23[%29, %27] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %34 = subview %24[%25, %27] [%31, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb19(%c0 : index)
^bb19(%35: index):  // 2 preds: ^bb18, ^bb26
  %36 = cmpi "slt", %35, %31 : index
  cond_br %36, ^bb20, ^bb27
^bb20:  // pred: ^bb19
  br ^bb21(%c0 : index)
^bb21(%37: index):  // 2 preds: ^bb20, ^bb25
  %38 = cmpi "slt", %37, %c4 : index
  cond_br %38, ^bb22, ^bb26
^bb22:  // pred: ^bb21
  br ^bb23(%c0 : index)
^bb23(%39: index):  // 2 preds: ^bb22, ^bb24
  %40 = cmpi "slt", %39, %c4 : index
  cond_br %40, ^bb24, ^bb25
^bb24:  // pred: ^bb23
  %41 = load %32[%35, %39] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %42 = load %33[%39, %37] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %43 = load %34[%35, %37] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %44 = mulf %41, %42 : f32
  %45 = addf %43, %44 : f32
  store %45, %34[%35, %37] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %46 = addi %39, %c1 : index
  br ^bb23(%46 : index)
^bb25:  // pred: ^bb23
  %47 = addi %37, %c1 : index
  br ^bb21(%47 : index)
^bb26:  // pred: ^bb21
  %48 = addi %35, %c1 : index
  br ^bb19(%48 : index)
^bb27:  // pred: ^bb19
  %49 = addi %29, %c4 : index
  br ^bb17(%49 : index)
^bb28:  // pred: ^bb17
  %50 = addi %27, %c4 : index
  br ^bb15(%50 : index)
^bb29:  // pred: ^bb15
  %51 = addi %25, %c4 : index
  br ^bb13(%51 : index)
^bb30:  // pred: ^bb13
  %52 = addi %19, %c32 : index
  br ^bb11(%52 : index)
^bb31:  // pred: ^bb11
  %53 = addi %17, %c32 : index
  br ^bb9(%53 : index)
^bb32:  // pred: ^bb9
  %54 = addi %15, %c32 : index
  br ^bb7(%54 : index)
^bb33:  // pred: ^bb7
  return
}

```
### IR Dump After Canonicalizer
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After Canonicalizer
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb1(%c0 : index)
^bb1(%9: index):  // 2 preds: ^bb0, ^bb4
  %10 = cmpi "slt", %9, %4 : index
  cond_br %10, ^bb2(%c0 : index), ^bb5(%c0 : index)
^bb2(%11: index):  // 2 preds: ^bb1, ^bb3
  %12 = cmpi "slt", %11, %c64 : index
  cond_br %12, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  store %cst, %8[%9, %11] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %13 = addi %11, %c1 : index
  br ^bb2(%13 : index)
^bb4:  // pred: ^bb2
  %14 = addi %9, %c1 : index
  br ^bb1(%14 : index)
^bb5(%15: index):  // 2 preds: ^bb1, ^bb24
  %16 = cmpi "slt", %15, %4 : index
  cond_br %16, ^bb6(%c0 : index), ^bb25
^bb6(%17: index):  // 2 preds: ^bb5, ^bb23
  %18 = cmpi "slt", %17, %c64 : index
  cond_br %18, ^bb7(%c0 : index), ^bb24
^bb7(%19: index):  // 2 preds: ^bb6, ^bb22
  %20 = cmpi "slt", %19, %c1024 : index
  cond_br %20, ^bb8, ^bb23
^bb8:  // pred: ^bb7
  %21 = affine.min affine_map<()[s0, s1] -> (32, -s1 + s0)>()[%4, %15]
  %22 = subview %5[%15, %19] [%21, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %23 = subview %7[%19, %17] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %24 = subview %8[%15, %17] [%21, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb9(%c0 : index)
^bb9(%25: index):  // 2 preds: ^bb8, ^bb21
  %26 = cmpi "slt", %25, %21 : index
  cond_br %26, ^bb10(%c0 : index), ^bb22
^bb10(%27: index):  // 2 preds: ^bb9, ^bb20
  %28 = cmpi "slt", %27, %c32 : index
  cond_br %28, ^bb11(%c0 : index), ^bb21
^bb11(%29: index):  // 2 preds: ^bb10, ^bb19
  %30 = cmpi "slt", %29, %c32 : index
  cond_br %30, ^bb12, ^bb20
^bb12:  // pred: ^bb11
  %31 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%21, %25]
  %32 = subview %22[%25, %29] [%31, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %33 = subview %23[%29, %27] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %34 = subview %24[%25, %27] [%31, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb13(%c0 : index)
^bb13(%35: index):  // 2 preds: ^bb12, ^bb18
  %36 = cmpi "slt", %35, %31 : index
  cond_br %36, ^bb14(%c0 : index), ^bb19
^bb14(%37: index):  // 2 preds: ^bb13, ^bb17
  %38 = cmpi "slt", %37, %c4 : index
  cond_br %38, ^bb15(%c0 : index), ^bb18
^bb15(%39: index):  // 2 preds: ^bb14, ^bb16
  %40 = cmpi "slt", %39, %c4 : index
  cond_br %40, ^bb16, ^bb17
^bb16:  // pred: ^bb15
  %41 = load %32[%35, %39] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %42 = load %33[%39, %37] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %43 = load %34[%35, %37] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %44 = mulf %41, %42 : f32
  %45 = addf %43, %44 : f32
  store %45, %34[%35, %37] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %46 = addi %39, %c1 : index
  br ^bb15(%46 : index)
^bb17:  // pred: ^bb15
  %47 = addi %37, %c1 : index
  br ^bb14(%47 : index)
^bb18:  // pred: ^bb14
  %48 = addi %35, %c1 : index
  br ^bb13(%48 : index)
^bb19:  // pred: ^bb13
  %49 = addi %29, %c4 : index
  br ^bb11(%49 : index)
^bb20:  // pred: ^bb11
  %50 = addi %27, %c4 : index
  br ^bb10(%50 : index)
^bb21:  // pred: ^bb10
  %51 = addi %25, %c4 : index
  br ^bb9(%51 : index)
^bb22:  // pred: ^bb9
  %52 = addi %19, %c32 : index
  br ^bb7(%52 : index)
^bb23:  // pred: ^bb7
  %53 = addi %17, %c32 : index
  br ^bb6(%53 : index)
^bb24:  // pred: ^bb6
  %54 = addi %15, %c32 : index
  br ^bb5(%54 : index)
^bb25:  // pred: ^bb5
  return
}

```
### IR Dump After CSE
```
func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
  %c1 = constant 1 : index
  return %c1, %c1, %c1 : index, index, index
}

```
### IR Dump After CSE
```
func @dot_ex_dispatch_0() attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
  %cst = constant 0.000000e+00 : f32
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c4 = constant 4 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0, operand_result_index = 2 : i32} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0, operand_result_index = 0 : i32} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1, operand_result_index = 1 : i32} : memref<1024x64xf32>
  %workgroup_id_x = hal.interface.workgroup.id[0] : index
  %workgroup_id_y = hal.interface.workgroup.id[1] : index
  %3 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_y]
  %4 = affine.min affine_map<()[s0] -> (64, s0 * -64 + 32)>()[%workgroup_id_y]
  %5 = subview %1[%3, 0] [%4, 1024] [1, 1] : memref<32x1024xf32> to memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %6 = affine.apply affine_map<()[s0] -> (s0 * 64)>()[%workgroup_id_x]
  %7 = subview %2[0, %6] [1024, 64] [1, 1] : memref<1024x64xf32> to memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %8 = subview %0[%3, %6] [%4, 64] [1, 1] : memref<32x64xf32> to memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb1(%c0 : index)
^bb1(%9: index):  // 2 preds: ^bb0, ^bb4
  %10 = cmpi "slt", %9, %4 : index
  cond_br %10, ^bb2(%c0 : index), ^bb5(%c0 : index)
^bb2(%11: index):  // 2 preds: ^bb1, ^bb3
  %12 = cmpi "slt", %11, %c64 : index
  cond_br %12, ^bb3, ^bb4
^bb3:  // pred: ^bb2
  store %cst, %8[%9, %11] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %13 = addi %11, %c1 : index
  br ^bb2(%13 : index)
^bb4:  // pred: ^bb2
  %14 = addi %9, %c1 : index
  br ^bb1(%14 : index)
^bb5(%15: index):  // 2 preds: ^bb1, ^bb24
  %16 = cmpi "slt", %15, %4 : index
  cond_br %16, ^bb6(%c0 : index), ^bb25
^bb6(%17: index):  // 2 preds: ^bb5, ^bb23
  %18 = cmpi "slt", %17, %c64 : index
  cond_br %18, ^bb7(%c0 : index), ^bb24
^bb7(%19: index):  // 2 preds: ^bb6, ^bb22
  %20 = cmpi "slt", %19, %c1024 : index
  cond_br %20, ^bb8, ^bb23
^bb8:  // pred: ^bb7
  %21 = affine.min affine_map<()[s0, s1] -> (32, -s1 + s0)>()[%4, %15]
  %22 = subview %5[%15, %19] [%21, 32] [1, 1] : memref<?x1024xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %23 = subview %7[%19, %17] [32, 32] [1, 1] : memref<1024x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %24 = subview %8[%15, %17] [%21, 32] [1, 1] : memref<?x64xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb9(%c0 : index)
^bb9(%25: index):  // 2 preds: ^bb8, ^bb21
  %26 = cmpi "slt", %25, %21 : index
  cond_br %26, ^bb10(%c0 : index), ^bb22
^bb10(%27: index):  // 2 preds: ^bb9, ^bb20
  %28 = cmpi "slt", %27, %c32 : index
  cond_br %28, ^bb11(%c0 : index), ^bb21
^bb11(%29: index):  // 2 preds: ^bb10, ^bb19
  %30 = cmpi "slt", %29, %c32 : index
  cond_br %30, ^bb12, ^bb20
^bb12:  // pred: ^bb11
  %31 = affine.min affine_map<()[s0, s1] -> (4, s0 - s1)>()[%21, %25]
  %32 = subview %22[%25, %29] [%31, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %33 = subview %23[%29, %27] [4, 4] [1, 1] : memref<32x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %34 = subview %24[%25, %27] [%31, 4] [1, 1] : memref<?x32xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>> to memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  br ^bb13(%c0 : index)
^bb13(%35: index):  // 2 preds: ^bb12, ^bb18
  %36 = cmpi "slt", %35, %31 : index
  cond_br %36, ^bb14(%c0 : index), ^bb19
^bb14(%37: index):  // 2 preds: ^bb13, ^bb17
  %38 = cmpi "slt", %37, %c4 : index
  cond_br %38, ^bb15(%c0 : index), ^bb18
^bb15(%39: index):  // 2 preds: ^bb14, ^bb16
  %40 = cmpi "slt", %39, %c4 : index
  cond_br %40, ^bb16, ^bb17
^bb16:  // pred: ^bb15
  %41 = load %32[%35, %39] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
  %42 = load %33[%39, %37] : memref<4x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %43 = load %34[%35, %37] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %44 = mulf %41, %42 : f32
  %45 = addf %43, %44 : f32
  store %45, %34[%35, %37] : memref<?x4xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
  %46 = addi %39, %c1 : index
  br ^bb15(%46 : index)
^bb17:  // pred: ^bb15
  %47 = addi %37, %c1 : index
  br ^bb14(%47 : index)
^bb18:  // pred: ^bb14
  %48 = addi %35, %c1 : index
  br ^bb13(%48 : index)
^bb19:  // pred: ^bb13
  %49 = addi %29, %c4 : index
  br ^bb11(%49 : index)
^bb20:  // pred: ^bb11
  %50 = addi %27, %c4 : index
  br ^bb10(%50 : index)
^bb21:  // pred: ^bb10
  %51 = addi %25, %c4 : index
  br ^bb9(%51 : index)
^bb22:  // pred: ^bb9
  %52 = addi %19, %c32 : index
  br ^bb7(%52 : index)
^bb23:  // pred: ^bb7
  %53 = addi %17, %c32 : index
  br ^bb6(%53 : index)
^bb24:  // pred: ^bb6
  %54 = addi %15, %c32 : index
  br ^bb5(%54 : index)
^bb25:  // pred: ^bb5
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertToLLVMPass
```
module  {
  func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
    %c1 = constant 1 : index
    return %c1, %c1, %c1 : index, index, index
  }
  llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
    %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
    %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
    %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %6 = llvm.mlir.constant(0 : index) : !llvm.i64
    %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = llvm.mlir.constant(32 : index) : !llvm.i64
    %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %12 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %13 = llvm.insertvalue %12, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.mlir.constant(1 : index) : !llvm.i64
    %15 = llvm.insertvalue %14, %13[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %17 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %20 = llvm.mlir.constant(0 : index) : !llvm.i64
    %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %23 = llvm.insertvalue %22, %21[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %24 = llvm.mlir.constant(64 : index) : !llvm.i64
    %25 = llvm.insertvalue %24, %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.mlir.constant(64 : index) : !llvm.i64
    %27 = llvm.insertvalue %26, %25[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.mlir.constant(1 : index) : !llvm.i64
    %29 = llvm.insertvalue %28, %27[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %31 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.mlir.constant(0 : index) : !llvm.i64
    %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.mlir.constant(32 : index) : !llvm.i64
    %37 = llvm.insertvalue %36, %35[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.mlir.constant(64 : index) : !llvm.i64
    %39 = llvm.insertvalue %38, %37[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %40 = llvm.mlir.constant(64 : index) : !llvm.i64
    %41 = llvm.insertvalue %40, %39[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.mlir.constant(1 : index) : !llvm.i64
    %43 = llvm.insertvalue %42, %41[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
    %45 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %46 = llvm.mlir.constant(32 : index) : !llvm.i64
    %47 = llvm.mlir.constant(64 : index) : !llvm.i64
    %48 = llvm.mlir.constant(4 : index) : !llvm.i64
    %49 = llvm.mlir.constant(0 : index) : !llvm.i64
    %50 = llvm.mlir.constant(1 : index) : !llvm.i64
    %51 = llvm.mlir.constant(0 : index) : !llvm.i64
    %52 = llvm.getelementptr %arg2[%51] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
    %53 = llvm.load %52 : !llvm.ptr<i32>
    %54 = llvm.zext %53 : !llvm.i32 to !llvm.i64
    %55 = llvm.mlir.constant(1 : index) : !llvm.i64
    %56 = llvm.getelementptr %arg2[%55] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
    %57 = llvm.load %56 : !llvm.ptr<i32>
    %58 = llvm.zext %57 : !llvm.i32 to !llvm.i64
    %59 = llvm.mlir.constant(64 : index) : !llvm.i64
    %60 = llvm.mul %58, %59 : !llvm.i64
    %61 = llvm.mlir.constant(64 : index) : !llvm.i64
    %62 = llvm.mlir.constant(-64 : index) : !llvm.i64
    %63 = llvm.mul %58, %62 : !llvm.i64
    %64 = llvm.mlir.constant(32 : index) : !llvm.i64
    %65 = llvm.add %63, %64 : !llvm.i64
    %66 = llvm.icmp "slt" %61, %65 : !llvm.i64
    %67 = llvm.select %66, %61, %65 : !llvm.i1, !llvm.i64
    %68 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %69 = llvm.extractvalue %15[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %70 = llvm.bitcast %69 : !llvm.ptr<float> to !llvm.ptr<float>
    %71 = llvm.insertvalue %70, %68[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %72 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %73 = llvm.bitcast %72 : !llvm.ptr<float> to !llvm.ptr<float>
    %74 = llvm.insertvalue %73, %71[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %75 = llvm.extractvalue %15[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %76 = llvm.extractvalue %15[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %77 = llvm.extractvalue %15[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %78 = llvm.mul %60, %75 : !llvm.i64
    %79 = llvm.add %77, %78 : !llvm.i64
    %80 = llvm.mlir.constant(0 : i64) : !llvm.i64
    %81 = llvm.mul %80, %76 : !llvm.i64
    %82 = llvm.add %79, %81 : !llvm.i64
    %83 = llvm.insertvalue %82, %74[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %84 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %85 = llvm.insertvalue %84, %83[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %86 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %87 = llvm.insertvalue %86, %85[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %88 = llvm.insertvalue %67, %87[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %89 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %90 = llvm.insertvalue %89, %88[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %91 = llvm.mlir.constant(64 : index) : !llvm.i64
    %92 = llvm.mul %54, %91 : !llvm.i64
    %93 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %94 = llvm.extractvalue %29[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %95 = llvm.bitcast %94 : !llvm.ptr<float> to !llvm.ptr<float>
    %96 = llvm.insertvalue %95, %93[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %97 = llvm.extractvalue %29[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.bitcast %97 : !llvm.ptr<float> to !llvm.ptr<float>
    %99 = llvm.insertvalue %98, %96[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.extractvalue %29[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.extractvalue %29[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.extractvalue %29[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.mlir.constant(0 : i64) : !llvm.i64
    %104 = llvm.mul %103, %100 : !llvm.i64
    %105 = llvm.add %102, %104 : !llvm.i64
    %106 = llvm.mul %92, %101 : !llvm.i64
    %107 = llvm.add %105, %106 : !llvm.i64
    %108 = llvm.insertvalue %107, %99[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %110 = llvm.insertvalue %109, %108[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %112 = llvm.insertvalue %111, %110[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %113 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %114 = llvm.insertvalue %113, %112[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %115 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %116 = llvm.insertvalue %115, %114[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.extractvalue %43[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.bitcast %118 : !llvm.ptr<float> to !llvm.ptr<float>
    %120 = llvm.insertvalue %119, %117[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.extractvalue %43[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.bitcast %121 : !llvm.ptr<float> to !llvm.ptr<float>
    %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.extractvalue %43[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.extractvalue %43[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %43[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.mul %60, %124 : !llvm.i64
    %128 = llvm.add %126, %127 : !llvm.i64
    %129 = llvm.mul %92, %125 : !llvm.i64
    %130 = llvm.add %128, %129 : !llvm.i64
    %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %133 = llvm.insertvalue %132, %131[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %135 = llvm.insertvalue %134, %133[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.insertvalue %67, %135[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %138 = llvm.insertvalue %137, %136[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb1(%49 : !llvm.i64)
  ^bb1(%139: !llvm.i64):  // 2 preds: ^bb0, ^bb4
    %140 = llvm.icmp "slt" %139, %67 : !llvm.i64
    llvm.cond_br %140, ^bb2(%49 : !llvm.i64), ^bb5(%49 : !llvm.i64)
  ^bb2(%141: !llvm.i64):  // 2 preds: ^bb1, ^bb3
    %142 = llvm.icmp "slt" %141, %47 : !llvm.i64
    llvm.cond_br %142, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %143 = llvm.extractvalue %138[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.extractvalue %138[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.mlir.constant(64 : index) : !llvm.i64
    %146 = llvm.mul %139, %145 : !llvm.i64
    %147 = llvm.add %144, %146 : !llvm.i64
    %148 = llvm.add %147, %141 : !llvm.i64
    %149 = llvm.getelementptr %143[%148] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    llvm.store %44, %149 : !llvm.ptr<float>
    %150 = llvm.add %141, %50 : !llvm.i64
    llvm.br ^bb2(%150 : !llvm.i64)
  ^bb4:  // pred: ^bb2
    %151 = llvm.add %139, %50 : !llvm.i64
    llvm.br ^bb1(%151 : !llvm.i64)
  ^bb5(%152: !llvm.i64):  // 2 preds: ^bb1, ^bb24
    %153 = llvm.icmp "slt" %152, %67 : !llvm.i64
    llvm.cond_br %153, ^bb6(%49 : !llvm.i64), ^bb25
  ^bb6(%154: !llvm.i64):  // 2 preds: ^bb5, ^bb23
    %155 = llvm.icmp "slt" %154, %47 : !llvm.i64
    llvm.cond_br %155, ^bb7(%49 : !llvm.i64), ^bb24
  ^bb7(%156: !llvm.i64):  // 2 preds: ^bb6, ^bb22
    %157 = llvm.icmp "slt" %156, %45 : !llvm.i64
    llvm.cond_br %157, ^bb8, ^bb23
  ^bb8:  // pred: ^bb7
    %158 = llvm.mlir.constant(32 : index) : !llvm.i64
    %159 = llvm.mlir.constant(-1 : index) : !llvm.i64
    %160 = llvm.mul %152, %159 : !llvm.i64
    %161 = llvm.add %160, %67 : !llvm.i64
    %162 = llvm.icmp "slt" %158, %161 : !llvm.i64
    %163 = llvm.select %162, %158, %161 : !llvm.i1, !llvm.i64
    %164 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %165 = llvm.extractvalue %90[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
    %167 = llvm.insertvalue %166, %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.extractvalue %90[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
    %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %171 = llvm.extractvalue %90[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %172 = llvm.extractvalue %90[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %173 = llvm.extractvalue %90[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %174 = llvm.mul %152, %171 : !llvm.i64
    %175 = llvm.add %173, %174 : !llvm.i64
    %176 = llvm.mul %156, %172 : !llvm.i64
    %177 = llvm.add %175, %176 : !llvm.i64
    %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %179 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %180 = llvm.insertvalue %179, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %181 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %182 = llvm.insertvalue %181, %180[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %183 = llvm.insertvalue %163, %182[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %184 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %185 = llvm.insertvalue %184, %183[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %186 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %187 = llvm.extractvalue %116[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %188 = llvm.bitcast %187 : !llvm.ptr<float> to !llvm.ptr<float>
    %189 = llvm.insertvalue %188, %186[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %190 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %191 = llvm.bitcast %190 : !llvm.ptr<float> to !llvm.ptr<float>
    %192 = llvm.insertvalue %191, %189[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %193 = llvm.extractvalue %116[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %194 = llvm.extractvalue %116[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %195 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %196 = llvm.mul %156, %193 : !llvm.i64
    %197 = llvm.add %195, %196 : !llvm.i64
    %198 = llvm.mul %154, %194 : !llvm.i64
    %199 = llvm.add %197, %198 : !llvm.i64
    %200 = llvm.insertvalue %199, %192[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %202 = llvm.insertvalue %201, %200[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %203 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %204 = llvm.insertvalue %203, %202[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %205 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %206 = llvm.insertvalue %205, %204[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %207 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %208 = llvm.insertvalue %207, %206[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %209 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %210 = llvm.extractvalue %138[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %211 = llvm.bitcast %210 : !llvm.ptr<float> to !llvm.ptr<float>
    %212 = llvm.insertvalue %211, %209[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %213 = llvm.extractvalue %138[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.bitcast %213 : !llvm.ptr<float> to !llvm.ptr<float>
    %215 = llvm.insertvalue %214, %212[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %216 = llvm.extractvalue %138[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %217 = llvm.extractvalue %138[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.extractvalue %138[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %219 = llvm.mul %152, %216 : !llvm.i64
    %220 = llvm.add %218, %219 : !llvm.i64
    %221 = llvm.mul %154, %217 : !llvm.i64
    %222 = llvm.add %220, %221 : !llvm.i64
    %223 = llvm.insertvalue %222, %215[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %224 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %225 = llvm.insertvalue %224, %223[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %226 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %227 = llvm.insertvalue %226, %225[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.insertvalue %163, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %229 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %230 = llvm.insertvalue %229, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb9(%49 : !llvm.i64)
  ^bb9(%231: !llvm.i64):  // 2 preds: ^bb8, ^bb21
    %232 = llvm.icmp "slt" %231, %163 : !llvm.i64
    llvm.cond_br %232, ^bb10(%49 : !llvm.i64), ^bb22
  ^bb10(%233: !llvm.i64):  // 2 preds: ^bb9, ^bb20
    %234 = llvm.icmp "slt" %233, %46 : !llvm.i64
    llvm.cond_br %234, ^bb11(%49 : !llvm.i64), ^bb21
  ^bb11(%235: !llvm.i64):  // 2 preds: ^bb10, ^bb19
    %236 = llvm.icmp "slt" %235, %46 : !llvm.i64
    llvm.cond_br %236, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %237 = llvm.mlir.constant(4 : index) : !llvm.i64
    %238 = llvm.mlir.constant(-1 : index) : !llvm.i64
    %239 = llvm.mul %231, %238 : !llvm.i64
    %240 = llvm.add %163, %239 : !llvm.i64
    %241 = llvm.icmp "slt" %237, %240 : !llvm.i64
    %242 = llvm.select %241, %237, %240 : !llvm.i1, !llvm.i64
    %243 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %244 = llvm.extractvalue %185[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.bitcast %244 : !llvm.ptr<float> to !llvm.ptr<float>
    %246 = llvm.insertvalue %245, %243[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %247 = llvm.extractvalue %185[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %248 = llvm.bitcast %247 : !llvm.ptr<float> to !llvm.ptr<float>
    %249 = llvm.insertvalue %248, %246[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %250 = llvm.extractvalue %185[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %251 = llvm.extractvalue %185[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %252 = llvm.extractvalue %185[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %253 = llvm.mul %231, %250 : !llvm.i64
    %254 = llvm.add %252, %253 : !llvm.i64
    %255 = llvm.mul %235, %251 : !llvm.i64
    %256 = llvm.add %254, %255 : !llvm.i64
    %257 = llvm.insertvalue %256, %249[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %258 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %259 = llvm.insertvalue %258, %257[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %260 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %261 = llvm.insertvalue %260, %259[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %262 = llvm.insertvalue %242, %261[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %263 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %264 = llvm.insertvalue %263, %262[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %265 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %266 = llvm.extractvalue %208[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %267 = llvm.bitcast %266 : !llvm.ptr<float> to !llvm.ptr<float>
    %268 = llvm.insertvalue %267, %265[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %269 = llvm.extractvalue %208[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %270 = llvm.bitcast %269 : !llvm.ptr<float> to !llvm.ptr<float>
    %271 = llvm.insertvalue %270, %268[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %272 = llvm.extractvalue %208[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %273 = llvm.extractvalue %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %274 = llvm.extractvalue %208[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %275 = llvm.mul %235, %272 : !llvm.i64
    %276 = llvm.add %274, %275 : !llvm.i64
    %277 = llvm.mul %233, %273 : !llvm.i64
    %278 = llvm.add %276, %277 : !llvm.i64
    %279 = llvm.insertvalue %278, %271[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %280 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %281 = llvm.insertvalue %280, %279[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %282 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %283 = llvm.insertvalue %282, %281[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %284 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %285 = llvm.insertvalue %284, %283[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %286 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %287 = llvm.insertvalue %286, %285[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %288 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %289 = llvm.extractvalue %230[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %290 = llvm.bitcast %289 : !llvm.ptr<float> to !llvm.ptr<float>
    %291 = llvm.insertvalue %290, %288[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %292 = llvm.extractvalue %230[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %293 = llvm.bitcast %292 : !llvm.ptr<float> to !llvm.ptr<float>
    %294 = llvm.insertvalue %293, %291[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %295 = llvm.extractvalue %230[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %296 = llvm.extractvalue %230[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %297 = llvm.extractvalue %230[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %298 = llvm.mul %231, %295 : !llvm.i64
    %299 = llvm.add %297, %298 : !llvm.i64
    %300 = llvm.mul %233, %296 : !llvm.i64
    %301 = llvm.add %299, %300 : !llvm.i64
    %302 = llvm.insertvalue %301, %294[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %303 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %304 = llvm.insertvalue %303, %302[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %305 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %306 = llvm.insertvalue %305, %304[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %307 = llvm.insertvalue %242, %306[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %308 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %309 = llvm.insertvalue %308, %307[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%49 : !llvm.i64)
  ^bb13(%310: !llvm.i64):  // 2 preds: ^bb12, ^bb18
    %311 = llvm.icmp "slt" %310, %242 : !llvm.i64
    llvm.cond_br %311, ^bb14(%49 : !llvm.i64), ^bb19
  ^bb14(%312: !llvm.i64):  // 2 preds: ^bb13, ^bb17
    %313 = llvm.icmp "slt" %312, %48 : !llvm.i64
    llvm.cond_br %313, ^bb15(%49 : !llvm.i64), ^bb18
  ^bb15(%314: !llvm.i64):  // 2 preds: ^bb14, ^bb16
    %315 = llvm.icmp "slt" %314, %48 : !llvm.i64
    llvm.cond_br %315, ^bb16, ^bb17
  ^bb16:  // pred: ^bb15
    %316 = llvm.extractvalue %264[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %317 = llvm.extractvalue %264[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %318 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %319 = llvm.mul %310, %318 : !llvm.i64
    %320 = llvm.add %317, %319 : !llvm.i64
    %321 = llvm.add %320, %314 : !llvm.i64
    %322 = llvm.getelementptr %316[%321] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %323 = llvm.load %322 : !llvm.ptr<float>
    %324 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %325 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %326 = llvm.mlir.constant(64 : index) : !llvm.i64
    %327 = llvm.mul %314, %326 : !llvm.i64
    %328 = llvm.add %325, %327 : !llvm.i64
    %329 = llvm.add %328, %312 : !llvm.i64
    %330 = llvm.getelementptr %324[%329] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %331 = llvm.load %330 : !llvm.ptr<float>
    %332 = llvm.extractvalue %309[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %333 = llvm.extractvalue %309[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %334 = llvm.mlir.constant(64 : index) : !llvm.i64
    %335 = llvm.mul %310, %334 : !llvm.i64
    %336 = llvm.add %333, %335 : !llvm.i64
    %337 = llvm.add %336, %312 : !llvm.i64
    %338 = llvm.getelementptr %332[%337] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %339 = llvm.load %338 : !llvm.ptr<float>
    %340 = llvm.fmul %323, %331 : !llvm.float
    %341 = llvm.fadd %339, %340 : !llvm.float
    %342 = llvm.extractvalue %309[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %343 = llvm.extractvalue %309[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %344 = llvm.mlir.constant(64 : index) : !llvm.i64
    %345 = llvm.mul %310, %344 : !llvm.i64
    %346 = llvm.add %343, %345 : !llvm.i64
    %347 = llvm.add %346, %312 : !llvm.i64
    %348 = llvm.getelementptr %342[%347] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    llvm.store %341, %348 : !llvm.ptr<float>
    %349 = llvm.add %314, %50 : !llvm.i64
    llvm.br ^bb15(%349 : !llvm.i64)
  ^bb17:  // pred: ^bb15
    %350 = llvm.add %312, %50 : !llvm.i64
    llvm.br ^bb14(%350 : !llvm.i64)
  ^bb18:  // pred: ^bb14
    %351 = llvm.add %310, %50 : !llvm.i64
    llvm.br ^bb13(%351 : !llvm.i64)
  ^bb19:  // pred: ^bb13
    %352 = llvm.add %235, %48 : !llvm.i64
    llvm.br ^bb11(%352 : !llvm.i64)
  ^bb20:  // pred: ^bb11
    %353 = llvm.add %233, %48 : !llvm.i64
    llvm.br ^bb10(%353 : !llvm.i64)
  ^bb21:  // pred: ^bb10
    %354 = llvm.add %231, %48 : !llvm.i64
    llvm.br ^bb9(%354 : !llvm.i64)
  ^bb22:  // pred: ^bb9
    %355 = llvm.add %156, %46 : !llvm.i64
    llvm.br ^bb7(%355 : !llvm.i64)
  ^bb23:  // pred: ^bb7
    %356 = llvm.add %154, %46 : !llvm.i64
    llvm.br ^bb6(%356 : !llvm.i64)
  ^bb24:  // pred: ^bb6
    %357 = llvm.add %152, %46 : !llvm.i64
    llvm.br ^bb5(%357 : !llvm.i64)
  ^bb25:  // pred: ^bb5
    llvm.return
  }
}

```
### IR Dump After Canonicalizer
```
module  {
  func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
    %c1 = constant 1 : index
    return %c1, %c1, %c1 : index, index, index
  }
  llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
    %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
    %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
    %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %6 = llvm.mlir.constant(0 : index) : !llvm.i64
    %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = llvm.mlir.constant(32 : index) : !llvm.i64
    %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %12 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %13 = llvm.insertvalue %12, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %14 = llvm.mlir.constant(1 : index) : !llvm.i64
    %15 = llvm.insertvalue %14, %13[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %16 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %17 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %16, %17[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.insertvalue %16, %18[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %20 = llvm.mlir.constant(0 : index) : !llvm.i64
    %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %23 = llvm.insertvalue %22, %21[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %24 = llvm.mlir.constant(64 : index) : !llvm.i64
    %25 = llvm.insertvalue %24, %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.mlir.constant(64 : index) : !llvm.i64
    %27 = llvm.insertvalue %26, %25[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.mlir.constant(1 : index) : !llvm.i64
    %29 = llvm.insertvalue %28, %27[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %31 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.insertvalue %30, %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %33 = llvm.insertvalue %30, %32[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %34 = llvm.mlir.constant(0 : index) : !llvm.i64
    %35 = llvm.insertvalue %34, %33[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %36 = llvm.mlir.constant(32 : index) : !llvm.i64
    %37 = llvm.insertvalue %36, %35[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %38 = llvm.mlir.constant(64 : index) : !llvm.i64
    %39 = llvm.insertvalue %38, %37[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %40 = llvm.mlir.constant(64 : index) : !llvm.i64
    %41 = llvm.insertvalue %40, %39[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %42 = llvm.mlir.constant(1 : index) : !llvm.i64
    %43 = llvm.insertvalue %42, %41[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %44 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
    %45 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %46 = llvm.mlir.constant(32 : index) : !llvm.i64
    %47 = llvm.mlir.constant(64 : index) : !llvm.i64
    %48 = llvm.mlir.constant(4 : index) : !llvm.i64
    %49 = llvm.mlir.constant(0 : index) : !llvm.i64
    %50 = llvm.mlir.constant(1 : index) : !llvm.i64
    %51 = llvm.mlir.constant(0 : index) : !llvm.i64
    %52 = llvm.getelementptr %arg2[%51] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
    %53 = llvm.load %52 : !llvm.ptr<i32>
    %54 = llvm.zext %53 : !llvm.i32 to !llvm.i64
    %55 = llvm.mlir.constant(1 : index) : !llvm.i64
    %56 = llvm.getelementptr %arg2[%55] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
    %57 = llvm.load %56 : !llvm.ptr<i32>
    %58 = llvm.zext %57 : !llvm.i32 to !llvm.i64
    %59 = llvm.mlir.constant(64 : index) : !llvm.i64
    %60 = llvm.mul %58, %59 : !llvm.i64
    %61 = llvm.mlir.constant(64 : index) : !llvm.i64
    %62 = llvm.mlir.constant(-64 : index) : !llvm.i64
    %63 = llvm.mul %58, %62 : !llvm.i64
    %64 = llvm.mlir.constant(32 : index) : !llvm.i64
    %65 = llvm.add %63, %64 : !llvm.i64
    %66 = llvm.icmp "slt" %61, %65 : !llvm.i64
    %67 = llvm.select %66, %61, %65 : !llvm.i1, !llvm.i64
    %68 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %69 = llvm.extractvalue %15[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %70 = llvm.bitcast %69 : !llvm.ptr<float> to !llvm.ptr<float>
    %71 = llvm.insertvalue %70, %68[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %72 = llvm.extractvalue %15[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %73 = llvm.bitcast %72 : !llvm.ptr<float> to !llvm.ptr<float>
    %74 = llvm.insertvalue %73, %71[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %75 = llvm.extractvalue %15[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %76 = llvm.extractvalue %15[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %77 = llvm.extractvalue %15[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %78 = llvm.mul %60, %75 : !llvm.i64
    %79 = llvm.add %77, %78 : !llvm.i64
    %80 = llvm.mlir.constant(0 : i64) : !llvm.i64
    %81 = llvm.mul %80, %76 : !llvm.i64
    %82 = llvm.add %79, %81 : !llvm.i64
    %83 = llvm.insertvalue %82, %74[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %84 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %85 = llvm.insertvalue %84, %83[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %86 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %87 = llvm.insertvalue %86, %85[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %88 = llvm.insertvalue %67, %87[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %89 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %90 = llvm.insertvalue %89, %88[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %91 = llvm.mlir.constant(64 : index) : !llvm.i64
    %92 = llvm.mul %54, %91 : !llvm.i64
    %93 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %94 = llvm.extractvalue %29[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %95 = llvm.bitcast %94 : !llvm.ptr<float> to !llvm.ptr<float>
    %96 = llvm.insertvalue %95, %93[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %97 = llvm.extractvalue %29[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %98 = llvm.bitcast %97 : !llvm.ptr<float> to !llvm.ptr<float>
    %99 = llvm.insertvalue %98, %96[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %100 = llvm.extractvalue %29[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.extractvalue %29[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.extractvalue %29[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.mlir.constant(0 : i64) : !llvm.i64
    %104 = llvm.mul %103, %100 : !llvm.i64
    %105 = llvm.add %102, %104 : !llvm.i64
    %106 = llvm.mul %92, %101 : !llvm.i64
    %107 = llvm.add %105, %106 : !llvm.i64
    %108 = llvm.insertvalue %107, %99[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %109 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %110 = llvm.insertvalue %109, %108[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %112 = llvm.insertvalue %111, %110[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %113 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %114 = llvm.insertvalue %113, %112[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %115 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %116 = llvm.insertvalue %115, %114[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %117 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %118 = llvm.extractvalue %43[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %119 = llvm.bitcast %118 : !llvm.ptr<float> to !llvm.ptr<float>
    %120 = llvm.insertvalue %119, %117[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %121 = llvm.extractvalue %43[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %122 = llvm.bitcast %121 : !llvm.ptr<float> to !llvm.ptr<float>
    %123 = llvm.insertvalue %122, %120[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %124 = llvm.extractvalue %43[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %125 = llvm.extractvalue %43[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %126 = llvm.extractvalue %43[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %127 = llvm.mul %60, %124 : !llvm.i64
    %128 = llvm.add %126, %127 : !llvm.i64
    %129 = llvm.mul %92, %125 : !llvm.i64
    %130 = llvm.add %128, %129 : !llvm.i64
    %131 = llvm.insertvalue %130, %123[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %133 = llvm.insertvalue %132, %131[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %135 = llvm.insertvalue %134, %133[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.insertvalue %67, %135[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %138 = llvm.insertvalue %137, %136[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb1(%49 : !llvm.i64)
  ^bb1(%139: !llvm.i64):  // 2 preds: ^bb0, ^bb4
    %140 = llvm.icmp "slt" %139, %67 : !llvm.i64
    llvm.cond_br %140, ^bb2(%49 : !llvm.i64), ^bb5(%49 : !llvm.i64)
  ^bb2(%141: !llvm.i64):  // 2 preds: ^bb1, ^bb3
    %142 = llvm.icmp "slt" %141, %47 : !llvm.i64
    llvm.cond_br %142, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %143 = llvm.extractvalue %138[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.extractvalue %138[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.mlir.constant(64 : index) : !llvm.i64
    %146 = llvm.mul %139, %145 : !llvm.i64
    %147 = llvm.add %144, %146 : !llvm.i64
    %148 = llvm.add %147, %141 : !llvm.i64
    %149 = llvm.getelementptr %143[%148] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    llvm.store %44, %149 : !llvm.ptr<float>
    %150 = llvm.add %141, %50 : !llvm.i64
    llvm.br ^bb2(%150 : !llvm.i64)
  ^bb4:  // pred: ^bb2
    %151 = llvm.add %139, %50 : !llvm.i64
    llvm.br ^bb1(%151 : !llvm.i64)
  ^bb5(%152: !llvm.i64):  // 2 preds: ^bb1, ^bb24
    %153 = llvm.icmp "slt" %152, %67 : !llvm.i64
    llvm.cond_br %153, ^bb6(%49 : !llvm.i64), ^bb25
  ^bb6(%154: !llvm.i64):  // 2 preds: ^bb5, ^bb23
    %155 = llvm.icmp "slt" %154, %47 : !llvm.i64
    llvm.cond_br %155, ^bb7(%49 : !llvm.i64), ^bb24
  ^bb7(%156: !llvm.i64):  // 2 preds: ^bb6, ^bb22
    %157 = llvm.icmp "slt" %156, %45 : !llvm.i64
    llvm.cond_br %157, ^bb8, ^bb23
  ^bb8:  // pred: ^bb7
    %158 = llvm.mlir.constant(32 : index) : !llvm.i64
    %159 = llvm.mlir.constant(-1 : index) : !llvm.i64
    %160 = llvm.mul %152, %159 : !llvm.i64
    %161 = llvm.add %160, %67 : !llvm.i64
    %162 = llvm.icmp "slt" %158, %161 : !llvm.i64
    %163 = llvm.select %162, %158, %161 : !llvm.i1, !llvm.i64
    %164 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %165 = llvm.extractvalue %90[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
    %167 = llvm.insertvalue %166, %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.extractvalue %90[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
    %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %171 = llvm.extractvalue %90[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %172 = llvm.extractvalue %90[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %173 = llvm.extractvalue %90[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %174 = llvm.mul %152, %171 : !llvm.i64
    %175 = llvm.add %173, %174 : !llvm.i64
    %176 = llvm.mul %156, %172 : !llvm.i64
    %177 = llvm.add %175, %176 : !llvm.i64
    %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %179 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %180 = llvm.insertvalue %179, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %181 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %182 = llvm.insertvalue %181, %180[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %183 = llvm.insertvalue %163, %182[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %184 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %185 = llvm.insertvalue %184, %183[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %186 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %187 = llvm.extractvalue %116[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %188 = llvm.bitcast %187 : !llvm.ptr<float> to !llvm.ptr<float>
    %189 = llvm.insertvalue %188, %186[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %190 = llvm.extractvalue %116[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %191 = llvm.bitcast %190 : !llvm.ptr<float> to !llvm.ptr<float>
    %192 = llvm.insertvalue %191, %189[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %193 = llvm.extractvalue %116[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %194 = llvm.extractvalue %116[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %195 = llvm.extractvalue %116[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %196 = llvm.mul %156, %193 : !llvm.i64
    %197 = llvm.add %195, %196 : !llvm.i64
    %198 = llvm.mul %154, %194 : !llvm.i64
    %199 = llvm.add %197, %198 : !llvm.i64
    %200 = llvm.insertvalue %199, %192[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %202 = llvm.insertvalue %201, %200[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %203 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %204 = llvm.insertvalue %203, %202[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %205 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %206 = llvm.insertvalue %205, %204[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %207 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %208 = llvm.insertvalue %207, %206[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %209 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %210 = llvm.extractvalue %138[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %211 = llvm.bitcast %210 : !llvm.ptr<float> to !llvm.ptr<float>
    %212 = llvm.insertvalue %211, %209[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %213 = llvm.extractvalue %138[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %214 = llvm.bitcast %213 : !llvm.ptr<float> to !llvm.ptr<float>
    %215 = llvm.insertvalue %214, %212[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %216 = llvm.extractvalue %138[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %217 = llvm.extractvalue %138[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.extractvalue %138[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %219 = llvm.mul %152, %216 : !llvm.i64
    %220 = llvm.add %218, %219 : !llvm.i64
    %221 = llvm.mul %154, %217 : !llvm.i64
    %222 = llvm.add %220, %221 : !llvm.i64
    %223 = llvm.insertvalue %222, %215[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %224 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %225 = llvm.insertvalue %224, %223[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %226 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %227 = llvm.insertvalue %226, %225[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.insertvalue %163, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %229 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %230 = llvm.insertvalue %229, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb9(%49 : !llvm.i64)
  ^bb9(%231: !llvm.i64):  // 2 preds: ^bb8, ^bb21
    %232 = llvm.icmp "slt" %231, %163 : !llvm.i64
    llvm.cond_br %232, ^bb10(%49 : !llvm.i64), ^bb22
  ^bb10(%233: !llvm.i64):  // 2 preds: ^bb9, ^bb20
    %234 = llvm.icmp "slt" %233, %46 : !llvm.i64
    llvm.cond_br %234, ^bb11(%49 : !llvm.i64), ^bb21
  ^bb11(%235: !llvm.i64):  // 2 preds: ^bb10, ^bb19
    %236 = llvm.icmp "slt" %235, %46 : !llvm.i64
    llvm.cond_br %236, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %237 = llvm.mlir.constant(4 : index) : !llvm.i64
    %238 = llvm.mlir.constant(-1 : index) : !llvm.i64
    %239 = llvm.mul %231, %238 : !llvm.i64
    %240 = llvm.add %163, %239 : !llvm.i64
    %241 = llvm.icmp "slt" %237, %240 : !llvm.i64
    %242 = llvm.select %241, %237, %240 : !llvm.i1, !llvm.i64
    %243 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %244 = llvm.extractvalue %185[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.bitcast %244 : !llvm.ptr<float> to !llvm.ptr<float>
    %246 = llvm.insertvalue %245, %243[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %247 = llvm.extractvalue %185[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %248 = llvm.bitcast %247 : !llvm.ptr<float> to !llvm.ptr<float>
    %249 = llvm.insertvalue %248, %246[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %250 = llvm.extractvalue %185[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %251 = llvm.extractvalue %185[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %252 = llvm.extractvalue %185[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %253 = llvm.mul %231, %250 : !llvm.i64
    %254 = llvm.add %252, %253 : !llvm.i64
    %255 = llvm.mul %235, %251 : !llvm.i64
    %256 = llvm.add %254, %255 : !llvm.i64
    %257 = llvm.insertvalue %256, %249[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %258 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %259 = llvm.insertvalue %258, %257[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %260 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %261 = llvm.insertvalue %260, %259[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %262 = llvm.insertvalue %242, %261[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %263 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %264 = llvm.insertvalue %263, %262[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %265 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %266 = llvm.extractvalue %208[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %267 = llvm.bitcast %266 : !llvm.ptr<float> to !llvm.ptr<float>
    %268 = llvm.insertvalue %267, %265[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %269 = llvm.extractvalue %208[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %270 = llvm.bitcast %269 : !llvm.ptr<float> to !llvm.ptr<float>
    %271 = llvm.insertvalue %270, %268[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %272 = llvm.extractvalue %208[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %273 = llvm.extractvalue %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %274 = llvm.extractvalue %208[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %275 = llvm.mul %235, %272 : !llvm.i64
    %276 = llvm.add %274, %275 : !llvm.i64
    %277 = llvm.mul %233, %273 : !llvm.i64
    %278 = llvm.add %276, %277 : !llvm.i64
    %279 = llvm.insertvalue %278, %271[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %280 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %281 = llvm.insertvalue %280, %279[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %282 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %283 = llvm.insertvalue %282, %281[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %284 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %285 = llvm.insertvalue %284, %283[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %286 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %287 = llvm.insertvalue %286, %285[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %288 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %289 = llvm.extractvalue %230[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %290 = llvm.bitcast %289 : !llvm.ptr<float> to !llvm.ptr<float>
    %291 = llvm.insertvalue %290, %288[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %292 = llvm.extractvalue %230[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %293 = llvm.bitcast %292 : !llvm.ptr<float> to !llvm.ptr<float>
    %294 = llvm.insertvalue %293, %291[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %295 = llvm.extractvalue %230[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %296 = llvm.extractvalue %230[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %297 = llvm.extractvalue %230[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %298 = llvm.mul %231, %295 : !llvm.i64
    %299 = llvm.add %297, %298 : !llvm.i64
    %300 = llvm.mul %233, %296 : !llvm.i64
    %301 = llvm.add %299, %300 : !llvm.i64
    %302 = llvm.insertvalue %301, %294[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %303 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %304 = llvm.insertvalue %303, %302[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %305 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %306 = llvm.insertvalue %305, %304[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %307 = llvm.insertvalue %242, %306[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %308 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %309 = llvm.insertvalue %308, %307[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%49 : !llvm.i64)
  ^bb13(%310: !llvm.i64):  // 2 preds: ^bb12, ^bb18
    %311 = llvm.icmp "slt" %310, %242 : !llvm.i64
    llvm.cond_br %311, ^bb14(%49 : !llvm.i64), ^bb19
  ^bb14(%312: !llvm.i64):  // 2 preds: ^bb13, ^bb17
    %313 = llvm.icmp "slt" %312, %48 : !llvm.i64
    llvm.cond_br %313, ^bb15(%49 : !llvm.i64), ^bb18
  ^bb15(%314: !llvm.i64):  // 2 preds: ^bb14, ^bb16
    %315 = llvm.icmp "slt" %314, %48 : !llvm.i64
    llvm.cond_br %315, ^bb16, ^bb17
  ^bb16:  // pred: ^bb15
    %316 = llvm.extractvalue %264[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %317 = llvm.extractvalue %264[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %318 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %319 = llvm.mul %310, %318 : !llvm.i64
    %320 = llvm.add %317, %319 : !llvm.i64
    %321 = llvm.add %320, %314 : !llvm.i64
    %322 = llvm.getelementptr %316[%321] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %323 = llvm.load %322 : !llvm.ptr<float>
    %324 = llvm.extractvalue %287[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %325 = llvm.extractvalue %287[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %326 = llvm.mlir.constant(64 : index) : !llvm.i64
    %327 = llvm.mul %314, %326 : !llvm.i64
    %328 = llvm.add %325, %327 : !llvm.i64
    %329 = llvm.add %328, %312 : !llvm.i64
    %330 = llvm.getelementptr %324[%329] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %331 = llvm.load %330 : !llvm.ptr<float>
    %332 = llvm.extractvalue %309[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %333 = llvm.extractvalue %309[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %334 = llvm.mlir.constant(64 : index) : !llvm.i64
    %335 = llvm.mul %310, %334 : !llvm.i64
    %336 = llvm.add %333, %335 : !llvm.i64
    %337 = llvm.add %336, %312 : !llvm.i64
    %338 = llvm.getelementptr %332[%337] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %339 = llvm.load %338 : !llvm.ptr<float>
    %340 = llvm.fmul %323, %331 : !llvm.float
    %341 = llvm.fadd %339, %340 : !llvm.float
    %342 = llvm.extractvalue %309[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %343 = llvm.extractvalue %309[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %344 = llvm.mlir.constant(64 : index) : !llvm.i64
    %345 = llvm.mul %310, %344 : !llvm.i64
    %346 = llvm.add %343, %345 : !llvm.i64
    %347 = llvm.add %346, %312 : !llvm.i64
    %348 = llvm.getelementptr %342[%347] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    llvm.store %341, %348 : !llvm.ptr<float>
    %349 = llvm.add %314, %50 : !llvm.i64
    llvm.br ^bb15(%349 : !llvm.i64)
  ^bb17:  // pred: ^bb15
    %350 = llvm.add %312, %50 : !llvm.i64
    llvm.br ^bb14(%350 : !llvm.i64)
  ^bb18:  // pred: ^bb14
    %351 = llvm.add %310, %50 : !llvm.i64
    llvm.br ^bb13(%351 : !llvm.i64)
  ^bb19:  // pred: ^bb13
    %352 = llvm.add %235, %48 : !llvm.i64
    llvm.br ^bb11(%352 : !llvm.i64)
  ^bb20:  // pred: ^bb11
    %353 = llvm.add %233, %48 : !llvm.i64
    llvm.br ^bb10(%353 : !llvm.i64)
  ^bb21:  // pred: ^bb10
    %354 = llvm.add %231, %48 : !llvm.i64
    llvm.br ^bb9(%354 : !llvm.i64)
  ^bb22:  // pred: ^bb9
    %355 = llvm.add %156, %46 : !llvm.i64
    llvm.br ^bb7(%355 : !llvm.i64)
  ^bb23:  // pred: ^bb7
    %356 = llvm.add %154, %46 : !llvm.i64
    llvm.br ^bb6(%356 : !llvm.i64)
  ^bb24:  // pred: ^bb6
    %357 = llvm.add %152, %46 : !llvm.i64
    llvm.br ^bb5(%357 : !llvm.i64)
  ^bb25:  // pred: ^bb5
    llvm.return
  }
}

```
### IR Dump After CSE
```
module  {
  func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
    %c1 = constant 1 : index
    return %c1, %c1, %c1 : index, index, index
  }
  llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
    %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
    %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
    %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %6 = llvm.mlir.constant(0 : index) : !llvm.i64
    %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %8 = llvm.mlir.constant(32 : index) : !llvm.i64
    %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
    %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %13 = llvm.mlir.constant(1 : index) : !llvm.i64
    %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %20 = llvm.mlir.constant(64 : index) : !llvm.i64
    %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
    %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
    %33 = llvm.mlir.constant(4 : index) : !llvm.i64
    %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
    %35 = llvm.load %34 : !llvm.ptr<i32>
    %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
    %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
    %38 = llvm.load %37 : !llvm.ptr<i32>
    %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
    %40 = llvm.mul %39, %20 : !llvm.i64
    %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
    %42 = llvm.mul %39, %41 : !llvm.i64
    %43 = llvm.add %42, %8 : !llvm.i64
    %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
    %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
    %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
    %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
    %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %55 = llvm.mul %40, %52 : !llvm.i64
    %56 = llvm.add %54, %55 : !llvm.i64
    %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
    %58 = llvm.mul %57, %53 : !llvm.i64
    %59 = llvm.add %56, %58 : !llvm.i64
    %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
    %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
    %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %67 = llvm.mul %36, %20 : !llvm.i64
    %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
    %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
    %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %77 = llvm.mul %57, %74 : !llvm.i64
    %78 = llvm.add %76, %77 : !llvm.i64
    %79 = llvm.mul %67, %75 : !llvm.i64
    %80 = llvm.add %78, %79 : !llvm.i64
    %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
    %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
    %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
    %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %96 = llvm.mul %40, %93 : !llvm.i64
    %97 = llvm.add %95, %96 : !llvm.i64
    %98 = llvm.mul %67, %94 : !llvm.i64
    %99 = llvm.add %97, %98 : !llvm.i64
    %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb1(%6 : !llvm.i64)
  ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
    %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
    llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
  ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
    %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
    llvm.cond_br %108, ^bb3, ^bb4
  ^bb3:  // pred: ^bb2
    %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %111 = llvm.mul %105, %20 : !llvm.i64
    %112 = llvm.add %110, %111 : !llvm.i64
    %113 = llvm.add %112, %107 : !llvm.i64
    %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    llvm.store %32, %114 : !llvm.ptr<float>
    %115 = llvm.add %107, %13 : !llvm.i64
    llvm.br ^bb2(%115 : !llvm.i64)
  ^bb4:  // pred: ^bb2
    %116 = llvm.add %105, %13 : !llvm.i64
    llvm.br ^bb1(%116 : !llvm.i64)
  ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
    %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
    llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
  ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
    %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
    llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
  ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
    %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
    llvm.cond_br %122, ^bb8, ^bb23
  ^bb8:  // pred: ^bb7
    %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
    %124 = llvm.mul %117, %123 : !llvm.i64
    %125 = llvm.add %124, %45 : !llvm.i64
    %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
    %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
    %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
    %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
    %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %137 = llvm.mul %117, %134 : !llvm.i64
    %138 = llvm.add %136, %137 : !llvm.i64
    %139 = llvm.mul %121, %135 : !llvm.i64
    %140 = llvm.add %138, %139 : !llvm.i64
    %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
    %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
    %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
    %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %156 = llvm.mul %121, %153 : !llvm.i64
    %157 = llvm.add %155, %156 : !llvm.i64
    %158 = llvm.mul %119, %154 : !llvm.i64
    %159 = llvm.add %157, %158 : !llvm.i64
    %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
    %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
    %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %174 = llvm.mul %117, %171 : !llvm.i64
    %175 = llvm.add %173, %174 : !llvm.i64
    %176 = llvm.mul %119, %172 : !llvm.i64
    %177 = llvm.add %175, %176 : !llvm.i64
    %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb9(%6 : !llvm.i64)
  ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
    %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
    llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
  ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
    %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
    llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
  ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
    %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
    llvm.cond_br %188, ^bb12, ^bb20
  ^bb12:  // pred: ^bb11
    %189 = llvm.mul %183, %123 : !llvm.i64
    %190 = llvm.add %127, %189 : !llvm.i64
    %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
    %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
    %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
    %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
    %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %202 = llvm.mul %183, %199 : !llvm.i64
    %203 = llvm.add %201, %202 : !llvm.i64
    %204 = llvm.mul %187, %200 : !llvm.i64
    %205 = llvm.add %203, %204 : !llvm.i64
    %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
    %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
    %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
    %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %221 = llvm.mul %187, %218 : !llvm.i64
    %222 = llvm.add %220, %221 : !llvm.i64
    %223 = llvm.mul %185, %219 : !llvm.i64
    %224 = llvm.add %222, %223 : !llvm.i64
    %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
    %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
    %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %239 = llvm.mul %183, %236 : !llvm.i64
    %240 = llvm.add %238, %239 : !llvm.i64
    %241 = llvm.mul %185, %237 : !llvm.i64
    %242 = llvm.add %240, %241 : !llvm.i64
    %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    llvm.br ^bb13(%6 : !llvm.i64)
  ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
    %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
    llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
  ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
    %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
    llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
  ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
    %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
    llvm.cond_br %253, ^bb16, ^bb17
  ^bb16:  // pred: ^bb15
    %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %256 = llvm.mul %248, %10 : !llvm.i64
    %257 = llvm.add %255, %256 : !llvm.i64
    %258 = llvm.add %257, %252 : !llvm.i64
    %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %260 = llvm.load %259 : !llvm.ptr<float>
    %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %263 = llvm.mul %252, %20 : !llvm.i64
    %264 = llvm.add %262, %263 : !llvm.i64
    %265 = llvm.add %264, %250 : !llvm.i64
    %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %267 = llvm.load %266 : !llvm.ptr<float>
    %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
    %270 = llvm.mul %248, %20 : !llvm.i64
    %271 = llvm.add %269, %270 : !llvm.i64
    %272 = llvm.add %271, %250 : !llvm.i64
    %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
    %274 = llvm.load %273 : !llvm.ptr<float>
    %275 = llvm.fmul %260, %267 : !llvm.float
    %276 = llvm.fadd %274, %275 : !llvm.float
    llvm.store %276, %273 : !llvm.ptr<float>
    %277 = llvm.add %252, %13 : !llvm.i64
    llvm.br ^bb15(%277 : !llvm.i64)
  ^bb17:  // pred: ^bb15
    %278 = llvm.add %250, %13 : !llvm.i64
    llvm.br ^bb14(%278 : !llvm.i64)
  ^bb18:  // pred: ^bb14
    %279 = llvm.add %248, %13 : !llvm.i64
    llvm.br ^bb13(%279 : !llvm.i64)
  ^bb19:  // pred: ^bb13
    %280 = llvm.add %187, %33 : !llvm.i64
    llvm.br ^bb11(%280 : !llvm.i64)
  ^bb20:  // pred: ^bb11
    %281 = llvm.add %185, %33 : !llvm.i64
    llvm.br ^bb10(%281 : !llvm.i64)
  ^bb21:  // pred: ^bb10
    %282 = llvm.add %183, %33 : !llvm.i64
    llvm.br ^bb9(%282 : !llvm.i64)
  ^bb22:  // pred: ^bb9
    %283 = llvm.add %121, %8 : !llvm.i64
    llvm.br ^bb7(%283 : !llvm.i64)
  ^bb23:  // pred: ^bb7
    %284 = llvm.add %119, %8 : !llvm.i64
    llvm.br ^bb6(%284 : !llvm.i64)
  ^bb24:  // pred: ^bb6
    %285 = llvm.add %117, %8 : !llvm.i64
    llvm.br ^bb5(%285 : !llvm.i64)
  ^bb25:  // pred: ^bb5
    llvm.return
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass
```
hal.executable.target @llvm_aot, filter="dylib*" {
  hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
  module  {
    func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
      %c1 = constant 1 : index
      return %c1, %c1, %c1 : index, index, index
    }
    llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
      %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
      %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
      %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
      %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %6 = llvm.mlir.constant(0 : index) : !llvm.i64
      %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %8 = llvm.mlir.constant(32 : index) : !llvm.i64
      %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
      %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %13 = llvm.mlir.constant(1 : index) : !llvm.i64
      %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
      %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %20 = llvm.mlir.constant(64 : index) : !llvm.i64
      %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
      %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
      %33 = llvm.mlir.constant(4 : index) : !llvm.i64
      %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
      %35 = llvm.load %34 : !llvm.ptr<i32>
      %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
      %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
      %38 = llvm.load %37 : !llvm.ptr<i32>
      %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
      %40 = llvm.mul %39, %20 : !llvm.i64
      %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
      %42 = llvm.mul %39, %41 : !llvm.i64
      %43 = llvm.add %42, %8 : !llvm.i64
      %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
      %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
      %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
      %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
      %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %55 = llvm.mul %40, %52 : !llvm.i64
      %56 = llvm.add %54, %55 : !llvm.i64
      %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
      %58 = llvm.mul %57, %53 : !llvm.i64
      %59 = llvm.add %56, %58 : !llvm.i64
      %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
      %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
      %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %67 = llvm.mul %36, %20 : !llvm.i64
      %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
      %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
      %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %77 = llvm.mul %57, %74 : !llvm.i64
      %78 = llvm.add %76, %77 : !llvm.i64
      %79 = llvm.mul %67, %75 : !llvm.i64
      %80 = llvm.add %78, %79 : !llvm.i64
      %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
      %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
      %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
      %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %96 = llvm.mul %40, %93 : !llvm.i64
      %97 = llvm.add %95, %96 : !llvm.i64
      %98 = llvm.mul %67, %94 : !llvm.i64
      %99 = llvm.add %97, %98 : !llvm.i64
      %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb1(%6 : !llvm.i64)
    ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
      %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
      llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
    ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
      %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
      llvm.cond_br %108, ^bb3, ^bb4
    ^bb3:  // pred: ^bb2
      %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %111 = llvm.mul %105, %20 : !llvm.i64
      %112 = llvm.add %110, %111 : !llvm.i64
      %113 = llvm.add %112, %107 : !llvm.i64
      %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
      llvm.store %32, %114 : !llvm.ptr<float>
      %115 = llvm.add %107, %13 : !llvm.i64
      llvm.br ^bb2(%115 : !llvm.i64)
    ^bb4:  // pred: ^bb2
      %116 = llvm.add %105, %13 : !llvm.i64
      llvm.br ^bb1(%116 : !llvm.i64)
    ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
      %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
      llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
    ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
      %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
      llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
    ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
      %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
      llvm.cond_br %122, ^bb8, ^bb23
    ^bb8:  // pred: ^bb7
      %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
      %124 = llvm.mul %117, %123 : !llvm.i64
      %125 = llvm.add %124, %45 : !llvm.i64
      %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
      %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
      %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
      %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
      %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %137 = llvm.mul %117, %134 : !llvm.i64
      %138 = llvm.add %136, %137 : !llvm.i64
      %139 = llvm.mul %121, %135 : !llvm.i64
      %140 = llvm.add %138, %139 : !llvm.i64
      %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
      %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
      %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
      %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %156 = llvm.mul %121, %153 : !llvm.i64
      %157 = llvm.add %155, %156 : !llvm.i64
      %158 = llvm.mul %119, %154 : !llvm.i64
      %159 = llvm.add %157, %158 : !llvm.i64
      %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
      %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
      %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %174 = llvm.mul %117, %171 : !llvm.i64
      %175 = llvm.add %173, %174 : !llvm.i64
      %176 = llvm.mul %119, %172 : !llvm.i64
      %177 = llvm.add %175, %176 : !llvm.i64
      %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb9(%6 : !llvm.i64)
    ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
      %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
      llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
    ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
      %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
      llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
    ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
      %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
      llvm.cond_br %188, ^bb12, ^bb20
    ^bb12:  // pred: ^bb11
      %189 = llvm.mul %183, %123 : !llvm.i64
      %190 = llvm.add %127, %189 : !llvm.i64
      %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
      %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
      %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
      %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
      %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %202 = llvm.mul %183, %199 : !llvm.i64
      %203 = llvm.add %201, %202 : !llvm.i64
      %204 = llvm.mul %187, %200 : !llvm.i64
      %205 = llvm.add %203, %204 : !llvm.i64
      %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
      %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
      %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
      %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %221 = llvm.mul %187, %218 : !llvm.i64
      %222 = llvm.add %220, %221 : !llvm.i64
      %223 = llvm.mul %185, %219 : !llvm.i64
      %224 = llvm.add %222, %223 : !llvm.i64
      %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
      %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
      %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %239 = llvm.mul %183, %236 : !llvm.i64
      %240 = llvm.add %238, %239 : !llvm.i64
      %241 = llvm.mul %185, %237 : !llvm.i64
      %242 = llvm.add %240, %241 : !llvm.i64
      %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      llvm.br ^bb13(%6 : !llvm.i64)
    ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
      %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
      llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
    ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
      %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
      llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
    ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
      %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
      llvm.cond_br %253, ^bb16, ^bb17
    ^bb16:  // pred: ^bb15
      %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %256 = llvm.mul %248, %10 : !llvm.i64
      %257 = llvm.add %255, %256 : !llvm.i64
      %258 = llvm.add %257, %252 : !llvm.i64
      %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
      %260 = llvm.load %259 : !llvm.ptr<float>
      %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %263 = llvm.mul %252, %20 : !llvm.i64
      %264 = llvm.add %262, %263 : !llvm.i64
      %265 = llvm.add %264, %250 : !llvm.i64
      %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
      %267 = llvm.load %266 : !llvm.ptr<float>
      %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
      %270 = llvm.mul %248, %20 : !llvm.i64
      %271 = llvm.add %269, %270 : !llvm.i64
      %272 = llvm.add %271, %250 : !llvm.i64
      %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
      %274 = llvm.load %273 : !llvm.ptr<float>
      %275 = llvm.fmul %260, %267 : !llvm.float
      %276 = llvm.fadd %274, %275 : !llvm.float
      llvm.store %276, %273 : !llvm.ptr<float>
      %277 = llvm.add %252, %13 : !llvm.i64
      llvm.br ^bb15(%277 : !llvm.i64)
    ^bb17:  // pred: ^bb15
      %278 = llvm.add %250, %13 : !llvm.i64
      llvm.br ^bb14(%278 : !llvm.i64)
    ^bb18:  // pred: ^bb14
      %279 = llvm.add %248, %13 : !llvm.i64
      llvm.br ^bb13(%279 : !llvm.i64)
    ^bb19:  // pred: ^bb13
      %280 = llvm.add %187, %33 : !llvm.i64
      llvm.br ^bb11(%280 : !llvm.i64)
    ^bb20:  // pred: ^bb11
      %281 = llvm.add %185, %33 : !llvm.i64
      llvm.br ^bb10(%281 : !llvm.i64)
    ^bb21:  // pred: ^bb10
      %282 = llvm.add %183, %33 : !llvm.i64
      llvm.br ^bb9(%282 : !llvm.i64)
    ^bb22:  // pred: ^bb9
      %283 = llvm.add %121, %8 : !llvm.i64
      llvm.br ^bb7(%283 : !llvm.i64)
    ^bb23:  // pred: ^bb7
      %284 = llvm.add %119, %8 : !llvm.i64
      llvm.br ^bb6(%284 : !llvm.i64)
    ^bb24:  // pred: ^bb6
      %285 = llvm.add %117, %8 : !llvm.i64
      llvm.br ^bb5(%285 : !llvm.i64)
    ^bb25:  // pred: ^bb5
      llvm.return
    }
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::{anonymous}::ConvertToHALPass
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module  {
        func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
          %c1 = constant 1 : index
          return %c1, %c1, %c1 : index, index, index
        }
        llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
          %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %6 = llvm.mlir.constant(0 : index) : !llvm.i64
          %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.mlir.constant(32 : index) : !llvm.i64
          %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
          %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.mlir.constant(1 : index) : !llvm.i64
          %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.mlir.constant(64 : index) : !llvm.i64
          %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
          %33 = llvm.mlir.constant(4 : index) : !llvm.i64
          %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %35 = llvm.load %34 : !llvm.ptr<i32>
          %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
          %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %38 = llvm.load %37 : !llvm.ptr<i32>
          %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
          %40 = llvm.mul %39, %20 : !llvm.i64
          %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
          %42 = llvm.mul %39, %41 : !llvm.i64
          %43 = llvm.add %42, %8 : !llvm.i64
          %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
          %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
          %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
          %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
          %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %55 = llvm.mul %40, %52 : !llvm.i64
          %56 = llvm.add %54, %55 : !llvm.i64
          %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
          %58 = llvm.mul %57, %53 : !llvm.i64
          %59 = llvm.add %56, %58 : !llvm.i64
          %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
          %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
          %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %67 = llvm.mul %36, %20 : !llvm.i64
          %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
          %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
          %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.mul %57, %74 : !llvm.i64
          %78 = llvm.add %76, %77 : !llvm.i64
          %79 = llvm.mul %67, %75 : !llvm.i64
          %80 = llvm.add %78, %79 : !llvm.i64
          %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
          %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
          %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
          %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.mul %40, %93 : !llvm.i64
          %97 = llvm.add %95, %96 : !llvm.i64
          %98 = llvm.mul %67, %94 : !llvm.i64
          %99 = llvm.add %97, %98 : !llvm.i64
          %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb1(%6 : !llvm.i64)
        ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
          %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
          llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
        ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
          %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
          llvm.cond_br %108, ^bb3, ^bb4
        ^bb3:  // pred: ^bb2
          %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mul %105, %20 : !llvm.i64
          %112 = llvm.add %110, %111 : !llvm.i64
          %113 = llvm.add %112, %107 : !llvm.i64
          %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          llvm.store %32, %114 : !llvm.ptr<float>
          %115 = llvm.add %107, %13 : !llvm.i64
          llvm.br ^bb2(%115 : !llvm.i64)
        ^bb4:  // pred: ^bb2
          %116 = llvm.add %105, %13 : !llvm.i64
          llvm.br ^bb1(%116 : !llvm.i64)
        ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
          %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
          llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
        ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
          %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
          llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
        ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
          %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
          llvm.cond_br %122, ^bb8, ^bb23
        ^bb8:  // pred: ^bb7
          %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
          %124 = llvm.mul %117, %123 : !llvm.i64
          %125 = llvm.add %124, %45 : !llvm.i64
          %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
          %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
          %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
          %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %117, %134 : !llvm.i64
          %138 = llvm.add %136, %137 : !llvm.i64
          %139 = llvm.mul %121, %135 : !llvm.i64
          %140 = llvm.add %138, %139 : !llvm.i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
          %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
          %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
          %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %156 = llvm.mul %121, %153 : !llvm.i64
          %157 = llvm.add %155, %156 : !llvm.i64
          %158 = llvm.mul %119, %154 : !llvm.i64
          %159 = llvm.add %157, %158 : !llvm.i64
          %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
          %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
          %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mul %117, %171 : !llvm.i64
          %175 = llvm.add %173, %174 : !llvm.i64
          %176 = llvm.mul %119, %172 : !llvm.i64
          %177 = llvm.add %175, %176 : !llvm.i64
          %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb9(%6 : !llvm.i64)
        ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
          %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
          llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
        ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
          %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
          llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
        ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
          %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
          llvm.cond_br %188, ^bb12, ^bb20
        ^bb12:  // pred: ^bb11
          %189 = llvm.mul %183, %123 : !llvm.i64
          %190 = llvm.add %127, %189 : !llvm.i64
          %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
          %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
          %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
          %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
          %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.mul %183, %199 : !llvm.i64
          %203 = llvm.add %201, %202 : !llvm.i64
          %204 = llvm.mul %187, %200 : !llvm.i64
          %205 = llvm.add %203, %204 : !llvm.i64
          %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
          %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
          %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
          %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %221 = llvm.mul %187, %218 : !llvm.i64
          %222 = llvm.add %220, %221 : !llvm.i64
          %223 = llvm.mul %185, %219 : !llvm.i64
          %224 = llvm.add %222, %223 : !llvm.i64
          %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
          %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
          %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %239 = llvm.mul %183, %236 : !llvm.i64
          %240 = llvm.add %238, %239 : !llvm.i64
          %241 = llvm.mul %185, %237 : !llvm.i64
          %242 = llvm.add %240, %241 : !llvm.i64
          %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%6 : !llvm.i64)
        ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
          %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
          llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
        ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
          %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
          llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
        ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
          %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
          llvm.cond_br %253, ^bb16, ^bb17
        ^bb16:  // pred: ^bb15
          %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.mul %248, %10 : !llvm.i64
          %257 = llvm.add %255, %256 : !llvm.i64
          %258 = llvm.add %257, %252 : !llvm.i64
          %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %260 = llvm.load %259 : !llvm.ptr<float>
          %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %263 = llvm.mul %252, %20 : !llvm.i64
          %264 = llvm.add %262, %263 : !llvm.i64
          %265 = llvm.add %264, %250 : !llvm.i64
          %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %267 = llvm.load %266 : !llvm.ptr<float>
          %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %248, %20 : !llvm.i64
          %271 = llvm.add %269, %270 : !llvm.i64
          %272 = llvm.add %271, %250 : !llvm.i64
          %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %274 = llvm.load %273 : !llvm.ptr<float>
          %275 = llvm.fmul %260, %267 : !llvm.float
          %276 = llvm.fadd %274, %275 : !llvm.float
          llvm.store %276, %273 : !llvm.ptr<float>
          %277 = llvm.add %252, %13 : !llvm.i64
          llvm.br ^bb15(%277 : !llvm.i64)
        ^bb17:  // pred: ^bb15
          %278 = llvm.add %250, %13 : !llvm.i64
          llvm.br ^bb14(%278 : !llvm.i64)
        ^bb18:  // pred: ^bb14
          %279 = llvm.add %248, %13 : !llvm.i64
          llvm.br ^bb13(%279 : !llvm.i64)
        ^bb19:  // pred: ^bb13
          %280 = llvm.add %187, %33 : !llvm.i64
          llvm.br ^bb11(%280 : !llvm.i64)
        ^bb20:  // pred: ^bb11
          %281 = llvm.add %185, %33 : !llvm.i64
          llvm.br ^bb10(%281 : !llvm.i64)
        ^bb21:  // pred: ^bb10
          %282 = llvm.add %183, %33 : !llvm.i64
          llvm.br ^bb9(%282 : !llvm.i64)
        ^bb22:  // pred: ^bb9
          %283 = llvm.add %121, %8 : !llvm.i64
          llvm.br ^bb7(%283 : !llvm.i64)
        ^bb23:  // pred: ^bb7
          %284 = llvm.add %119, %8 : !llvm.i64
          llvm.br ^bb6(%284 : !llvm.i64)
        ^bb24:  // pred: ^bb6
          %285 = llvm.add %117, %8 : !llvm.i64
          llvm.br ^bb5(%285 : !llvm.i64)
        ^bb25:  // pred: ^bb5
          llvm.return
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
    %c0 = constant 0 : index
    %c32_0 = constant 32 : index
    %c1024 = constant 1024 : index
    %allocator_1 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_2 = hal.allocator.compute_size %allocator_1, shape = [%c32_0, %c1024], element_type = 50331680
    %c1024_3 = constant 1024 : index
    %c64_4 = constant 64 : index
    %allocator_5 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_6 = hal.allocator.compute_size %allocator_5, shape = [%c1024_3, %c64_4], element_type = 50331680
    %c32_7 = constant 32 : index
    %c64_8 = constant 64 : index
    %allocator_9 = hal.buffer.allocator %buffer : !hal.allocator
    %sz_10 = hal.allocator.compute_size %allocator_9, shape = [%c32_7, %c64_8], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_2), 1 = (%arg1, %c0, %sz_6), 2 = (%buffer, %c0, %sz_10)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
      %c32_11 = constant 32 : index
      %c1024_12 = constant 1024 : index
      %c1024_13 = constant 1024 : index
      %c64_14 = constant 64 : index
      %c32_15 = constant 32 : index
      %c64_16 = constant 64 : index
      %c1 = constant 1 : index
      hal.command_buffer.dispatch.symbol %arg3, @dot_ex_dispatch_0::@llvm_aot::@dot_ex_dispatch_0, workgroup_xyz = [%c1, %c1, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ExpandFunctionRankedShapeDimsPass
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  %c0 = constant 0 : index
  %c32_0 = constant 32 : index
  %c1024 = constant 1024 : index
  %allocator_1 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_2 = hal.allocator.compute_size %allocator_1, shape = [%c32_0, %c1024], element_type = 50331680
  %c1024_3 = constant 1024 : index
  %c64_4 = constant 64 : index
  %allocator_5 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_6 = hal.allocator.compute_size %allocator_5, shape = [%c1024_3, %c64_4], element_type = 50331680
  %c32_7 = constant 32 : index
  %c64_8 = constant 64 : index
  %allocator_9 = hal.buffer.allocator %buffer : !hal.allocator
  %sz_10 = hal.allocator.compute_size %allocator_9, shape = [%c32_7, %c64_8], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_2), 1 = (%arg1, %c0, %sz_6), 2 = (%buffer, %c0, %sz_10)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
    %c32_11 = constant 32 : index
    %c1024_12 = constant 1024 : index
    %c1024_13 = constant 1024 : index
    %c64_14 = constant 64 : index
    %c32_15 = constant 32 : index
    %c64_16 = constant 64 : index
    %c1 = constant 1 : index
    hal.command_buffer.dispatch.symbol %arg3, @dot_ex_dispatch_0::@llvm_aot::@dot_ex_dispatch_0, workgroup_xyz = [%c1, %c1, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c131072 = constant 131072 : index
  %c262144 = constant 262144 : index
  %c8192 = constant 8192 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
    %c1 = constant 1 : index
    hal.command_buffer.dispatch.symbol %arg3, @dot_ex_dispatch_0::@llvm_aot::@dot_ex_dispatch_0, workgroup_xyz = [%c1, %c1, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After CSE
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c131072 = constant 131072 : index
  %c262144 = constant 262144 : index
  %c8192 = constant 8192 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
    %c1 = constant 1 : index
    hal.command_buffer.dispatch.symbol %arg3, @dot_ex_dispatch_0::@llvm_aot::@dot_ex_dispatch_0, workgroup_xyz = [%c1, %c1, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::{anonymous}::PublicABIGenerationPass
```
module  {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module  {
        func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
          %c1 = constant 1 : index
          return %c1, %c1, %c1 : index, index, index
        }
        llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
          %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %6 = llvm.mlir.constant(0 : index) : !llvm.i64
          %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.mlir.constant(32 : index) : !llvm.i64
          %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
          %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.mlir.constant(1 : index) : !llvm.i64
          %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.mlir.constant(64 : index) : !llvm.i64
          %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
          %33 = llvm.mlir.constant(4 : index) : !llvm.i64
          %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %35 = llvm.load %34 : !llvm.ptr<i32>
          %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
          %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %38 = llvm.load %37 : !llvm.ptr<i32>
          %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
          %40 = llvm.mul %39, %20 : !llvm.i64
          %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
          %42 = llvm.mul %39, %41 : !llvm.i64
          %43 = llvm.add %42, %8 : !llvm.i64
          %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
          %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
          %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
          %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
          %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %55 = llvm.mul %40, %52 : !llvm.i64
          %56 = llvm.add %54, %55 : !llvm.i64
          %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
          %58 = llvm.mul %57, %53 : !llvm.i64
          %59 = llvm.add %56, %58 : !llvm.i64
          %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
          %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
          %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %67 = llvm.mul %36, %20 : !llvm.i64
          %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
          %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
          %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.mul %57, %74 : !llvm.i64
          %78 = llvm.add %76, %77 : !llvm.i64
          %79 = llvm.mul %67, %75 : !llvm.i64
          %80 = llvm.add %78, %79 : !llvm.i64
          %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
          %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
          %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
          %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.mul %40, %93 : !llvm.i64
          %97 = llvm.add %95, %96 : !llvm.i64
          %98 = llvm.mul %67, %94 : !llvm.i64
          %99 = llvm.add %97, %98 : !llvm.i64
          %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb1(%6 : !llvm.i64)
        ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
          %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
          llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
        ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
          %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
          llvm.cond_br %108, ^bb3, ^bb4
        ^bb3:  // pred: ^bb2
          %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mul %105, %20 : !llvm.i64
          %112 = llvm.add %110, %111 : !llvm.i64
          %113 = llvm.add %112, %107 : !llvm.i64
          %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          llvm.store %32, %114 : !llvm.ptr<float>
          %115 = llvm.add %107, %13 : !llvm.i64
          llvm.br ^bb2(%115 : !llvm.i64)
        ^bb4:  // pred: ^bb2
          %116 = llvm.add %105, %13 : !llvm.i64
          llvm.br ^bb1(%116 : !llvm.i64)
        ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
          %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
          llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
        ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
          %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
          llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
        ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
          %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
          llvm.cond_br %122, ^bb8, ^bb23
        ^bb8:  // pred: ^bb7
          %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
          %124 = llvm.mul %117, %123 : !llvm.i64
          %125 = llvm.add %124, %45 : !llvm.i64
          %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
          %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
          %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
          %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %117, %134 : !llvm.i64
          %138 = llvm.add %136, %137 : !llvm.i64
          %139 = llvm.mul %121, %135 : !llvm.i64
          %140 = llvm.add %138, %139 : !llvm.i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
          %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
          %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
          %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %156 = llvm.mul %121, %153 : !llvm.i64
          %157 = llvm.add %155, %156 : !llvm.i64
          %158 = llvm.mul %119, %154 : !llvm.i64
          %159 = llvm.add %157, %158 : !llvm.i64
          %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
          %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
          %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mul %117, %171 : !llvm.i64
          %175 = llvm.add %173, %174 : !llvm.i64
          %176 = llvm.mul %119, %172 : !llvm.i64
          %177 = llvm.add %175, %176 : !llvm.i64
          %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb9(%6 : !llvm.i64)
        ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
          %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
          llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
        ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
          %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
          llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
        ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
          %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
          llvm.cond_br %188, ^bb12, ^bb20
        ^bb12:  // pred: ^bb11
          %189 = llvm.mul %183, %123 : !llvm.i64
          %190 = llvm.add %127, %189 : !llvm.i64
          %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
          %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
          %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
          %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
          %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.mul %183, %199 : !llvm.i64
          %203 = llvm.add %201, %202 : !llvm.i64
          %204 = llvm.mul %187, %200 : !llvm.i64
          %205 = llvm.add %203, %204 : !llvm.i64
          %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
          %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
          %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
          %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %221 = llvm.mul %187, %218 : !llvm.i64
          %222 = llvm.add %220, %221 : !llvm.i64
          %223 = llvm.mul %185, %219 : !llvm.i64
          %224 = llvm.add %222, %223 : !llvm.i64
          %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
          %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
          %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %239 = llvm.mul %183, %236 : !llvm.i64
          %240 = llvm.add %238, %239 : !llvm.i64
          %241 = llvm.mul %185, %237 : !llvm.i64
          %242 = llvm.add %240, %241 : !llvm.i64
          %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%6 : !llvm.i64)
        ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
          %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
          llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
        ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
          %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
          llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
        ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
          %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
          llvm.cond_br %253, ^bb16, ^bb17
        ^bb16:  // pred: ^bb15
          %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.mul %248, %10 : !llvm.i64
          %257 = llvm.add %255, %256 : !llvm.i64
          %258 = llvm.add %257, %252 : !llvm.i64
          %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %260 = llvm.load %259 : !llvm.ptr<float>
          %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %263 = llvm.mul %252, %20 : !llvm.i64
          %264 = llvm.add %262, %263 : !llvm.i64
          %265 = llvm.add %264, %250 : !llvm.i64
          %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %267 = llvm.load %266 : !llvm.ptr<float>
          %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %248, %20 : !llvm.i64
          %271 = llvm.add %269, %270 : !llvm.i64
          %272 = llvm.add %271, %250 : !llvm.i64
          %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %274 = llvm.load %273 : !llvm.ptr<float>
          %275 = llvm.fmul %260, %267 : !llvm.float
          %276 = llvm.fadd %274, %275 : !llvm.float
          llvm.store %276, %273 : !llvm.ptr<float>
          %277 = llvm.add %252, %13 : !llvm.i64
          llvm.br ^bb15(%277 : !llvm.i64)
        ^bb17:  // pred: ^bb15
          %278 = llvm.add %250, %13 : !llvm.i64
          llvm.br ^bb14(%278 : !llvm.i64)
        ^bb18:  // pred: ^bb14
          %279 = llvm.add %248, %13 : !llvm.i64
          llvm.br ^bb13(%279 : !llvm.i64)
        ^bb19:  // pred: ^bb13
          %280 = llvm.add %187, %33 : !llvm.i64
          llvm.br ^bb11(%280 : !llvm.i64)
        ^bb20:  // pred: ^bb11
          %281 = llvm.add %185, %33 : !llvm.i64
          llvm.br ^bb10(%281 : !llvm.i64)
        ^bb21:  // pred: ^bb10
          %282 = llvm.add %183, %33 : !llvm.i64
          llvm.br ^bb9(%282 : !llvm.i64)
        ^bb22:  // pred: ^bb9
          %283 = llvm.add %121, %8 : !llvm.i64
          llvm.br ^bb7(%283 : !llvm.i64)
        ^bb23:  // pred: ^bb7
          %284 = llvm.add %119, %8 : !llvm.i64
          llvm.br ^bb6(%284 : !llvm.i64)
        ^bb24:  // pred: ^bb6
          %285 = llvm.add %117, %8 : !llvm.i64
          llvm.br ^bb5(%285 : !llvm.i64)
        ^bb25:  // pred: ^bb5
          llvm.return
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c131072 = constant 131072 : index
    %c262144 = constant 262144 : index
    %c8192 = constant 8192 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
    hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
      %c1 = constant 1 : index
      hal.command_buffer.dispatch.symbol %arg3, @dot_ex_dispatch_0::@llvm_aot::@dot_ex_dispatch_0, workgroup_xyz = [%c1, %c1, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::LinkExecutablesPass
```
module  {
  hal.executable @"mhlo-dot_linked_llvm_aot" attributes {sym_visibility = "private"} {
    hal.interface @legacy_io_0 {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io_0, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module  {
        func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
          %c1 = constant 1 : index
          return %c1, %c1, %c1 : index, index, index
        }
        llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
          %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %6 = llvm.mlir.constant(0 : index) : !llvm.i64
          %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.mlir.constant(32 : index) : !llvm.i64
          %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
          %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.mlir.constant(1 : index) : !llvm.i64
          %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.mlir.constant(64 : index) : !llvm.i64
          %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
          %33 = llvm.mlir.constant(4 : index) : !llvm.i64
          %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %35 = llvm.load %34 : !llvm.ptr<i32>
          %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
          %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %38 = llvm.load %37 : !llvm.ptr<i32>
          %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
          %40 = llvm.mul %39, %20 : !llvm.i64
          %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
          %42 = llvm.mul %39, %41 : !llvm.i64
          %43 = llvm.add %42, %8 : !llvm.i64
          %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
          %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
          %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
          %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
          %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %55 = llvm.mul %40, %52 : !llvm.i64
          %56 = llvm.add %54, %55 : !llvm.i64
          %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
          %58 = llvm.mul %57, %53 : !llvm.i64
          %59 = llvm.add %56, %58 : !llvm.i64
          %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
          %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
          %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %67 = llvm.mul %36, %20 : !llvm.i64
          %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
          %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
          %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.mul %57, %74 : !llvm.i64
          %78 = llvm.add %76, %77 : !llvm.i64
          %79 = llvm.mul %67, %75 : !llvm.i64
          %80 = llvm.add %78, %79 : !llvm.i64
          %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
          %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
          %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
          %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.mul %40, %93 : !llvm.i64
          %97 = llvm.add %95, %96 : !llvm.i64
          %98 = llvm.mul %67, %94 : !llvm.i64
          %99 = llvm.add %97, %98 : !llvm.i64
          %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb1(%6 : !llvm.i64)
        ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
          %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
          llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
        ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
          %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
          llvm.cond_br %108, ^bb3, ^bb4
        ^bb3:  // pred: ^bb2
          %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mul %105, %20 : !llvm.i64
          %112 = llvm.add %110, %111 : !llvm.i64
          %113 = llvm.add %112, %107 : !llvm.i64
          %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          llvm.store %32, %114 : !llvm.ptr<float>
          %115 = llvm.add %107, %13 : !llvm.i64
          llvm.br ^bb2(%115 : !llvm.i64)
        ^bb4:  // pred: ^bb2
          %116 = llvm.add %105, %13 : !llvm.i64
          llvm.br ^bb1(%116 : !llvm.i64)
        ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
          %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
          llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
        ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
          %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
          llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
        ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
          %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
          llvm.cond_br %122, ^bb8, ^bb23
        ^bb8:  // pred: ^bb7
          %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
          %124 = llvm.mul %117, %123 : !llvm.i64
          %125 = llvm.add %124, %45 : !llvm.i64
          %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
          %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
          %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
          %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %117, %134 : !llvm.i64
          %138 = llvm.add %136, %137 : !llvm.i64
          %139 = llvm.mul %121, %135 : !llvm.i64
          %140 = llvm.add %138, %139 : !llvm.i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
          %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
          %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
          %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %156 = llvm.mul %121, %153 : !llvm.i64
          %157 = llvm.add %155, %156 : !llvm.i64
          %158 = llvm.mul %119, %154 : !llvm.i64
          %159 = llvm.add %157, %158 : !llvm.i64
          %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
          %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
          %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mul %117, %171 : !llvm.i64
          %175 = llvm.add %173, %174 : !llvm.i64
          %176 = llvm.mul %119, %172 : !llvm.i64
          %177 = llvm.add %175, %176 : !llvm.i64
          %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb9(%6 : !llvm.i64)
        ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
          %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
          llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
        ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
          %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
          llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
        ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
          %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
          llvm.cond_br %188, ^bb12, ^bb20
        ^bb12:  // pred: ^bb11
          %189 = llvm.mul %183, %123 : !llvm.i64
          %190 = llvm.add %127, %189 : !llvm.i64
          %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
          %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
          %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
          %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
          %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.mul %183, %199 : !llvm.i64
          %203 = llvm.add %201, %202 : !llvm.i64
          %204 = llvm.mul %187, %200 : !llvm.i64
          %205 = llvm.add %203, %204 : !llvm.i64
          %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
          %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
          %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
          %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %221 = llvm.mul %187, %218 : !llvm.i64
          %222 = llvm.add %220, %221 : !llvm.i64
          %223 = llvm.mul %185, %219 : !llvm.i64
          %224 = llvm.add %222, %223 : !llvm.i64
          %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
          %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
          %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %239 = llvm.mul %183, %236 : !llvm.i64
          %240 = llvm.add %238, %239 : !llvm.i64
          %241 = llvm.mul %185, %237 : !llvm.i64
          %242 = llvm.add %240, %241 : !llvm.i64
          %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%6 : !llvm.i64)
        ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
          %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
          llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
        ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
          %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
          llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
        ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
          %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
          llvm.cond_br %253, ^bb16, ^bb17
        ^bb16:  // pred: ^bb15
          %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.mul %248, %10 : !llvm.i64
          %257 = llvm.add %255, %256 : !llvm.i64
          %258 = llvm.add %257, %252 : !llvm.i64
          %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %260 = llvm.load %259 : !llvm.ptr<float>
          %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %263 = llvm.mul %252, %20 : !llvm.i64
          %264 = llvm.add %262, %263 : !llvm.i64
          %265 = llvm.add %264, %250 : !llvm.i64
          %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %267 = llvm.load %266 : !llvm.ptr<float>
          %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %248, %20 : !llvm.i64
          %271 = llvm.add %269, %270 : !llvm.i64
          %272 = llvm.add %271, %250 : !llvm.i64
          %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %274 = llvm.load %273 : !llvm.ptr<float>
          %275 = llvm.fmul %260, %267 : !llvm.float
          %276 = llvm.fadd %274, %275 : !llvm.float
          llvm.store %276, %273 : !llvm.ptr<float>
          %277 = llvm.add %252, %13 : !llvm.i64
          llvm.br ^bb15(%277 : !llvm.i64)
        ^bb17:  // pred: ^bb15
          %278 = llvm.add %250, %13 : !llvm.i64
          llvm.br ^bb14(%278 : !llvm.i64)
        ^bb18:  // pred: ^bb14
          %279 = llvm.add %248, %13 : !llvm.i64
          llvm.br ^bb13(%279 : !llvm.i64)
        ^bb19:  // pred: ^bb13
          %280 = llvm.add %187, %33 : !llvm.i64
          llvm.br ^bb11(%280 : !llvm.i64)
        ^bb20:  // pred: ^bb11
          %281 = llvm.add %185, %33 : !llvm.i64
          llvm.br ^bb10(%281 : !llvm.i64)
        ^bb21:  // pred: ^bb10
          %282 = llvm.add %183, %33 : !llvm.i64
          llvm.br ^bb9(%282 : !llvm.i64)
        ^bb22:  // pred: ^bb9
          %283 = llvm.add %121, %8 : !llvm.i64
          llvm.br ^bb7(%283 : !llvm.i64)
        ^bb23:  // pred: ^bb7
          %284 = llvm.add %119, %8 : !llvm.i64
          llvm.br ^bb6(%284 : !llvm.i64)
        ^bb24:  // pred: ^bb6
          %285 = llvm.add %117, %8 : !llvm.i64
          llvm.br ^bb5(%285 : !llvm.i64)
        ^bb25:  // pred: ^bb5
          llvm.return
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c131072 = constant 131072 : index
    %c262144 = constant 262144 : index
    %c8192 = constant 8192 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
    hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
      %c1 = constant 1 : index
      hal.command_buffer.dispatch.symbol %arg3, @"mhlo-dot_linked_llvm_aot"::@llvm_aot::@dot_ex_dispatch_0, workgroup_xyz = [%c1, %c1, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::ResolveEntryPointOrdinalsPass
```
module  {
  hal.executable @"mhlo-dot_linked_llvm_aot" attributes {sym_visibility = "private"} {
    hal.interface @legacy_io_0 {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io_0, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module  {
        func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
          %c1 = constant 1 : index
          return %c1, %c1, %c1 : index, index, index
        }
        llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
          %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %6 = llvm.mlir.constant(0 : index) : !llvm.i64
          %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.mlir.constant(32 : index) : !llvm.i64
          %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
          %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.mlir.constant(1 : index) : !llvm.i64
          %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.mlir.constant(64 : index) : !llvm.i64
          %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
          %33 = llvm.mlir.constant(4 : index) : !llvm.i64
          %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %35 = llvm.load %34 : !llvm.ptr<i32>
          %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
          %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %38 = llvm.load %37 : !llvm.ptr<i32>
          %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
          %40 = llvm.mul %39, %20 : !llvm.i64
          %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
          %42 = llvm.mul %39, %41 : !llvm.i64
          %43 = llvm.add %42, %8 : !llvm.i64
          %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
          %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
          %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
          %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
          %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %55 = llvm.mul %40, %52 : !llvm.i64
          %56 = llvm.add %54, %55 : !llvm.i64
          %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
          %58 = llvm.mul %57, %53 : !llvm.i64
          %59 = llvm.add %56, %58 : !llvm.i64
          %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
          %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
          %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %67 = llvm.mul %36, %20 : !llvm.i64
          %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
          %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
          %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.mul %57, %74 : !llvm.i64
          %78 = llvm.add %76, %77 : !llvm.i64
          %79 = llvm.mul %67, %75 : !llvm.i64
          %80 = llvm.add %78, %79 : !llvm.i64
          %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
          %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
          %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
          %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.mul %40, %93 : !llvm.i64
          %97 = llvm.add %95, %96 : !llvm.i64
          %98 = llvm.mul %67, %94 : !llvm.i64
          %99 = llvm.add %97, %98 : !llvm.i64
          %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb1(%6 : !llvm.i64)
        ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
          %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
          llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
        ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
          %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
          llvm.cond_br %108, ^bb3, ^bb4
        ^bb3:  // pred: ^bb2
          %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mul %105, %20 : !llvm.i64
          %112 = llvm.add %110, %111 : !llvm.i64
          %113 = llvm.add %112, %107 : !llvm.i64
          %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          llvm.store %32, %114 : !llvm.ptr<float>
          %115 = llvm.add %107, %13 : !llvm.i64
          llvm.br ^bb2(%115 : !llvm.i64)
        ^bb4:  // pred: ^bb2
          %116 = llvm.add %105, %13 : !llvm.i64
          llvm.br ^bb1(%116 : !llvm.i64)
        ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
          %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
          llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
        ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
          %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
          llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
        ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
          %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
          llvm.cond_br %122, ^bb8, ^bb23
        ^bb8:  // pred: ^bb7
          %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
          %124 = llvm.mul %117, %123 : !llvm.i64
          %125 = llvm.add %124, %45 : !llvm.i64
          %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
          %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
          %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
          %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %117, %134 : !llvm.i64
          %138 = llvm.add %136, %137 : !llvm.i64
          %139 = llvm.mul %121, %135 : !llvm.i64
          %140 = llvm.add %138, %139 : !llvm.i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
          %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
          %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
          %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %156 = llvm.mul %121, %153 : !llvm.i64
          %157 = llvm.add %155, %156 : !llvm.i64
          %158 = llvm.mul %119, %154 : !llvm.i64
          %159 = llvm.add %157, %158 : !llvm.i64
          %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
          %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
          %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mul %117, %171 : !llvm.i64
          %175 = llvm.add %173, %174 : !llvm.i64
          %176 = llvm.mul %119, %172 : !llvm.i64
          %177 = llvm.add %175, %176 : !llvm.i64
          %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb9(%6 : !llvm.i64)
        ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
          %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
          llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
        ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
          %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
          llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
        ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
          %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
          llvm.cond_br %188, ^bb12, ^bb20
        ^bb12:  // pred: ^bb11
          %189 = llvm.mul %183, %123 : !llvm.i64
          %190 = llvm.add %127, %189 : !llvm.i64
          %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
          %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
          %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
          %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
          %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.mul %183, %199 : !llvm.i64
          %203 = llvm.add %201, %202 : !llvm.i64
          %204 = llvm.mul %187, %200 : !llvm.i64
          %205 = llvm.add %203, %204 : !llvm.i64
          %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
          %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
          %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
          %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %221 = llvm.mul %187, %218 : !llvm.i64
          %222 = llvm.add %220, %221 : !llvm.i64
          %223 = llvm.mul %185, %219 : !llvm.i64
          %224 = llvm.add %222, %223 : !llvm.i64
          %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
          %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
          %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %239 = llvm.mul %183, %236 : !llvm.i64
          %240 = llvm.add %238, %239 : !llvm.i64
          %241 = llvm.mul %185, %237 : !llvm.i64
          %242 = llvm.add %240, %241 : !llvm.i64
          %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%6 : !llvm.i64)
        ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
          %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
          llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
        ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
          %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
          llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
        ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
          %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
          llvm.cond_br %253, ^bb16, ^bb17
        ^bb16:  // pred: ^bb15
          %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.mul %248, %10 : !llvm.i64
          %257 = llvm.add %255, %256 : !llvm.i64
          %258 = llvm.add %257, %252 : !llvm.i64
          %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %260 = llvm.load %259 : !llvm.ptr<float>
          %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %263 = llvm.mul %252, %20 : !llvm.i64
          %264 = llvm.add %262, %263 : !llvm.i64
          %265 = llvm.add %264, %250 : !llvm.i64
          %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %267 = llvm.load %266 : !llvm.ptr<float>
          %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %248, %20 : !llvm.i64
          %271 = llvm.add %269, %270 : !llvm.i64
          %272 = llvm.add %271, %250 : !llvm.i64
          %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %274 = llvm.load %273 : !llvm.ptr<float>
          %275 = llvm.fmul %260, %267 : !llvm.float
          %276 = llvm.fadd %274, %275 : !llvm.float
          llvm.store %276, %273 : !llvm.ptr<float>
          %277 = llvm.add %252, %13 : !llvm.i64
          llvm.br ^bb15(%277 : !llvm.i64)
        ^bb17:  // pred: ^bb15
          %278 = llvm.add %250, %13 : !llvm.i64
          llvm.br ^bb14(%278 : !llvm.i64)
        ^bb18:  // pred: ^bb14
          %279 = llvm.add %248, %13 : !llvm.i64
          llvm.br ^bb13(%279 : !llvm.i64)
        ^bb19:  // pred: ^bb13
          %280 = llvm.add %187, %33 : !llvm.i64
          llvm.br ^bb11(%280 : !llvm.i64)
        ^bb20:  // pred: ^bb11
          %281 = llvm.add %185, %33 : !llvm.i64
          llvm.br ^bb10(%281 : !llvm.i64)
        ^bb21:  // pred: ^bb10
          %282 = llvm.add %183, %33 : !llvm.i64
          llvm.br ^bb9(%282 : !llvm.i64)
        ^bb22:  // pred: ^bb9
          %283 = llvm.add %121, %8 : !llvm.i64
          llvm.br ^bb7(%283 : !llvm.i64)
        ^bb23:  // pred: ^bb7
          %284 = llvm.add %119, %8 : !llvm.i64
          llvm.br ^bb6(%284 : !llvm.i64)
        ^bb24:  // pred: ^bb6
          %285 = llvm.add %117, %8 : !llvm.i64
          llvm.br ^bb5(%285 : !llvm.i64)
        ^bb25:  // pred: ^bb5
          llvm.return
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c131072 = constant 131072 : index
    %c262144 = constant 262144 : index
    %c8192 = constant 8192 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
    hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
      %c1 = constant 1 : index
      %0 = hal.command_buffer.device %arg3 : !hal.device
      %exe = hal.executable.lookup %0, @"mhlo-dot_linked_llvm_aot" : !hal.executable
      hal.command_buffer.dispatch %arg3, %exe, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c131072 = constant 131072 : index
  %c262144 = constant 262144 : index
  %c8192 = constant 8192 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
    %c1 = constant 1 : index
    %0 = hal.command_buffer.device %arg3 : !hal.device
    %exe = hal.executable.lookup %0, @"mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.command_buffer.dispatch %arg3, %exe, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After CSE
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c131072 = constant 131072 : index
  %c262144 = constant 262144 : index
  %c8192 = constant 8192 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
    %c1 = constant 1 : index
    %0 = hal.command_buffer.device %arg3 : !hal.device
    %exe = hal.executable.lookup %0, @"mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.command_buffer.dispatch %arg3, %exe, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After Canonicalizer
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After Canonicalizer
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeResourceCachesPass
```
module  {
  hal.variable @"_executable_mhlo-dot_linked_llvm_aot" mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func private @_executable_cache_initializer() -> !hal.executable_cache {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg0 = %executable_cache_default : !hal.executable_cache) {
      %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
      %executable_mhlo-dot_linked_llvm_aot = hal.executable_cache.prepare %arg0, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @"mhlo-dot_linked_llvm_aot" : !hal.executable
      hal.variable.store %executable_mhlo-dot_linked_llvm_aot, @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
      hal.return
    }
    return %executable_cache_default : !hal.executable_cache
  }
  hal.executable @"mhlo-dot_linked_llvm_aot" attributes {sym_visibility = "private"} {
    hal.interface @legacy_io_0 {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io_0, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module  {
        func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
          %c1 = constant 1 : index
          return %c1, %c1, %c1 : index, index, index
        }
        llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
          %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %6 = llvm.mlir.constant(0 : index) : !llvm.i64
          %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.mlir.constant(32 : index) : !llvm.i64
          %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
          %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.mlir.constant(1 : index) : !llvm.i64
          %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.mlir.constant(64 : index) : !llvm.i64
          %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
          %33 = llvm.mlir.constant(4 : index) : !llvm.i64
          %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %35 = llvm.load %34 : !llvm.ptr<i32>
          %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
          %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %38 = llvm.load %37 : !llvm.ptr<i32>
          %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
          %40 = llvm.mul %39, %20 : !llvm.i64
          %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
          %42 = llvm.mul %39, %41 : !llvm.i64
          %43 = llvm.add %42, %8 : !llvm.i64
          %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
          %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
          %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
          %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
          %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %55 = llvm.mul %40, %52 : !llvm.i64
          %56 = llvm.add %54, %55 : !llvm.i64
          %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
          %58 = llvm.mul %57, %53 : !llvm.i64
          %59 = llvm.add %56, %58 : !llvm.i64
          %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
          %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
          %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %67 = llvm.mul %36, %20 : !llvm.i64
          %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
          %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
          %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.mul %57, %74 : !llvm.i64
          %78 = llvm.add %76, %77 : !llvm.i64
          %79 = llvm.mul %67, %75 : !llvm.i64
          %80 = llvm.add %78, %79 : !llvm.i64
          %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
          %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
          %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
          %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.mul %40, %93 : !llvm.i64
          %97 = llvm.add %95, %96 : !llvm.i64
          %98 = llvm.mul %67, %94 : !llvm.i64
          %99 = llvm.add %97, %98 : !llvm.i64
          %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb1(%6 : !llvm.i64)
        ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
          %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
          llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
        ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
          %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
          llvm.cond_br %108, ^bb3, ^bb4
        ^bb3:  // pred: ^bb2
          %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mul %105, %20 : !llvm.i64
          %112 = llvm.add %110, %111 : !llvm.i64
          %113 = llvm.add %112, %107 : !llvm.i64
          %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          llvm.store %32, %114 : !llvm.ptr<float>
          %115 = llvm.add %107, %13 : !llvm.i64
          llvm.br ^bb2(%115 : !llvm.i64)
        ^bb4:  // pred: ^bb2
          %116 = llvm.add %105, %13 : !llvm.i64
          llvm.br ^bb1(%116 : !llvm.i64)
        ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
          %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
          llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
        ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
          %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
          llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
        ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
          %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
          llvm.cond_br %122, ^bb8, ^bb23
        ^bb8:  // pred: ^bb7
          %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
          %124 = llvm.mul %117, %123 : !llvm.i64
          %125 = llvm.add %124, %45 : !llvm.i64
          %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
          %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
          %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
          %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %117, %134 : !llvm.i64
          %138 = llvm.add %136, %137 : !llvm.i64
          %139 = llvm.mul %121, %135 : !llvm.i64
          %140 = llvm.add %138, %139 : !llvm.i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
          %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
          %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
          %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %156 = llvm.mul %121, %153 : !llvm.i64
          %157 = llvm.add %155, %156 : !llvm.i64
          %158 = llvm.mul %119, %154 : !llvm.i64
          %159 = llvm.add %157, %158 : !llvm.i64
          %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
          %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
          %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mul %117, %171 : !llvm.i64
          %175 = llvm.add %173, %174 : !llvm.i64
          %176 = llvm.mul %119, %172 : !llvm.i64
          %177 = llvm.add %175, %176 : !llvm.i64
          %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb9(%6 : !llvm.i64)
        ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
          %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
          llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
        ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
          %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
          llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
        ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
          %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
          llvm.cond_br %188, ^bb12, ^bb20
        ^bb12:  // pred: ^bb11
          %189 = llvm.mul %183, %123 : !llvm.i64
          %190 = llvm.add %127, %189 : !llvm.i64
          %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
          %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
          %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
          %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
          %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.mul %183, %199 : !llvm.i64
          %203 = llvm.add %201, %202 : !llvm.i64
          %204 = llvm.mul %187, %200 : !llvm.i64
          %205 = llvm.add %203, %204 : !llvm.i64
          %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
          %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
          %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
          %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %221 = llvm.mul %187, %218 : !llvm.i64
          %222 = llvm.add %220, %221 : !llvm.i64
          %223 = llvm.mul %185, %219 : !llvm.i64
          %224 = llvm.add %222, %223 : !llvm.i64
          %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
          %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
          %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %239 = llvm.mul %183, %236 : !llvm.i64
          %240 = llvm.add %238, %239 : !llvm.i64
          %241 = llvm.mul %185, %237 : !llvm.i64
          %242 = llvm.add %240, %241 : !llvm.i64
          %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%6 : !llvm.i64)
        ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
          %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
          llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
        ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
          %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
          llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
        ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
          %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
          llvm.cond_br %253, ^bb16, ^bb17
        ^bb16:  // pred: ^bb15
          %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.mul %248, %10 : !llvm.i64
          %257 = llvm.add %255, %256 : !llvm.i64
          %258 = llvm.add %257, %252 : !llvm.i64
          %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %260 = llvm.load %259 : !llvm.ptr<float>
          %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %263 = llvm.mul %252, %20 : !llvm.i64
          %264 = llvm.add %262, %263 : !llvm.i64
          %265 = llvm.add %264, %250 : !llvm.i64
          %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %267 = llvm.load %266 : !llvm.ptr<float>
          %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %248, %20 : !llvm.i64
          %271 = llvm.add %269, %270 : !llvm.i64
          %272 = llvm.add %271, %250 : !llvm.i64
          %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %274 = llvm.load %273 : !llvm.ptr<float>
          %275 = llvm.fmul %260, %267 : !llvm.float
          %276 = llvm.fadd %274, %275 : !llvm.float
          llvm.store %276, %273 : !llvm.ptr<float>
          %277 = llvm.add %252, %13 : !llvm.i64
          llvm.br ^bb15(%277 : !llvm.i64)
        ^bb17:  // pred: ^bb15
          %278 = llvm.add %250, %13 : !llvm.i64
          llvm.br ^bb14(%278 : !llvm.i64)
        ^bb18:  // pred: ^bb14
          %279 = llvm.add %248, %13 : !llvm.i64
          llvm.br ^bb13(%279 : !llvm.i64)
        ^bb19:  // pred: ^bb13
          %280 = llvm.add %187, %33 : !llvm.i64
          llvm.br ^bb11(%280 : !llvm.i64)
        ^bb20:  // pred: ^bb11
          %281 = llvm.add %185, %33 : !llvm.i64
          llvm.br ^bb10(%281 : !llvm.i64)
        ^bb21:  // pred: ^bb10
          %282 = llvm.add %183, %33 : !llvm.i64
          llvm.br ^bb9(%282 : !llvm.i64)
        ^bb22:  // pred: ^bb9
          %283 = llvm.add %121, %8 : !llvm.i64
          llvm.br ^bb7(%283 : !llvm.i64)
        ^bb23:  // pred: ^bb7
          %284 = llvm.add %119, %8 : !llvm.i64
          llvm.br ^bb6(%284 : !llvm.i64)
        ^bb24:  // pred: ^bb6
          %285 = llvm.add %117, %8 : !llvm.i64
          llvm.br ^bb5(%285 : !llvm.i64)
        ^bb25:  // pred: ^bb5
          llvm.return
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c131072 = constant 131072 : index
    %c262144 = constant 262144 : index
    %c8192 = constant 8192 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set %cmd, %0, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"dylib*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer) {
      %c1 = constant 1 : index
      %1 = hal.command_buffer.device %arg3 : !hal.device
      %2 = hal.variable.load @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
      hal.command_buffer.dispatch %arg3, %2, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %dev = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %dev = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func private @_executable_cache_initializer() -> !hal.executable_cache {
  %dev = hal.ex.shared_device : !hal.device
  %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
  %0 = hal.device.match.id %dev, pattern = ["dylib*"] : (!hal.device) -> i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %executable_mhlo-dot_linked_llvm_aot = hal.executable_cache.prepare %executable_cache_default, layout = %1, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @"mhlo-dot_linked_llvm_aot" : !hal.executable
  hal.variable.store %executable_mhlo-dot_linked_llvm_aot, @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
  br ^bb3
^bb2:  // pred: ^bb0
  iree.unreachable
^bb3:  // pred: ^bb1
  return %executable_cache_default : !hal.executable_cache
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c131072 = constant 131072 : index
  %c262144 = constant 262144 : index
  %c8192 = constant 8192 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set %cmd, %0, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
  %1 = hal.device.match.id %dev, pattern = ["dylib*"] : (!hal.device) -> i1
  cond_br %1, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %c1 = constant 1 : index
  %2 = hal.command_buffer.device %cmd : !hal.device
  %3 = hal.variable.load @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
  hal.command_buffer.dispatch %cmd, %3, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
  br ^bb3
^bb2:  // pred: ^bb0
  iree.unreachable
^bb3:  // pred: ^bb1
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::MemoizeDeviceQueriesPass
```
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %dev = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id %dev, pattern = ["dylib*"] : (!hal.device) -> i1
    return %0 : i1
  }
  hal.variable @"_executable_mhlo-dot_linked_llvm_aot" mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func private @_executable_cache_initializer() -> !hal.executable_cache {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %executable_mhlo-dot_linked_llvm_aot = hal.executable_cache.prepare %executable_cache_default, layout = %1, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @"mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.variable.store %executable_mhlo-dot_linked_llvm_aot, @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
    br ^bb3
  ^bb2:  // pred: ^bb0
    iree.unreachable
  ^bb3:  // pred: ^bb1
    return %executable_cache_default : !hal.executable_cache
  }
  hal.executable @"mhlo-dot_linked_llvm_aot" attributes {sym_visibility = "private"} {
    hal.interface @legacy_io_0 {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @llvm_aot, filter="dylib*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io_0, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module  {
        func private @dot_ex_dispatch_0__num_workgroups__(%arg0: !shapex.ranked_shape<[32,1024]>, %arg1: !shapex.ranked_shape<[1024,64]>, %arg2: !shapex.ranked_shape<[32,64]>) -> (index, index, index) {
          %c1 = constant 1 : index
          return %c1, %c1, %c1 : index, index, index
        }
        llvm.func @dot_ex_dispatch_0(%arg0: !llvm.ptr<ptr<i8>>, %arg1: !llvm.ptr<i32>, %arg2: !llvm.ptr<i32>, %arg3: !llvm.ptr<i32>, %arg4: !llvm.ptr<i32>) attributes {hal.num_workgroups_fn = @dot_ex_dispatch_0__num_workgroups__} {
          %0 = llvm.bitcast %arg0 : !llvm.ptr<ptr<i8>> to !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %1 = llvm.load %0 : !llvm.ptr<struct<(ptr<float>, ptr<float>, ptr<float>)>>
          %2 = llvm.extractvalue %1[0] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %3 = llvm.mlir.undef : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %4 = llvm.insertvalue %2, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %5 = llvm.insertvalue %2, %4[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %6 = llvm.mlir.constant(0 : index) : !llvm.i64
          %7 = llvm.insertvalue %6, %5[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %8 = llvm.mlir.constant(32 : index) : !llvm.i64
          %9 = llvm.insertvalue %8, %7[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %10 = llvm.mlir.constant(1024 : index) : !llvm.i64
          %11 = llvm.insertvalue %10, %9[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %12 = llvm.insertvalue %10, %11[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %13 = llvm.mlir.constant(1 : index) : !llvm.i64
          %14 = llvm.insertvalue %13, %12[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %15 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %16 = llvm.insertvalue %15, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %17 = llvm.insertvalue %15, %16[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %18 = llvm.insertvalue %6, %17[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %19 = llvm.insertvalue %10, %18[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %20 = llvm.mlir.constant(64 : index) : !llvm.i64
          %21 = llvm.insertvalue %20, %19[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %22 = llvm.insertvalue %20, %21[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %23 = llvm.insertvalue %13, %22[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %24 = llvm.extractvalue %1[2] : !llvm.struct<(ptr<float>, ptr<float>, ptr<float>)>
          %25 = llvm.insertvalue %24, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %26 = llvm.insertvalue %24, %25[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %27 = llvm.insertvalue %6, %26[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %28 = llvm.insertvalue %8, %27[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %29 = llvm.insertvalue %20, %28[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %30 = llvm.insertvalue %20, %29[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %31 = llvm.insertvalue %13, %30[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %32 = llvm.mlir.constant(0.000000e+00 : f32) : !llvm.float
          %33 = llvm.mlir.constant(4 : index) : !llvm.i64
          %34 = llvm.getelementptr %arg2[%6] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %35 = llvm.load %34 : !llvm.ptr<i32>
          %36 = llvm.zext %35 : !llvm.i32 to !llvm.i64
          %37 = llvm.getelementptr %arg2[%13] : (!llvm.ptr<i32>, !llvm.i64) -> !llvm.ptr<i32>
          %38 = llvm.load %37 : !llvm.ptr<i32>
          %39 = llvm.zext %38 : !llvm.i32 to !llvm.i64
          %40 = llvm.mul %39, %20 : !llvm.i64
          %41 = llvm.mlir.constant(-64 : index) : !llvm.i64
          %42 = llvm.mul %39, %41 : !llvm.i64
          %43 = llvm.add %42, %8 : !llvm.i64
          %44 = llvm.icmp "slt" %20, %43 : !llvm.i64
          %45 = llvm.select %44, %20, %43 : !llvm.i1, !llvm.i64
          %46 = llvm.extractvalue %14[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %47 = llvm.bitcast %46 : !llvm.ptr<float> to !llvm.ptr<float>
          %48 = llvm.insertvalue %47, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %49 = llvm.extractvalue %14[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %50 = llvm.bitcast %49 : !llvm.ptr<float> to !llvm.ptr<float>
          %51 = llvm.insertvalue %50, %48[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %52 = llvm.extractvalue %14[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %53 = llvm.extractvalue %14[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %54 = llvm.extractvalue %14[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %55 = llvm.mul %40, %52 : !llvm.i64
          %56 = llvm.add %54, %55 : !llvm.i64
          %57 = llvm.mlir.constant(0 : i64) : !llvm.i64
          %58 = llvm.mul %57, %53 : !llvm.i64
          %59 = llvm.add %56, %58 : !llvm.i64
          %60 = llvm.insertvalue %59, %51[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %61 = llvm.mlir.constant(1024 : i64) : !llvm.i64
          %62 = llvm.insertvalue %61, %60[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %63 = llvm.mlir.constant(1 : i64) : !llvm.i64
          %64 = llvm.insertvalue %63, %62[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %65 = llvm.insertvalue %45, %64[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %66 = llvm.insertvalue %61, %65[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %67 = llvm.mul %36, %20 : !llvm.i64
          %68 = llvm.extractvalue %23[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %69 = llvm.bitcast %68 : !llvm.ptr<float> to !llvm.ptr<float>
          %70 = llvm.insertvalue %69, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %71 = llvm.extractvalue %23[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %72 = llvm.bitcast %71 : !llvm.ptr<float> to !llvm.ptr<float>
          %73 = llvm.insertvalue %72, %70[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %74 = llvm.extractvalue %23[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %75 = llvm.extractvalue %23[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %76 = llvm.extractvalue %23[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %77 = llvm.mul %57, %74 : !llvm.i64
          %78 = llvm.add %76, %77 : !llvm.i64
          %79 = llvm.mul %67, %75 : !llvm.i64
          %80 = llvm.add %78, %79 : !llvm.i64
          %81 = llvm.insertvalue %80, %73[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %82 = llvm.mlir.constant(64 : i64) : !llvm.i64
          %83 = llvm.insertvalue %82, %81[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %84 = llvm.insertvalue %63, %83[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %85 = llvm.insertvalue %61, %84[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %86 = llvm.insertvalue %82, %85[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %87 = llvm.extractvalue %31[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %88 = llvm.bitcast %87 : !llvm.ptr<float> to !llvm.ptr<float>
          %89 = llvm.insertvalue %88, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %90 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %91 = llvm.bitcast %90 : !llvm.ptr<float> to !llvm.ptr<float>
          %92 = llvm.insertvalue %91, %89[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %93 = llvm.extractvalue %31[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %94 = llvm.extractvalue %31[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %95 = llvm.extractvalue %31[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %96 = llvm.mul %40, %93 : !llvm.i64
          %97 = llvm.add %95, %96 : !llvm.i64
          %98 = llvm.mul %67, %94 : !llvm.i64
          %99 = llvm.add %97, %98 : !llvm.i64
          %100 = llvm.insertvalue %99, %92[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %101 = llvm.insertvalue %82, %100[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %102 = llvm.insertvalue %63, %101[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %103 = llvm.insertvalue %45, %102[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %104 = llvm.insertvalue %82, %103[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb1(%6 : !llvm.i64)
        ^bb1(%105: !llvm.i64):  // 2 preds: ^bb0, ^bb4
          %106 = llvm.icmp "slt" %105, %45 : !llvm.i64
          llvm.cond_br %106, ^bb2(%6 : !llvm.i64), ^bb5(%6 : !llvm.i64)
        ^bb2(%107: !llvm.i64):  // 2 preds: ^bb1, ^bb3
          %108 = llvm.icmp "slt" %107, %20 : !llvm.i64
          llvm.cond_br %108, ^bb3, ^bb4
        ^bb3:  // pred: ^bb2
          %109 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %110 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %111 = llvm.mul %105, %20 : !llvm.i64
          %112 = llvm.add %110, %111 : !llvm.i64
          %113 = llvm.add %112, %107 : !llvm.i64
          %114 = llvm.getelementptr %109[%113] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          llvm.store %32, %114 : !llvm.ptr<float>
          %115 = llvm.add %107, %13 : !llvm.i64
          llvm.br ^bb2(%115 : !llvm.i64)
        ^bb4:  // pred: ^bb2
          %116 = llvm.add %105, %13 : !llvm.i64
          llvm.br ^bb1(%116 : !llvm.i64)
        ^bb5(%117: !llvm.i64):  // 2 preds: ^bb1, ^bb24
          %118 = llvm.icmp "slt" %117, %45 : !llvm.i64
          llvm.cond_br %118, ^bb6(%6 : !llvm.i64), ^bb25
        ^bb6(%119: !llvm.i64):  // 2 preds: ^bb5, ^bb23
          %120 = llvm.icmp "slt" %119, %20 : !llvm.i64
          llvm.cond_br %120, ^bb7(%6 : !llvm.i64), ^bb24
        ^bb7(%121: !llvm.i64):  // 2 preds: ^bb6, ^bb22
          %122 = llvm.icmp "slt" %121, %10 : !llvm.i64
          llvm.cond_br %122, ^bb8, ^bb23
        ^bb8:  // pred: ^bb7
          %123 = llvm.mlir.constant(-1 : index) : !llvm.i64
          %124 = llvm.mul %117, %123 : !llvm.i64
          %125 = llvm.add %124, %45 : !llvm.i64
          %126 = llvm.icmp "slt" %8, %125 : !llvm.i64
          %127 = llvm.select %126, %8, %125 : !llvm.i1, !llvm.i64
          %128 = llvm.extractvalue %66[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %129 = llvm.bitcast %128 : !llvm.ptr<float> to !llvm.ptr<float>
          %130 = llvm.insertvalue %129, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %131 = llvm.extractvalue %66[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %132 = llvm.bitcast %131 : !llvm.ptr<float> to !llvm.ptr<float>
          %133 = llvm.insertvalue %132, %130[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %134 = llvm.extractvalue %66[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %135 = llvm.extractvalue %66[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %136 = llvm.extractvalue %66[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %137 = llvm.mul %117, %134 : !llvm.i64
          %138 = llvm.add %136, %137 : !llvm.i64
          %139 = llvm.mul %121, %135 : !llvm.i64
          %140 = llvm.add %138, %139 : !llvm.i64
          %141 = llvm.insertvalue %140, %133[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %142 = llvm.mlir.constant(32 : i64) : !llvm.i64
          %143 = llvm.insertvalue %142, %141[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %144 = llvm.insertvalue %63, %143[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %145 = llvm.insertvalue %127, %144[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %146 = llvm.insertvalue %61, %145[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %147 = llvm.extractvalue %86[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %148 = llvm.bitcast %147 : !llvm.ptr<float> to !llvm.ptr<float>
          %149 = llvm.insertvalue %148, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %150 = llvm.extractvalue %86[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %151 = llvm.bitcast %150 : !llvm.ptr<float> to !llvm.ptr<float>
          %152 = llvm.insertvalue %151, %149[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %153 = llvm.extractvalue %86[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %154 = llvm.extractvalue %86[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %155 = llvm.extractvalue %86[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %156 = llvm.mul %121, %153 : !llvm.i64
          %157 = llvm.add %155, %156 : !llvm.i64
          %158 = llvm.mul %119, %154 : !llvm.i64
          %159 = llvm.add %157, %158 : !llvm.i64
          %160 = llvm.insertvalue %159, %152[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %161 = llvm.insertvalue %142, %160[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %162 = llvm.insertvalue %63, %161[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %163 = llvm.insertvalue %142, %162[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %164 = llvm.insertvalue %82, %163[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %165 = llvm.extractvalue %104[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %166 = llvm.bitcast %165 : !llvm.ptr<float> to !llvm.ptr<float>
          %167 = llvm.insertvalue %166, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %168 = llvm.extractvalue %104[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %169 = llvm.bitcast %168 : !llvm.ptr<float> to !llvm.ptr<float>
          %170 = llvm.insertvalue %169, %167[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %171 = llvm.extractvalue %104[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %172 = llvm.extractvalue %104[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %173 = llvm.extractvalue %104[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %174 = llvm.mul %117, %171 : !llvm.i64
          %175 = llvm.add %173, %174 : !llvm.i64
          %176 = llvm.mul %119, %172 : !llvm.i64
          %177 = llvm.add %175, %176 : !llvm.i64
          %178 = llvm.insertvalue %177, %170[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %179 = llvm.insertvalue %142, %178[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %180 = llvm.insertvalue %63, %179[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %181 = llvm.insertvalue %127, %180[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %182 = llvm.insertvalue %82, %181[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb9(%6 : !llvm.i64)
        ^bb9(%183: !llvm.i64):  // 2 preds: ^bb8, ^bb21
          %184 = llvm.icmp "slt" %183, %127 : !llvm.i64
          llvm.cond_br %184, ^bb10(%6 : !llvm.i64), ^bb22
        ^bb10(%185: !llvm.i64):  // 2 preds: ^bb9, ^bb20
          %186 = llvm.icmp "slt" %185, %8 : !llvm.i64
          llvm.cond_br %186, ^bb11(%6 : !llvm.i64), ^bb21
        ^bb11(%187: !llvm.i64):  // 2 preds: ^bb10, ^bb19
          %188 = llvm.icmp "slt" %187, %8 : !llvm.i64
          llvm.cond_br %188, ^bb12, ^bb20
        ^bb12:  // pred: ^bb11
          %189 = llvm.mul %183, %123 : !llvm.i64
          %190 = llvm.add %127, %189 : !llvm.i64
          %191 = llvm.icmp "slt" %33, %190 : !llvm.i64
          %192 = llvm.select %191, %33, %190 : !llvm.i1, !llvm.i64
          %193 = llvm.extractvalue %146[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %194 = llvm.bitcast %193 : !llvm.ptr<float> to !llvm.ptr<float>
          %195 = llvm.insertvalue %194, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %196 = llvm.extractvalue %146[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %197 = llvm.bitcast %196 : !llvm.ptr<float> to !llvm.ptr<float>
          %198 = llvm.insertvalue %197, %195[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %199 = llvm.extractvalue %146[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %200 = llvm.extractvalue %146[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %201 = llvm.extractvalue %146[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %202 = llvm.mul %183, %199 : !llvm.i64
          %203 = llvm.add %201, %202 : !llvm.i64
          %204 = llvm.mul %187, %200 : !llvm.i64
          %205 = llvm.add %203, %204 : !llvm.i64
          %206 = llvm.insertvalue %205, %198[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %207 = llvm.mlir.constant(4 : i64) : !llvm.i64
          %208 = llvm.insertvalue %207, %206[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %209 = llvm.insertvalue %63, %208[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %210 = llvm.insertvalue %192, %209[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %211 = llvm.insertvalue %61, %210[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %212 = llvm.extractvalue %164[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %213 = llvm.bitcast %212 : !llvm.ptr<float> to !llvm.ptr<float>
          %214 = llvm.insertvalue %213, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %215 = llvm.extractvalue %164[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %216 = llvm.bitcast %215 : !llvm.ptr<float> to !llvm.ptr<float>
          %217 = llvm.insertvalue %216, %214[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %218 = llvm.extractvalue %164[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %219 = llvm.extractvalue %164[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %220 = llvm.extractvalue %164[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %221 = llvm.mul %187, %218 : !llvm.i64
          %222 = llvm.add %220, %221 : !llvm.i64
          %223 = llvm.mul %185, %219 : !llvm.i64
          %224 = llvm.add %222, %223 : !llvm.i64
          %225 = llvm.insertvalue %224, %217[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %226 = llvm.insertvalue %207, %225[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %227 = llvm.insertvalue %63, %226[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %228 = llvm.insertvalue %207, %227[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %229 = llvm.insertvalue %82, %228[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %230 = llvm.extractvalue %182[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %231 = llvm.bitcast %230 : !llvm.ptr<float> to !llvm.ptr<float>
          %232 = llvm.insertvalue %231, %3[0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %233 = llvm.extractvalue %182[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %234 = llvm.bitcast %233 : !llvm.ptr<float> to !llvm.ptr<float>
          %235 = llvm.insertvalue %234, %232[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %236 = llvm.extractvalue %182[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %237 = llvm.extractvalue %182[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %238 = llvm.extractvalue %182[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %239 = llvm.mul %183, %236 : !llvm.i64
          %240 = llvm.add %238, %239 : !llvm.i64
          %241 = llvm.mul %185, %237 : !llvm.i64
          %242 = llvm.add %240, %241 : !llvm.i64
          %243 = llvm.insertvalue %242, %235[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %244 = llvm.insertvalue %207, %243[3, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %245 = llvm.insertvalue %63, %244[4, 1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %246 = llvm.insertvalue %192, %245[3, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %247 = llvm.insertvalue %82, %246[4, 0] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          llvm.br ^bb13(%6 : !llvm.i64)
        ^bb13(%248: !llvm.i64):  // 2 preds: ^bb12, ^bb18
          %249 = llvm.icmp "slt" %248, %192 : !llvm.i64
          llvm.cond_br %249, ^bb14(%6 : !llvm.i64), ^bb19
        ^bb14(%250: !llvm.i64):  // 2 preds: ^bb13, ^bb17
          %251 = llvm.icmp "slt" %250, %33 : !llvm.i64
          llvm.cond_br %251, ^bb15(%6 : !llvm.i64), ^bb18
        ^bb15(%252: !llvm.i64):  // 2 preds: ^bb14, ^bb16
          %253 = llvm.icmp "slt" %252, %33 : !llvm.i64
          llvm.cond_br %253, ^bb16, ^bb17
        ^bb16:  // pred: ^bb15
          %254 = llvm.extractvalue %211[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %255 = llvm.extractvalue %211[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %256 = llvm.mul %248, %10 : !llvm.i64
          %257 = llvm.add %255, %256 : !llvm.i64
          %258 = llvm.add %257, %252 : !llvm.i64
          %259 = llvm.getelementptr %254[%258] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %260 = llvm.load %259 : !llvm.ptr<float>
          %261 = llvm.extractvalue %229[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %262 = llvm.extractvalue %229[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %263 = llvm.mul %252, %20 : !llvm.i64
          %264 = llvm.add %262, %263 : !llvm.i64
          %265 = llvm.add %264, %250 : !llvm.i64
          %266 = llvm.getelementptr %261[%265] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %267 = llvm.load %266 : !llvm.ptr<float>
          %268 = llvm.extractvalue %247[1] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %269 = llvm.extractvalue %247[2] : !llvm.struct<(ptr<float>, ptr<float>, i64, array<2 x i64>, array<2 x i64>)>
          %270 = llvm.mul %248, %20 : !llvm.i64
          %271 = llvm.add %269, %270 : !llvm.i64
          %272 = llvm.add %271, %250 : !llvm.i64
          %273 = llvm.getelementptr %268[%272] : (!llvm.ptr<float>, !llvm.i64) -> !llvm.ptr<float>
          %274 = llvm.load %273 : !llvm.ptr<float>
          %275 = llvm.fmul %260, %267 : !llvm.float
          %276 = llvm.fadd %274, %275 : !llvm.float
          llvm.store %276, %273 : !llvm.ptr<float>
          %277 = llvm.add %252, %13 : !llvm.i64
          llvm.br ^bb15(%277 : !llvm.i64)
        ^bb17:  // pred: ^bb15
          %278 = llvm.add %250, %13 : !llvm.i64
          llvm.br ^bb14(%278 : !llvm.i64)
        ^bb18:  // pred: ^bb14
          %279 = llvm.add %248, %13 : !llvm.i64
          llvm.br ^bb13(%279 : !llvm.i64)
        ^bb19:  // pred: ^bb13
          %280 = llvm.add %187, %33 : !llvm.i64
          llvm.br ^bb11(%280 : !llvm.i64)
        ^bb20:  // pred: ^bb11
          %281 = llvm.add %185, %33 : !llvm.i64
          llvm.br ^bb10(%281 : !llvm.i64)
        ^bb21:  // pred: ^bb10
          %282 = llvm.add %183, %33 : !llvm.i64
          llvm.br ^bb9(%282 : !llvm.i64)
        ^bb22:  // pred: ^bb9
          %283 = llvm.add %121, %8 : !llvm.i64
          llvm.br ^bb7(%283 : !llvm.i64)
        ^bb23:  // pred: ^bb7
          %284 = llvm.add %119, %8 : !llvm.i64
          llvm.br ^bb6(%284 : !llvm.i64)
        ^bb24:  // pred: ^bb6
          %285 = llvm.add %117, %8 : !llvm.i64
          llvm.br ^bb5(%285 : !llvm.i64)
        ^bb25:  // pred: ^bb5
          llvm.return
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c131072 = constant 131072 : index
    %c262144 = constant 262144 : index
    %c8192 = constant 8192 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set %cmd, %0, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
    %1 = hal.variable.load @_device_match_id_0 : i1
    cond_br %1, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %c1 = constant 1 : index
    %2 = hal.command_buffer.device %cmd : !hal.device
    %3 = hal.variable.load @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.command_buffer.dispatch %cmd, %3, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
    br ^bb3
  ^bb2:  // pred: ^bb0
    iree.unreachable
  ^bb3:  // pred: ^bb1
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After Canonicalizer
```
func private @_device_match_id_0_initializer() -> i1 {
  %dev = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id %dev, pattern = ["dylib*"] : (!hal.device) -> i1
  return %0 : i1
}

```
### IR Dump After CSE
```
func private @_device_match_id_0_initializer() -> i1 {
  %dev = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id %dev, pattern = ["dylib*"] : (!hal.device) -> i1
  return %0 : i1
}

```
### IR Dump After Canonicalizer
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %dev = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
### IR Dump After CSE
```
func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
  %dev = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
### IR Dump After Canonicalizer
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %dev = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
### IR Dump After CSE
```
func private @_executable_layout_0_initializer() -> !hal.executable_layout {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %dev = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
### IR Dump After Canonicalizer
```
func private @_executable_cache_initializer() -> !hal.executable_cache {
  %dev = hal.ex.shared_device : !hal.device
  %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %executable_mhlo-dot_linked_llvm_aot = hal.executable_cache.prepare %executable_cache_default, layout = %1, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @"mhlo-dot_linked_llvm_aot" : !hal.executable
  hal.variable.store %executable_mhlo-dot_linked_llvm_aot, @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
  return %executable_cache_default : !hal.executable_cache
^bb2:  // pred: ^bb0
  iree.unreachable
}

```
### IR Dump After CSE
```
func private @_executable_cache_initializer() -> !hal.executable_cache {
  %dev = hal.ex.shared_device : !hal.device
  %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
  %0 = hal.variable.load @_device_match_id_0 : i1
  cond_br %0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %executable_mhlo-dot_linked_llvm_aot = hal.executable_cache.prepare %executable_cache_default, layout = %1, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @"mhlo-dot_linked_llvm_aot" : !hal.executable
  hal.variable.store %executable_mhlo-dot_linked_llvm_aot, @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
  return %executable_cache_default : !hal.executable_cache
^bb2:  // pred: ^bb0
  iree.unreachable
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::SerializeExecutablesPass
```
hal.executable @"mhlo-dot_linked_llvm_aot" attributes {sym_visibility = "private"} {
  hal.interface @legacy_io_0 {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
  hal.executable.binary attributes {data = opaque<"", "0xDEADBEEF"> : vector<6944xi8>, format = 1145850178 : i32} {
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
  %c0 = constant 0 : index
  %c131072 = constant 131072 : index
  %c262144 = constant 262144 : index
  %c8192 = constant 8192 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set %cmd, %0, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
  %1 = hal.variable.load @_device_match_id_0 : i1
  cond_br %1, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %2 = hal.variable.load @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
  hal.command_buffer.dispatch %cmd, %2, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable
}

```
### IR Dump After CSE
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
  %c0 = constant 0 : index
  %c131072 = constant 131072 : index
  %c262144 = constant 262144 : index
  %c8192 = constant 8192 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  hal.command_buffer.push_descriptor_set %cmd, %0, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
  %1 = hal.variable.load @_device_match_id_0 : i1
  cond_br %1, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %2 = hal.variable.load @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
  hal.command_buffer.dispatch %cmd, %2, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable
}

```
### IR Dump After Canonicalizer
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After Canonicalizer
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After SymbolDCE
```
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %dev = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id %dev, pattern = ["dylib*"] : (!hal.device) -> i1
    return %0 : i1
  }
  hal.variable @"_executable_mhlo-dot_linked_llvm_aot" mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func private @_executable_cache_initializer() -> !hal.executable_cache {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %executable_mhlo-dot_linked_llvm_aot = hal.executable_cache.prepare %executable_cache_default, layout = %1, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @"mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.variable.store %executable_mhlo-dot_linked_llvm_aot, @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
    return %executable_cache_default : !hal.executable_cache
  ^bb2:  // pred: ^bb0
    iree.unreachable
  }
  hal.executable @"mhlo-dot_linked_llvm_aot" attributes {sym_visibility = "private"} {
    hal.interface @legacy_io_0 {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary attributes {data = opaque<"", "0xDEADBEEF"> : vector<6944xi8>, format = 1145850178 : i32} {
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
    %c0 = constant 0 : index
    %c131072 = constant 131072 : index
    %c262144 = constant 262144 : index
    %c8192 = constant 8192 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set %cmd, %0, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
    %1 = hal.variable.load @_device_match_id_0 : i1
    cond_br %1, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %2 = hal.variable.load @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.command_buffer.dispatch %cmd, %2, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After Canonicalizer
```
module  {
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  func private @_device_match_id_0_initializer() -> i1 {
    %dev = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id %dev, pattern = ["dylib*"] : (!hal.device) -> i1
    return %0 : i1
  }
  hal.variable @"_executable_mhlo-dot_linked_llvm_aot" mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func private @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func private @_executable_layout_0_initializer() -> !hal.executable_layout {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func private @_executable_cache_initializer() -> !hal.executable_cache {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    %0 = hal.variable.load @_device_match_id_0 : i1
    cond_br %0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %executable_mhlo-dot_linked_llvm_aot = hal.executable_cache.prepare %executable_cache_default, layout = %1, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @"mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.variable.store %executable_mhlo-dot_linked_llvm_aot, @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
    return %executable_cache_default : !hal.executable_cache
  ^bb2:  // pred: ^bb0
    iree.unreachable
  }
  hal.executable @"mhlo-dot_linked_llvm_aot" attributes {sym_visibility = "private"} {
    hal.interface @legacy_io_0 {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary attributes {data = opaque<"", "0xDEADBEEF"> : vector<6944xi8>, format = 1145850178 : i32} {
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw", noinline} {
    %c0 = constant 0 : index
    %c131072 = constant 131072 : index
    %c262144 = constant 262144 : index
    %c8192 = constant 8192 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %c8192 : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    hal.command_buffer.push_descriptor_set %cmd, %0, set=0, bindings=[0 = (%arg0, %c0, %c131072), 1 = (%arg1, %c0, %c262144), 2 = (%buffer, %c0, %c8192)]
    %1 = hal.variable.load @_device_match_id_0 : i1
    cond_br %1, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %2 = hal.variable.load @"_executable_mhlo-dot_linked_llvm_aot" : !hal.executable
    hal.command_buffer.dispatch %cmd, %2, entry_point = 0, workgroup_xyz = [%c1, %c1, %c1]
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::VM::ConversionPass
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 init(@_device_match_id_0_initializer) : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.func private @_device_match_id_0_initializer() -> i32 {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.return %0 : i32
    }
    vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !vm.ref<!hal.descriptor_set_layout>
    vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c7 = vm.const.i32 7 : i32
      %c1_0 = vm.const.i32 1 : i32
      %c1_1 = vm.const.i32 1 : i32
      %c7_2 = vm.const.i32 7 : i32
      %c1_3 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7_4 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
    }
    vm.global.ref @_executable_layout_0 init(@_executable_layout_0_initializer) : !vm.ref<!hal.executable_layout>
    vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.return %ref_0 : !vm.ref<!hal.executable_layout>
    }
    vm.global.ref @_executable_cache init(@_executable_cache_initializer) : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
    vm.func private @_executable_cache_initializer() -> !vm.ref<!hal.executable_cache> {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_0 = vm.call @hal.executable_cache.create(%ref, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %c1145850178 = vm.const.i32 1145850178 : i32
      %0 = vm.call.variadic @hal.executable_cache.select_format(%ref_0, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %ref_1 = vm.switch.ref %0[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %ref_2 = vm.call @hal.executable_cache.prepare(%ref_0, %_executable_layout_0, %c7, %ref_1) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_2, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.return %ref_0 : !vm.ref<!hal.executable_cache>
    ^bb2:  // pred: ^bb0
      %c2 = vm.const.i32 2 : i32
      vm.fail %c2, "unreachable location reached"
    }
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %zero = vm.const.i32.zero : i32
      %c131072 = vm.const.i32 131072 : i32
      %c262144 = vm.const.i32 262144 : i32
      %c8192 = vm.const.i32 8192 : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %c1_2 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %zero_4 = vm.const.i32.zero : i32
      %zero_5 = vm.const.i32.zero : i32
      %c1_6 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero_4, [%zero_5, %c1_6, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      %zero_7 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mhlo-dot_linked_llvm_aot, %zero_7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      %c2_8 = vm.const.i32 2 : i32
      vm.fail %c2_8, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
      %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ..., %trace_info : !vm.ref<!iree.byte_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::VM::HoistInlinedRodataPass
```
vm.module @module {
  vm.global.i32 @_device_match_id_0 init(@_device_match_id_0_initializer) : i32
  vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
  vm.func private @_device_match_id_0_initializer() -> i32 {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
    vm.return %0 : i32
  }
  vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
  vm.global.ref @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_0 init(@_executable_layout_0_initializer) : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_executable_cache init(@_executable_cache_initializer) : !vm.ref<!hal.executable_cache>
  vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
  vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
  vm.func private @_executable_cache_initializer() -> !vm.ref<!hal.executable_cache> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
    %ref_0 = vm.call @hal.executable_cache.create(%ref, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %c1145850178 = vm.const.i32 1145850178 : i32
    %0 = vm.call.variadic @hal.executable_cache.select_format(%ref_0, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
    %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
    %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
    %ref_1 = vm.switch.ref %0[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
    %c7 = vm.const.i32 7 : i32
    %ref_2 = vm.call @hal.executable_cache.prepare(%ref_0, %_executable_layout_0, %c7, %ref_1) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
    vm.global.store.ref %ref_2, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
    vm.return %ref_0 : !vm.ref<!hal.executable_cache>
  ^bb2:  // pred: ^bb0
    %c2 = vm.const.i32 2 : i32
    vm.fail %c2, "unreachable location reached"
  }
  vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
    %zero = vm.const.i32.zero : i32
    %c131072 = vm.const.i32 131072 : i32
    %c262144 = vm.const.i32 262144 : i32
    %c8192 = vm.const.i32 8192 : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c50 = vm.const.i32 50 : i32
    %c15 = vm.const.i32 15 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c1_2 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %zero_4 = vm.const.i32.zero : i32
    %zero_5 = vm.const.i32.zero : i32
    %c1_6 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero_4, [%zero_5, %c1_6, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
    %zero_7 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mhlo-dot_linked_llvm_aot, %zero_7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %c8 = vm.const.i32 8 : i32
    %c4 = vm.const.i32 4 : i32
    vm.call.variadic @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
    vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  ^bb2:  // pred: ^bb0
    %c2_8 = vm.const.i32 2 : i32
    vm.fail %c2_8, "unreachable location reached"
  }
  vm.export @dot as("dot$raw")
  vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
    %c32 = vm.const.i32 32 : i32
    %c64 = vm.const.i32 64 : i32
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_2 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$async
  vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
    %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$sync as("dot")
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
  vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ..., %trace_info : !vm.ref<!iree.byte_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
}

```
### IR Dump After mlir::iree_compiler::IREE::VM::GlobalInitializationPass
```
vm.module @module {
  vm.global.i32 @_device_match_id_0 mutable : i32
  vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
  vm.func private @_device_match_id_0_initializer() -> i32 {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
    vm.return %0 : i32
  }
  vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
  vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
  vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
  vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
  vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
  vm.func private @_executable_cache_initializer() -> !vm.ref<!hal.executable_cache> {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
    %ref_0 = vm.call @hal.executable_cache.create(%ref, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %c1145850178 = vm.const.i32 1145850178 : i32
    %0 = vm.call.variadic @hal.executable_cache.select_format(%ref_0, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
    %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
    %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
    %ref_1 = vm.switch.ref %0[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
    %c7 = vm.const.i32 7 : i32
    %ref_2 = vm.call @hal.executable_cache.prepare(%ref_0, %_executable_layout_0, %c7, %ref_1) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
    vm.global.store.ref %ref_2, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
    vm.return %ref_0 : !vm.ref<!hal.executable_cache>
  ^bb2:  // pred: ^bb0
    %c2 = vm.const.i32 2 : i32
    vm.fail %c2, "unreachable location reached"
  }
  vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
    %zero = vm.const.i32.zero : i32
    %c131072 = vm.const.i32 131072 : i32
    %c262144 = vm.const.i32 262144 : i32
    %c8192 = vm.const.i32 8192 : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c50 = vm.const.i32 50 : i32
    %c15 = vm.const.i32 15 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c1_2 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %zero_4 = vm.const.i32.zero : i32
    %zero_5 = vm.const.i32.zero : i32
    %c1_6 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero_4, [%zero_5, %c1_6, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
    %zero_7 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_mhlo-dot_linked_llvm_aot, %zero_7, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %c8 = vm.const.i32 8 : i32
    %c4 = vm.const.i32 4 : i32
    vm.call.variadic @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
    vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  ^bb2:  // pred: ^bb0
    %c2_8 = vm.const.i32 2 : i32
    vm.fail %c2_8, "unreachable location reached"
  }
  vm.export @dot as("dot$raw")
  vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
    %c32 = vm.const.i32 32 : i32
    %c64 = vm.const.i32 64 : i32
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_2 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$async
  vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
    %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$sync as("dot")
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
  vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ..., %trace_info : !vm.ref<!iree.byte_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @__init() {
    %0 = vm.call @_device_match_id_0_initializer() : () -> i32
    vm.global.store.i32 %0, @_device_match_id_0 : i32
    %ref = vm.call @_descriptor_set_layout_0_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref_0 = vm.call @_executable_layout_0_initializer() : () -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_0, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_1 = vm.call @_executable_cache_initializer() : () -> !vm.ref<!hal.executable_cache>
    vm.global.store.ref %ref_1, @_executable_cache : !vm.ref<!hal.executable_cache>
    vm.return
  }
  vm.export @__init
}

```
### IR Dump After Canonicalizer
```
vm.func @__init() {
  %0 = vm.call @_device_match_id_0_initializer() : () -> i32
  vm.global.store.i32 %0, @_device_match_id_0 : i32
  %ref = vm.call @_descriptor_set_layout_0_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref_0 = vm.call @_executable_layout_0_initializer() : () -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_0, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %ref_1 = vm.call @_executable_cache_initializer() : () -> !vm.ref<!hal.executable_cache>
  vm.global.store.ref %ref_1, @_executable_cache : !vm.ref<!hal.executable_cache>
  vm.return
}

```
### IR Dump After Canonicalizer
```
vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
  %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
  %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  vm.return %ref_1 : !vm.ref<!hal.buffer_view>
^bb2(%1: i32):  // pred: ^bb0
  vm.fail %1, "semaphore wait failed"
}

```
### IR Dump After Canonicalizer
```
vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
  %c32 = vm.const.i32 32 : i32
  %c64 = vm.const.i32 64 : i32
  %c50331680 = vm.const.i32 50331680 : i32
  %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
  vm.return %ref_2 : !vm.ref<!hal.buffer_view>
^bb2(%1: i32):  // pred: ^bb0
  vm.fail %1, "semaphore wait failed"
}

```
### IR Dump After Canonicalizer
```
vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
  %c131072 = vm.const.i32 131072 : i32
  %c262144 = vm.const.i32 262144 : i32
  %c8192 = vm.const.i32 8192 : i32
  %c50 = vm.const.i32 50 : i32
  %c15 = vm.const.i32 15 : i32
  %c3 = vm.const.i32 3 : i32
  %c1 = vm.const.i32 1 : i32
  %zero = vm.const.i32.zero : i32
  %c20 = vm.const.i32 20 : i32
  %c5 = vm.const.i32 5 : i32
  %c8 = vm.const.i32 8 : i32
  %c4 = vm.const.i32 4 : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
  vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
  vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_mhlo-dot_linked_llvm_aot, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
  vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
  vm.return %ref_1 : !vm.ref<!hal.buffer>
^bb2:  // pred: ^bb0
  vm.fail %c2, "unreachable location reached"
}

```
### IR Dump After Canonicalizer
```
vm.func private @_executable_cache_initializer() -> !vm.ref<!hal.executable_cache> {
  %c1145850178 = vm.const.i32 1145850178 : i32
  %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
  %c7 = vm.const.i32 7 : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
  %ref_0 = vm.call @hal.executable_cache.create(%ref, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %0 = vm.call.variadic @hal.executable_cache.select_format(%ref_0, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
  %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
  %ref_1 = vm.switch.ref %0[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
  %ref_2 = vm.call @hal.executable_cache.prepare(%ref_0, %_executable_layout_0, %c7, %ref_1) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
  vm.global.store.ref %ref_2, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
  vm.return %ref_0 : !vm.ref<!hal.executable_cache>
^bb2:  // pred: ^bb0
  vm.fail %c2, "unreachable location reached"
}

```
### IR Dump After Canonicalizer
```
vm.func private @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> {
  %zero = vm.const.i32.zero : i32
  %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
  vm.return %ref_0 : !vm.ref<!hal.executable_layout>
}

```
### IR Dump After Canonicalizer
```
vm.func private @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %c2 = vm.const.i32 2 : i32
  %c7 = vm.const.i32 7 : i32
  %c6 = vm.const.i32 6 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.return %ref_0 : !vm.ref<!hal.descriptor_set_layout>
}

```
### IR Dump After Canonicalizer
```
vm.func private @_device_match_id_0_initializer() -> i32 {
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
  %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
  vm.return %0 : i32
}

```
### IR Dump After Canonicalizer
```
vm.func @__init() {
  %c1 = vm.const.i32 1 : i32
  %c6 = vm.const.i32 6 : i32
  %zero = vm.const.i32.zero : i32
  %c1145850178 = vm.const.i32 1145850178 : i32
  %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
  %c7 = vm.const.i32 7 : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
  %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
  vm.global.store.i32 %0, @_device_match_id_0 : i32
  %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
  vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
  %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
  vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
  %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
  %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
  %ref_6 = vm.switch.ref %1[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
  %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
  vm.global.store.ref %ref_7, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
  vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
  vm.return
^bb2:  // pred: ^bb0
  vm.fail %c2, "unreachable location reached"
}

```
### IR Dump After Canonicalizer
```
vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %zero = vm.const.i32.zero : i32
  %c1 = vm.const.i32 1 : i32
  %c32 = vm.const.i32 32 : i32
  %c64 = vm.const.i32 64 : i32
  %c50331680 = vm.const.i32 50331680 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
  %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_3 = vm.call @dot(%ref_1, %ref_2) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
  %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
  %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %1, ^bb2(%1 : i32), ^bb3
^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
  vm.fail %2, "semaphore wait failed"
^bb3:  // pred: ^bb1
  vm.return %ref_4 : !vm.ref<!hal.buffer_view>
}

```
### IR Dump After Canonicalizer
```
vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
  %c32 = vm.const.i32 32 : i32
  %c64 = vm.const.i32 64 : i32
  %c50331680 = vm.const.i32 50331680 : i32
  %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
  vm.cond_br %0, ^bb2(%0 : i32), ^bb1
^bb1:  // pred: ^bb0
  %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
  %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
  vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
  vm.return %ref_2 : !vm.ref<!hal.buffer_view>
^bb2(%1: i32):  // pred: ^bb0
  vm.fail %1, "semaphore wait failed"
}

```
### IR Dump After Canonicalizer
```
vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
  %c131072 = vm.const.i32 131072 : i32
  %c262144 = vm.const.i32 262144 : i32
  %c8192 = vm.const.i32 8192 : i32
  %c50 = vm.const.i32 50 : i32
  %c15 = vm.const.i32 15 : i32
  %c3 = vm.const.i32 3 : i32
  %c1 = vm.const.i32 1 : i32
  %zero = vm.const.i32.zero : i32
  %c20 = vm.const.i32 20 : i32
  %c5 = vm.const.i32 5 : i32
  %c8 = vm.const.i32 8 : i32
  %c4 = vm.const.i32 4 : i32
  %c2 = vm.const.i32 2 : i32
  %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
  %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
  %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
  %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
  vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
  vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
  %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
  vm.cond_br %_device_match_id_0, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
  vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_mhlo-dot_linked_llvm_aot, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
  vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
  vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
  vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
  vm.return %ref_1 : !vm.ref<!hal.buffer>
^bb2:  // pred: ^bb0
  vm.fail %c2, "unreachable location reached"
}

```
### IR Dump After Inliner
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c131072 = vm.const.i32 131072 : i32
      %c262144 = vm.const.i32 262144 : i32
      %c8192 = vm.const.i32 8192 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_mhlo-dot_linked_llvm_aot, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @dot(%ref_1, %ref_2) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ..., %trace_info : !vm.ref<!iree.byte_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %c1 = vm.const.i32 1 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c1145850178 = vm.const.i32 1145850178 : i32
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @__init
  }
}

```
### IR Dump After CSE
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c131072 = vm.const.i32 131072 : i32
      %c262144 = vm.const.i32 262144 : i32
      %c8192 = vm.const.i32 8192 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_mhlo-dot_linked_llvm_aot, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @dot(%ref_1, %ref_2) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.wrap.byte_buffer(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %source : !vm.ref<!iree.byte_buffer>, %offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ..., %trace_info : !vm.ref<!iree.byte_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %c1 = vm.const.i32 1 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c1145850178 = vm.const.i32 1145850178 : i32
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @__init
  }
}

```
### IR Dump After SymbolDCE
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %c131072 = vm.const.i32 131072 : i32
      %c262144 = vm.const.i32 262144 : i32
      %c8192 = vm.const.i32 8192 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_mhlo-dot_linked_llvm_aot, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @dot(%ref_1, %ref_2) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %c1 = vm.const.i32 1 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c1145850178 = vm.const.i32 1145850178 : i32
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @__init
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::VM::SinkDefiningOpsPass
```
vm.module @module {
  vm.global.i32 @_device_match_id_0 mutable : i32
  vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
  vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
  vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
  vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
  vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
  vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
  vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c8192 = vm.const.i32 8192 : i32
    %c50 = vm.const.i32 50 : i32
    %c15 = vm.const.i32 15 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    %c3 = vm.const.i32 3 : i32
    %c1 = vm.const.i32 1 : i32
    %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %c131072 = vm.const.i32 131072 : i32
    %c262144 = vm.const.i32 262144 : i32
    %zero = vm.const.i32.zero : i32
    %c2 = vm.const.i32 2 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
    vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_mhlo-dot_linked_llvm_aot, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %c8 = vm.const.i32 8 : i32
    %c4 = vm.const.i32 4 : i32
    vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
    vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  ^bb2:  // pred: ^bb0
    vm.fail %c2, "unreachable location reached"
  }
  vm.export @dot as("dot$raw")
  vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %0, ^bb2(%0 : i32), ^bb1
  ^bb1:  // pred: ^bb0
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %c32 = vm.const.i32 32 : i32
    %c64 = vm.const.i32 64 : i32
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_2 : !vm.ref<!hal.buffer_view>
  ^bb2(%1: i32):  // pred: ^bb0
    vm.fail %1, "semaphore wait failed"
  }
  vm.export @dot$async
  vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %0, ^bb2(%0 : i32), ^bb1
  ^bb1:  // pred: ^bb0
    %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_3 = vm.call @dot(%ref_1, %ref_2) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %c32 = vm.const.i32 32 : i32
    %c64 = vm.const.i32 64 : i32
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
    %c1 = vm.const.i32 1 : i32
    vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
    %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_br %1, ^bb2(%1 : i32), ^bb3
  ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
    vm.fail %2, "semaphore wait failed"
  ^bb3:  // pred: ^bb1
    vm.return %ref_4 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$sync as("dot")
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @__init() {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
    vm.global.store.i32 %0, @_device_match_id_0 : i32
    %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %c6 = vm.const.i32 6 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c2 = vm.const.i32 2 : i32
    %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
    %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %c1145850178 = vm.const.i32 1145850178 : i32
    %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
    %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
    %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
    %ref_6 = vm.switch.ref %1[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
    %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
    vm.global.store.ref %ref_7, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
    vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
    vm.return
  ^bb2:  // pred: ^bb0
    vm.fail %c2, "unreachable location reached"
  }
  vm.export @__init
}

```
### IR Dump After mlir::iree_compiler::IREE::DropCompilerHintsPass
```
module  {
  vm.module @module {
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.rodata @_utf8_dylib_971286B245550E6D dense<[100, 121, 108, 105, 98, 42]> : vector<6xi8>
    vm.global.ref @"_executable_mhlo-dot_linked_llvm_aot" mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" opaque<"", "0xDEADBEEF"> : vector<6944xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> attributes {noinline} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %c8192 = vm.const.i32 8192 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %c8192) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      %c3 = vm.const.i32 3 : i32
      %c1 = vm.const.i32 1 : i32
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %c131072 = vm.const.i32 131072 : i32
      %c262144 = vm.const.i32 262144 : i32
      %zero = vm.const.i32.zero : i32
      %c2 = vm.const.i32 2 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%c131072, %c262144, %c8192]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_mhlo-dot_linked_llvm_aot = vm.global.load.ref @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_mhlo-dot_linked_llvm_aot, %zero, %c1, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    ^bb2(%1: i32):  // pred: ^bb0
      vm.fail %1, "semaphore wait failed"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @dot(%ref_1, %ref_2) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_4 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      %c1 = vm.const.i32 1 : i32
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %1 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %1, ^bb2(%1 : i32), ^bb3
    ^bb2(%2: i32):  // 2 preds: ^bb0, ^bb1
      vm.fail %2, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.return %ref_4 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_dylib_971286B245550E6D = vm.const.ref.rodata @_utf8_dylib_971286B245550E6D : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_dylib_971286B245550E6D) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c1 = vm.const.i32 1 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c7 = vm.const.i32 7 : i32
      %c2 = vm.const.i32 2 : i32
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %c1145850178 = vm.const.i32 1145850178 : i32
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1145850178]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_mhlo-dot_linked_llvm_aot_binary_dylib = vm.const.ref.rodata @"_mhlo-dot_linked_llvm_aot_binary_dylib" : !vm.ref<!iree.byte_buffer>
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_mhlo-dot_linked_llvm_aot_binary_dylib] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @"_executable_mhlo-dot_linked_llvm_aot" : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @__init
  }
}

```