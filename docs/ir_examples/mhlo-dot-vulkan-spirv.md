---
layout: default
permalink: ir-examples/mhlo-dot-vulkan-spirv
title: "mhlo-dot on vulkan-spirv"
parent: IR Conversion Examples
---

# mhlo-dot on vulkan-spirv
{: .no_toc }

This is an IR conversion example auto-generated by running `iree-opt`
over [mhlo-dot](https://github.com/google/iree/tree/main/iree/samples/ops/mhlo-dot.mlir).

### The command

```shell
iree-opt -iree-transformation-pipeline \
  -iree-hal-target-backends=vulkan-spirv \
  --print-ir-after-all \
  -mlir-disable-threading \
  -mlir-elide-elementsattrs-if-larger=8 \
  iree/samples/ops/mhlo-dot.mlir

```
### Input IR

```
func @dot(%lhs: tensor<32x1024xf32>, %rhs: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes { iree.module.export } {
  %0 = "mhlo.dot"(%lhs, %rhs) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}
```
### IR Dump After Canonicalizer
```

module {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::mhlo::{anonymous}::LegalizeControlFlowPass
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::HLOToHLOPreprocessing
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After RemoveShapeConstraints
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ConvertShapeToShapex
```

module {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::FlattenTuplesInCFGPass
```

module {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Inliner
```

module {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::LegalizeInputTypesPass
```

module {
  func @dot(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {iree.module.export} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::MaterializeExportedReflectionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {f_partial = "I12!B9!d32d1024"}}, %arg1: tensor<1024x64xf32> {iree.reflection = {f_partial = "I12!B9!d1024d64"}}) -> (tensor<32x64xf32> {iree.reflection = {f_partial = "R10!B7!d32d64"}}) attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ExpandFunctionDynamicDimsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {f_partial = "I12!B9!d32d1024"}}, %arg1: tensor<1024x64xf32> {iree.reflection = {f_partial = "I12!B9!d1024d64"}}) -> (tensor<32x64xf32> {iree.reflection = {f_partial = "R10!B7!d32d64"}}) attributes {iree.module.export} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::MergeExportedReflectionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::TieDynamicShapesPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::MaterializeShapeCalculationsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::HoistShapeCalculations
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::PrePartitioningConversionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::DispatchabilityAnalysisPass
```

module {
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::IdentifyDispatchRegions2Pass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::FoldCompatibleDispatchRegionsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::RematerializeDispatchConstantsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch.region[%c2048 : index](%arg2 = %arg0 : tensor<32x1024xf32>, %arg3 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = "mhlo.dot"(%arg2, %arg3) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::OutlineDispatchRegionsPass
```

module {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0
    module {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::PostPartitioningConversionPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::{anonymous}::HoistUnstreamableOps
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%c2048 : index](%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After mlir::iree_compiler::IREE::Flow::FormStreamsPass
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After CSE
```
func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
    %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    flow.return %1 : tensor<32x64xf32>
  }
  return %0 : tensor<32x64xf32>
}

```
### IR Dump After SymbolDCE
```

module {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0
    module {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Canonicalizer
```

module {
  flow.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    flow.dispatch.entry @dot_ex_dispatch_0
    module {
      func @dot_ex_dispatch_0(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> {
        %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
        return %0 : tensor<32x64xf32>
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeInterfacesPass
```

module {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vulkan_spirv, filter="vulkan*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>} {
        func @dot_ex_dispatch_0() {
          %c0 = constant 0 : index
          %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
          %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
          %2 = call @dot_ex_dispatch_0_impl(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
          hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
          return
        }
        func @dot_ex_dispatch_0_impl(%arg0: tensor<32x1024xf32>, %arg1: tensor<1024x64xf32>) -> tensor<32x64xf32> attributes {sym_visibility = "private"} {
          %0 = "mhlo.dot"(%arg0, %arg1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
          return %0 : tensor<32x64xf32>
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After Inliner
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>} {
  func @dot_ex_dispatch_0() {
    %c0 = constant 0 : index
    %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
    %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
    %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::TieDynamicShapesPass
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::MaterializeShapeCalculationsPass
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::HoistShapeCalculations
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::DecomposeHLOClampPass
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertHLOToLinalgOnTensorsPass
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
  return
}

```
### IR Dump After LinalgFoldUnitExtentDims
```
func @dot_ex_dispatch_0() {
  %c0 = constant 0 : index
  %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
  %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
  %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
  hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
  return
}

```
### IR Dump After Canonicalizer
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>} {
  func @dot_ex_dispatch_0() {
    %c0 = constant 0 : index
    %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
    %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
    %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::FusionOfTensorOpsPass
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>} {
  func @dot_ex_dispatch_0() {
    %c0 = constant 0 : index
    %0 = hal.interface.load.tensor @legacy_io::@arg0, offset = %c0 : tensor<32x1024xf32>
    %1 = hal.interface.load.tensor @legacy_io::@arg1, offset = %c0 : tensor<1024x64xf32>
    %2 = "mhlo.dot"(%0, %1) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
    hal.interface.store.tensor %2, @legacy_io::@ret0, offset = %c0 : tensor<32x64xf32>
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertHLOToLinalgOnBuffersPass
```
func @dot_ex_dispatch_0() {
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  %c0 = constant 0 : index
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
  %cst = constant 0.000000e+00 : f32
  linalg.fill(%0, %cst) : memref<32x64xf32>, f32
  linalg.matmul  %1, %2, %0 : (memref<32x1024xf32>, memref<1024x64xf32>, memref<32x64xf32>)
  return
}

```
### IR Dump After Canonicalizer
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>} {
  func @dot_ex_dispatch_0() {
    %cst = constant 0.000000e+00 : f32
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    linalg.fill(%0, %cst) : memref<32x64xf32>, f32
    linalg.matmul  %1, %2, %0 : (memref<32x1024xf32>, memref<1024x64xf32>, memref<32x64xf32>)
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After CSE
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>} {
  func @dot_ex_dispatch_0() {
    %cst = constant 0.000000e+00 : f32
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    linalg.fill(%0, %cst) : memref<32x64xf32>, f32
    linalg.matmul  %1, %2, %0 : (memref<32x1024xf32>, memref<1024x64xf32>, memref<32x64xf32>)
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::LinalgTileAndFusePass
```
func @dot_ex_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
  %cst = constant 0.000000e+00 : f32
  %c0 = constant 0 : index
  %c4 = constant 4 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c8 = constant 8 : index
  %c64 = constant 64 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
  linalg.fill(%0, %cst) : memref<32x64xf32>, f32
  %3 = "gpu.block_id"() {dimension = "x"} : () -> index
  %4 = "gpu.block_id"() {dimension = "y"} : () -> index
  scf.for %arg0 = %c0 to %c1024 step %c4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
    %6 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c32, %5)
    %7 = affine.min affine_map<(d0, d1, d2) -> (4, d1 - d2)>(%c4, %c1024, %arg0)
    %8 = subview %1[%5, %arg0] [%6, %7] [%c1, %c1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
    %9 = affine.min affine_map<(d0, d1, d2) -> (4, d1 - d2)>(%c4, %c1024, %arg0)
    %10 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
    %11 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c64, %10)
    %12 = subview %2[%arg0, %10] [%9, %11] [%c1, %c1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
    %13 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
    %14 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c32, %13)
    %15 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
    %16 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c64, %15)
    %17 = subview %0[%13, %15] [%14, %16] [%c1, %c1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
    linalg.matmul  {__internal_linalg_transform__ = "workgroup_numprocs_ge_numiters"} %8, %12, %17 : (memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>, memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>, memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>)
  }
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::SplitDispatchFunctionPass
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c0 = constant 0 : index
    %c4 = constant 4 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c8 = constant 8 : index
    %c64 = constant 64 : index
    %c1 = constant 1 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
      %6 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c32, %5)
      %7 = affine.min affine_map<(d0, d1, d2) -> (4, d1 - d2)>(%c4, %c1024, %arg0)
      %8 = subview %1[%5, %arg0] [%6, %7] [%c1, %c1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
      %9 = affine.min affine_map<(d0, d1, d2) -> (4, d1 - d2)>(%c4, %c1024, %arg0)
      %10 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
      %11 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c64, %10)
      %12 = subview %2[%arg0, %10] [%9, %11] [%c1, %c1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
      %13 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
      %14 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c32, %13)
      %15 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
      %16 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c64, %15)
      %17 = subview %0[%13, %15] [%14, %16] [%c1, %c1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
      linalg.matmul  {__internal_linalg_transform__ = "workgroup_numprocs_ge_numiters"} %8, %12, %17 : (memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>, memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>, memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>)
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %cst = constant 0.000000e+00 : f32
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    linalg.fill(%0, %cst) : memref<32x64xf32>, f32
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::LinalgTileAndFusePass
```
func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
  %c0 = constant 0 : index
  %c4 = constant 4 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c8 = constant 8 : index
  %c64 = constant 64 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
  %3 = "gpu.block_id"() {dimension = "x"} : () -> index
  %4 = "gpu.block_id"() {dimension = "y"} : () -> index
  scf.for %arg0 = %c0 to %c1024 step %c4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
    %6 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c32, %5)
    %7 = affine.min affine_map<(d0, d1, d2) -> (4, d1 - d2)>(%c4, %c1024, %arg0)
    %8 = subview %1[%5, %arg0] [%6, %7] [%c1, %c1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
    %9 = affine.min affine_map<(d0, d1, d2) -> (4, d1 - d2)>(%c4, %c1024, %arg0)
    %10 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
    %11 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c64, %10)
    %12 = subview %2[%arg0, %10] [%9, %11] [%c1, %c1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
    %13 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
    %14 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c32, %13)
    %15 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
    %16 = affine.min affine_map<(d0, d1, d2) -> (8, d1 - d2)>(%c8, %c64, %15)
    %17 = subview %0[%13, %15] [%14, %16] [%c1, %c1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>
    linalg.matmul  {__internal_linalg_transform__ = "workgroup_numprocs_ge_numiters"} %8, %12, %17 : (memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>, memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>, memref<?x?xf32, affine_map<(d0, d1)[s0, s1, s2] -> (d0 * s1 + s0 + d1 * s2)>>)
  }
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::LinalgTileAndFusePass
```
func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
  %cst = constant 0.000000e+00 : f32
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  linalg.fill(%0, %cst) : memref<32x64xf32>, f32
  return
}

```
### IR Dump After Canonicalizer
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c0 = constant 0 : index
    %c4 = constant 4 : index
    %c1024 = constant 1024 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %5 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
      %6 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 32)>()[%4]
      %7 = affine.min affine_map<(d0) -> (4, -d0 + 1024)>(%arg0)
      %8 = subview %1[%5, %arg0] [%6, %7] [1, 1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %9 = affine.min affine_map<(d0) -> (4, -d0 + 1024)>(%arg0)
      %10 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
      %11 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 64)>()[%3]
      %12 = subview %2[%arg0, %10] [%9, %11] [1, 1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %13 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
      %14 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 32)>()[%4]
      %15 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
      %16 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 64)>()[%3]
      %17 = subview %0[%13, %15] [%14, %16] [1, 1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      linalg.matmul  {__internal_linalg_transform__ = "workgroup_numprocs_ge_numiters"} %8, %12, %17 : (memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>, memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>)
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %cst = constant 0.000000e+00 : f32
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    linalg.fill(%0, %cst) : memref<32x64xf32>, f32
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertToGPUPass
```
func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
  %c0 = constant 0 : index
  %c4 = constant 4 : index
  %c1024 = constant 1024 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
  %3 = "gpu.block_id"() {dimension = "x"} : () -> index
  %4 = "gpu.block_id"() {dimension = "y"} : () -> index
  scf.for %arg0 = %c0 to %c1024 step %c4 {
    %5 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
    %6 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 32)>()[%4]
    %7 = affine.min affine_map<(d0) -> (4, -d0 + 1024)>(%arg0)
    %8 = subview %1[%5, %arg0] [%6, %7] [1, 1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %9 = affine.min affine_map<(d0) -> (4, -d0 + 1024)>(%arg0)
    %10 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
    %11 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 64)>()[%3]
    %12 = subview %2[%arg0, %10] [%9, %11] [1, 1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %13 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%4]
    %14 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 32)>()[%4]
    %15 = affine.apply affine_map<()[s0] -> (s0 * 8)>()[%3]
    %16 = affine.min affine_map<()[s0] -> (8, s0 * -8 + 64)>()[%3]
    %17 = subview %0[%13, %15] [%14, %16] [1, 1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c0_0 = constant 0 : index
    %18 = dim %8, %c0_0 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %c1 = constant 1 : index
    %19 = dim %8, %c1 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %c0_1 = constant 0 : index
    %20 = dim %12, %c0_1 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c1_2 = constant 1 : index
    %21 = dim %12, %c1_2 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c0_3 = constant 0 : index
    %22 = dim %17, %c0_3 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c1_4 = constant 1 : index
    %23 = dim %17, %c1_4 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c0_5 = constant 0 : index
    %24 = dim %8, %c0_5 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %c1_6 = constant 1 : index
    %25 = dim %8, %c1_6 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %c0_7 = constant 0 : index
    %26 = dim %12, %c0_7 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c1_8 = constant 1 : index
    %27 = dim %12, %c1_8 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c0_9 = constant 0 : index
    %28 = dim %17, %c0_9 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c1_10 = constant 1 : index
    %29 = dim %17, %c1_10 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %c0_11 = constant 0 : index
    %c1_12 = constant 1 : index
    %c0_13 = constant 0 : index
    %c1_14 = constant 1 : index
    %c0_15 = constant 0 : index
    %c1_16 = constant 1 : index
    %30 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %31 = "gpu.block_dim"() {dimension = "x"} : () -> index
    %32 = "gpu.thread_id"() {dimension = "y"} : () -> index
    %33 = "gpu.block_dim"() {dimension = "y"} : () -> index
    %34 = muli %32, %c1_12 : index
    %35 = addi %c0_11, %34 : index
    %36 = muli %30, %c1_16 : index
    %37 = addi %c0_15, %36 : index
    %38 = cmpi "slt", %35, %24 : index
    %39 = cmpi "slt", %37, %27 : index
    %40 = and %38, %39 : i1
    scf.if %40 {
      scf.for %arg1 = %c0_13 to %25 step %c1_14 {
        %41 = affine.apply affine_map<(d0) -> (d0)>(%35)
        %42 = affine.apply affine_map<(d0) -> (d0)>(%arg1)
        %43 = load %8[%41, %42] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
        %44 = affine.apply affine_map<(d0) -> (d0)>(%arg1)
        %45 = affine.apply affine_map<(d0) -> (d0)>(%37)
        %46 = load %12[%44, %45] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %47 = affine.apply affine_map<(d0) -> (d0)>(%35)
        %48 = affine.apply affine_map<(d0) -> (d0)>(%37)
        %49 = load %17[%47, %48] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %50 = affine.apply affine_map<(d0) -> (d0)>(%35)
        %51 = affine.apply affine_map<(d0) -> (d0)>(%37)
        %52 = mulf %43, %46 : f32
        %53 = addf %49, %52 : f32
        store %53, %17[%50, %51] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      }
    }
  }
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertToGPUPass
```
func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
  %cst = constant 0.000000e+00 : f32
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  %c0 = constant 0 : index
  %1 = dim %0, %c0 : memref<32x64xf32>
  %c1 = constant 1 : index
  %2 = dim %0, %c1 : memref<32x64xf32>
  %c0_0 = constant 0 : index
  %3 = dim %0, %c0_0 : memref<32x64xf32>
  %c1_1 = constant 1 : index
  %4 = dim %0, %c1_1 : memref<32x64xf32>
  %c0_2 = constant 0 : index
  %c1_3 = constant 1 : index
  %c0_4 = constant 0 : index
  %c1_5 = constant 1 : index
  %c1_6 = constant 1 : index
  %5 = subi %4, %c0_4 : index
  %6 = divi_signed %5, %c1_5 : index
  %7 = muli %c1_6, %6 : index
  %8 = subi %3, %c0_2 : index
  %9 = divi_signed %8, %c1_3 : index
  %10 = muli %7, %9 : index
  %c0_7 = constant 0 : index
  %c1_8 = constant 1 : index
  %11 = "gpu.grid_dim"() {dimension = "x"} : () -> index
  %12 = "gpu.block_id"() {dimension = "x"} : () -> index
  %13 = "gpu.block_dim"() {dimension = "x"} : () -> index
  %14 = "gpu.thread_id"() {dimension = "x"} : () -> index
  %15 = muli %12, %13 : index
  %16 = addi %15, %14 : index
  %17 = muli %13, %11 : index
  %18 = muli %16, %c1_8 : index
  %19 = addi %c0_7, %18 : index
  %20 = cmpi "slt", %19, %10 : index
  scf.if %20 {
    %21 = divi_signed %19, %7 : index
    %22 = affine.apply affine_map<(d0) -> (d0)>(%21)
    %23 = affine.apply affine_map<(d0) -> (d0)>(%21)
    %24 = remi_signed %19, %7 : index
    %25 = divi_signed %24, %c1_6 : index
    %26 = affine.apply affine_map<(d0) -> (d0)>(%25)
    %27 = affine.apply affine_map<(d0) -> (d0)>(%25)
    %28 = remi_signed %24, %c1_6 : index
    store %cst, %0[%23, %27] : memref<32x64xf32>
  }
  return
}

```
### IR Dump After ConvertAffineToStandard
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c0 = constant 0 : index
    %c4 = constant 4 : index
    %c1024 = constant 1024 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %c8 = constant 8 : index
      %5 = muli %4, %c8 : index
      %c8_0 = constant 8 : index
      %c-8 = constant -8 : index
      %6 = muli %4, %c-8 : index
      %c32 = constant 32 : index
      %7 = addi %6, %c32 : index
      %8 = cmpi "slt", %c8_0, %7 : index
      %9 = select %8, %c8_0, %7 : index
      %c4_1 = constant 4 : index
      %c-1 = constant -1 : index
      %10 = muli %arg0, %c-1 : index
      %c1024_2 = constant 1024 : index
      %11 = addi %10, %c1024_2 : index
      %12 = cmpi "slt", %c4_1, %11 : index
      %13 = select %12, %c4_1, %11 : index
      %14 = subview %1[%5, %arg0] [%9, %13] [1, 1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %c4_3 = constant 4 : index
      %c-1_4 = constant -1 : index
      %15 = muli %arg0, %c-1_4 : index
      %c1024_5 = constant 1024 : index
      %16 = addi %15, %c1024_5 : index
      %17 = cmpi "slt", %c4_3, %16 : index
      %18 = select %17, %c4_3, %16 : index
      %c8_6 = constant 8 : index
      %19 = muli %3, %c8_6 : index
      %c8_7 = constant 8 : index
      %c-8_8 = constant -8 : index
      %20 = muli %3, %c-8_8 : index
      %c64 = constant 64 : index
      %21 = addi %20, %c64 : index
      %22 = cmpi "slt", %c8_7, %21 : index
      %23 = select %22, %c8_7, %21 : index
      %24 = subview %2[%arg0, %19] [%18, %23] [1, 1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c8_9 = constant 8 : index
      %25 = muli %4, %c8_9 : index
      %c8_10 = constant 8 : index
      %c-8_11 = constant -8 : index
      %26 = muli %4, %c-8_11 : index
      %c32_12 = constant 32 : index
      %27 = addi %26, %c32_12 : index
      %28 = cmpi "slt", %c8_10, %27 : index
      %29 = select %28, %c8_10, %27 : index
      %c8_13 = constant 8 : index
      %30 = muli %3, %c8_13 : index
      %c8_14 = constant 8 : index
      %c-8_15 = constant -8 : index
      %31 = muli %3, %c-8_15 : index
      %c64_16 = constant 64 : index
      %32 = addi %31, %c64_16 : index
      %33 = cmpi "slt", %c8_14, %32 : index
      %34 = select %33, %c8_14, %32 : index
      %35 = subview %0[%25, %30] [%29, %34] [1, 1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c0_17 = constant 0 : index
      %36 = dim %14, %c0_17 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %c1 = constant 1 : index
      %37 = dim %14, %c1 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %c0_18 = constant 0 : index
      %38 = dim %24, %c0_18 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c1_19 = constant 1 : index
      %39 = dim %24, %c1_19 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c0_20 = constant 0 : index
      %40 = dim %35, %c0_20 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c1_21 = constant 1 : index
      %41 = dim %35, %c1_21 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c0_22 = constant 0 : index
      %42 = dim %14, %c0_22 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %c1_23 = constant 1 : index
      %43 = dim %14, %c1_23 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %c0_24 = constant 0 : index
      %44 = dim %24, %c0_24 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c1_25 = constant 1 : index
      %45 = dim %24, %c1_25 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c0_26 = constant 0 : index
      %46 = dim %35, %c0_26 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c1_27 = constant 1 : index
      %47 = dim %35, %c1_27 : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %c0_28 = constant 0 : index
      %c1_29 = constant 1 : index
      %c0_30 = constant 0 : index
      %c1_31 = constant 1 : index
      %c0_32 = constant 0 : index
      %c1_33 = constant 1 : index
      %48 = "gpu.thread_id"() {dimension = "x"} : () -> index
      %49 = "gpu.block_dim"() {dimension = "x"} : () -> index
      %50 = "gpu.thread_id"() {dimension = "y"} : () -> index
      %51 = "gpu.block_dim"() {dimension = "y"} : () -> index
      %52 = muli %50, %c1_29 : index
      %53 = addi %c0_28, %52 : index
      %54 = muli %48, %c1_33 : index
      %55 = addi %c0_32, %54 : index
      %56 = cmpi "slt", %53, %42 : index
      %57 = cmpi "slt", %55, %45 : index
      %58 = and %56, %57 : i1
      scf.if %58 {
        scf.for %arg1 = %c0_30 to %43 step %c1_31 {
          %59 = load %14[%53, %arg1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
          %60 = load %24[%arg1, %55] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
          %61 = load %35[%53, %55] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
          %62 = mulf %59, %60 : f32
          %63 = addf %61, %62 : f32
          store %63, %35[%53, %55] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        }
      }
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %cst = constant 0.000000e+00 : f32
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %c0 = constant 0 : index
    %1 = dim %0, %c0 : memref<32x64xf32>
    %c1 = constant 1 : index
    %2 = dim %0, %c1 : memref<32x64xf32>
    %c0_0 = constant 0 : index
    %3 = dim %0, %c0_0 : memref<32x64xf32>
    %c1_1 = constant 1 : index
    %4 = dim %0, %c1_1 : memref<32x64xf32>
    %c0_2 = constant 0 : index
    %c1_3 = constant 1 : index
    %c0_4 = constant 0 : index
    %c1_5 = constant 1 : index
    %c1_6 = constant 1 : index
    %5 = subi %4, %c0_4 : index
    %6 = divi_signed %5, %c1_5 : index
    %7 = muli %c1_6, %6 : index
    %8 = subi %3, %c0_2 : index
    %9 = divi_signed %8, %c1_3 : index
    %10 = muli %7, %9 : index
    %c0_7 = constant 0 : index
    %c1_8 = constant 1 : index
    %11 = "gpu.grid_dim"() {dimension = "x"} : () -> index
    %12 = "gpu.block_id"() {dimension = "x"} : () -> index
    %13 = "gpu.block_dim"() {dimension = "x"} : () -> index
    %14 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %15 = muli %12, %13 : index
    %16 = addi %15, %14 : index
    %17 = muli %13, %11 : index
    %18 = muli %16, %c1_8 : index
    %19 = addi %c0_7, %18 : index
    %20 = cmpi "slt", %19, %10 : index
    scf.if %20 {
      %21 = divi_signed %19, %7 : index
      %22 = remi_signed %19, %7 : index
      %23 = divi_signed %22, %c1_6 : index
      %24 = remi_signed %22, %c1_6 : index
      store %cst, %0[%21, %23] : memref<32x64xf32>
    }
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After Canonicalizer
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c4 = constant 4 : index
    %c-1 = constant -1 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c8 = constant 8 : index
    %c-8 = constant -8 : index
    %c64 = constant 64 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %5 = muli %4, %c8 : index
      %6 = muli %4, %c-8 : index
      %7 = addi %6, %c32 : index
      %8 = cmpi "slt", %c8, %7 : index
      %9 = select %8, %c8, %7 : index
      %10 = muli %arg0, %c-1 : index
      %11 = addi %10, %c1024 : index
      %12 = cmpi "slt", %c4, %11 : index
      %13 = select %12, %c4, %11 : index
      %14 = subview %1[%5, %arg0] [%9, %13] [1, 1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %15 = muli %arg0, %c-1 : index
      %16 = addi %15, %c1024 : index
      %17 = cmpi "slt", %c4, %16 : index
      %18 = select %17, %c4, %16 : index
      %19 = muli %3, %c8 : index
      %20 = muli %3, %c-8 : index
      %21 = addi %20, %c64 : index
      %22 = cmpi "slt", %c8, %21 : index
      %23 = select %22, %c8, %21 : index
      %24 = subview %2[%arg0, %19] [%18, %23] [1, 1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %25 = muli %4, %c8 : index
      %26 = muli %4, %c-8 : index
      %27 = addi %26, %c32 : index
      %28 = cmpi "slt", %c8, %27 : index
      %29 = select %28, %c8, %27 : index
      %30 = muli %3, %c8 : index
      %31 = muli %3, %c-8 : index
      %32 = addi %31, %c64 : index
      %33 = cmpi "slt", %c8, %32 : index
      %34 = select %33, %c8, %32 : index
      %35 = subview %0[%25, %30] [%29, %34] [1, 1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %36 = "gpu.thread_id"() {dimension = "x"} : () -> index
      %37 = "gpu.thread_id"() {dimension = "y"} : () -> index
      %38 = cmpi "slt", %37, %9 : index
      %39 = cmpi "slt", %36, %23 : index
      %40 = and %38, %39 : i1
      scf.if %40 {
        scf.for %arg1 = %c0 to %13 step %c1 {
          %41 = load %14[%37, %arg1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
          %42 = load %24[%arg1, %36] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
          %43 = load %35[%37, %36] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
          %44 = mulf %41, %42 : f32
          %45 = addf %43, %44 : f32
          store %45, %35[%37, %36] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        }
      }
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %cst = constant 0.000000e+00 : f32
    %c2048 = constant 2048 : index
    %c64 = constant 64 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = "gpu.block_id"() {dimension = "x"} : () -> index
    %2 = "gpu.block_dim"() {dimension = "x"} : () -> index
    %3 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %4 = muli %1, %2 : index
    %5 = addi %4, %3 : index
    %6 = cmpi "slt", %5, %c2048 : index
    scf.if %6 {
      %7 = divi_signed %5, %c64 : index
      %8 = remi_signed %5, %c64 : index
      store %cst, %0[%7, %8] : memref<32x64xf32>
    }
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After CSE
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c4 = constant 4 : index
    %c-1 = constant -1 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c8 = constant 8 : index
    %c-8 = constant -8 : index
    %c64 = constant 64 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %5 = muli %4, %c8 : index
      %6 = muli %4, %c-8 : index
      %7 = addi %6, %c32 : index
      %8 = cmpi "slt", %c8, %7 : index
      %9 = select %8, %c8, %7 : index
      %10 = muli %arg0, %c-1 : index
      %11 = addi %10, %c1024 : index
      %12 = cmpi "slt", %c4, %11 : index
      %13 = select %12, %c4, %11 : index
      %14 = subview %1[%5, %arg0] [%9, %13] [1, 1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
      %15 = muli %3, %c8 : index
      %16 = muli %3, %c-8 : index
      %17 = addi %16, %c64 : index
      %18 = cmpi "slt", %c8, %17 : index
      %19 = select %18, %c8, %17 : index
      %20 = subview %2[%arg0, %15] [%13, %19] [1, 1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %21 = subview %0[%5, %15] [%9, %19] [1, 1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      %22 = "gpu.thread_id"() {dimension = "x"} : () -> index
      %23 = "gpu.thread_id"() {dimension = "y"} : () -> index
      %24 = cmpi "slt", %23, %9 : index
      %25 = cmpi "slt", %22, %19 : index
      %26 = and %24, %25 : i1
      scf.if %26 {
        scf.for %arg1 = %c0 to %13 step %c1 {
          %27 = load %14[%23, %arg1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
          %28 = load %20[%arg1, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
          %29 = load %21[%23, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
          %30 = mulf %27, %28 : f32
          %31 = addf %29, %30 : f32
          store %31, %21[%23, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        }
      }
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %cst = constant 0.000000e+00 : f32
    %c2048 = constant 2048 : index
    %c64 = constant 64 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = "gpu.block_id"() {dimension = "x"} : () -> index
    %2 = "gpu.block_dim"() {dimension = "x"} : () -> index
    %3 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %4 = muli %1, %2 : index
    %5 = addi %4, %3 : index
    %6 = cmpi "slt", %5, %c2048 : index
    scf.if %6 {
      %7 = divi_signed %5, %c64 : index
      %8 = remi_signed %5, %c64 : index
      store %cst, %0[%7, %8] : memref<32x64xf32>
    }
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ResolveShapeOpsPass
```
func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
  %c4 = constant 4 : index
  %c-1 = constant -1 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c8 = constant 8 : index
  %c-8 = constant -8 : index
  %c64 = constant 64 : index
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
  %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
  %3 = "gpu.block_id"() {dimension = "x"} : () -> index
  %4 = "gpu.block_id"() {dimension = "y"} : () -> index
  scf.for %arg0 = %c0 to %c1024 step %c4 {
    %5 = muli %4, %c8 : index
    %6 = muli %4, %c-8 : index
    %7 = addi %6, %c32 : index
    %8 = cmpi "slt", %c8, %7 : index
    %9 = select %8, %c8, %7 : index
    %10 = muli %arg0, %c-1 : index
    %11 = addi %10, %c1024 : index
    %12 = cmpi "slt", %c4, %11 : index
    %13 = select %12, %c4, %11 : index
    %14 = subview %1[%5, %arg0] [%9, %13] [1, 1]  : memref<32x1024xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
    %15 = muli %3, %c8 : index
    %16 = muli %3, %c-8 : index
    %17 = addi %16, %c64 : index
    %18 = cmpi "slt", %c8, %17 : index
    %19 = select %18, %c8, %17 : index
    %20 = subview %2[%arg0, %15] [%13, %19] [1, 1]  : memref<1024x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %21 = subview %0[%5, %15] [%9, %19] [1, 1]  : memref<32x64xf32> to memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
    %22 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %23 = "gpu.thread_id"() {dimension = "y"} : () -> index
    %24 = cmpi "slt", %23, %9 : index
    %25 = cmpi "slt", %22, %19 : index
    %26 = and %24, %25 : i1
    scf.if %26 {
      scf.for %arg1 = %c0 to %13 step %c1 {
        %27 = load %14[%23, %arg1] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 1024 + s0 + d1)>>
        %28 = load %20[%arg1, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %29 = load %21[%23, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
        %30 = mulf %27, %28 : f32
        %31 = addf %29, %30 : f32
        store %31, %21[%23, %22] : memref<?x?xf32, affine_map<(d0, d1)[s0] -> (d0 * 64 + s0 + d1)>>
      }
    }
  }
  return
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ResolveShapeOpsPass
```
func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
  %cst = constant 0.000000e+00 : f32
  %c2048 = constant 2048 : index
  %c64 = constant 64 : index
  %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
  %1 = "gpu.block_id"() {dimension = "x"} : () -> index
  %2 = "gpu.block_dim"() {dimension = "x"} : () -> index
  %3 = "gpu.thread_id"() {dimension = "x"} : () -> index
  %4 = muli %1, %2 : index
  %5 = addi %4, %3 : index
  %6 = cmpi "slt", %5, %c2048 : index
  scf.if %6 {
    %7 = divi_signed %5, %c64 : index
    %8 = remi_signed %5, %c64 : index
    store %cst, %0[%7, %8] : memref<32x64xf32>
  }
  return
}

```
### IR Dump After LegalizeStandardForSPIRV
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c4 = constant 4 : index
    %c-1 = constant -1 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c8 = constant 8 : index
    %c-8 = constant -8 : index
    %c64 = constant 64 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %5 = muli %4, %c8 : index
      %6 = muli %4, %c-8 : index
      %7 = addi %6, %c32 : index
      %8 = cmpi "slt", %c8, %7 : index
      %9 = select %8, %c8, %7 : index
      %10 = muli %arg0, %c-1 : index
      %11 = addi %10, %c1024 : index
      %12 = cmpi "slt", %c4, %11 : index
      %13 = select %12, %c4, %11 : index
      %14 = muli %3, %c8 : index
      %15 = muli %3, %c-8 : index
      %16 = addi %15, %c64 : index
      %17 = cmpi "slt", %c8, %16 : index
      %18 = select %17, %c8, %16 : index
      %19 = "gpu.thread_id"() {dimension = "x"} : () -> index
      %20 = "gpu.thread_id"() {dimension = "y"} : () -> index
      %21 = cmpi "slt", %20, %9 : index
      %22 = cmpi "slt", %19, %18 : index
      %23 = and %21, %22 : i1
      scf.if %23 {
        scf.for %arg1 = %c0 to %13 step %c1 {
          %24 = addi %5, %20 : index
          %25 = addi %arg0, %arg1 : index
          %26 = load %1[%24, %25] : memref<32x1024xf32>
          %27 = addi %arg0, %arg1 : index
          %28 = addi %14, %19 : index
          %29 = load %2[%27, %28] : memref<1024x64xf32>
          %30 = addi %5, %20 : index
          %31 = addi %14, %19 : index
          %32 = load %0[%30, %31] : memref<32x64xf32>
          %33 = mulf %26, %29 : f32
          %34 = addf %32, %33 : f32
          %35 = addi %5, %20 : index
          %36 = addi %14, %19 : index
          store %34, %0[%35, %36] : memref<32x64xf32>
        }
      }
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %cst = constant 0.000000e+00 : f32
    %c2048 = constant 2048 : index
    %c64 = constant 64 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = "gpu.block_id"() {dimension = "x"} : () -> index
    %2 = "gpu.block_dim"() {dimension = "x"} : () -> index
    %3 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %4 = muli %1, %2 : index
    %5 = addi %4, %3 : index
    %6 = cmpi "slt", %5, %c2048 : index
    scf.if %6 {
      %7 = divi_signed %5, %c64 : index
      %8 = remi_signed %5, %c64 : index
      store %cst, %0[%7, %8] : memref<32x64xf32>
    }
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After Canonicalizer
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c4 = constant 4 : index
    %c-1 = constant -1 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c8 = constant 8 : index
    %c-8 = constant -8 : index
    %c64 = constant 64 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %5 = muli %4, %c8 : index
      %6 = muli %4, %c-8 : index
      %7 = addi %6, %c32 : index
      %8 = cmpi "slt", %c8, %7 : index
      %9 = select %8, %c8, %7 : index
      %10 = muli %arg0, %c-1 : index
      %11 = addi %10, %c1024 : index
      %12 = cmpi "slt", %c4, %11 : index
      %13 = select %12, %c4, %11 : index
      %14 = muli %3, %c8 : index
      %15 = muli %3, %c-8 : index
      %16 = addi %15, %c64 : index
      %17 = cmpi "slt", %c8, %16 : index
      %18 = select %17, %c8, %16 : index
      %19 = "gpu.thread_id"() {dimension = "x"} : () -> index
      %20 = "gpu.thread_id"() {dimension = "y"} : () -> index
      %21 = cmpi "slt", %20, %9 : index
      %22 = cmpi "slt", %19, %18 : index
      %23 = and %21, %22 : i1
      scf.if %23 {
        scf.for %arg1 = %c0 to %13 step %c1 {
          %24 = addi %5, %20 : index
          %25 = addi %arg0, %arg1 : index
          %26 = load %1[%24, %25] : memref<32x1024xf32>
          %27 = addi %arg0, %arg1 : index
          %28 = addi %14, %19 : index
          %29 = load %2[%27, %28] : memref<1024x64xf32>
          %30 = addi %5, %20 : index
          %31 = addi %14, %19 : index
          %32 = load %0[%30, %31] : memref<32x64xf32>
          %33 = mulf %26, %29 : f32
          %34 = addf %32, %33 : f32
          %35 = addi %5, %20 : index
          %36 = addi %14, %19 : index
          store %34, %0[%35, %36] : memref<32x64xf32>
        }
      }
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %cst = constant 0.000000e+00 : f32
    %c2048 = constant 2048 : index
    %c64 = constant 64 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = "gpu.block_id"() {dimension = "x"} : () -> index
    %2 = "gpu.block_dim"() {dimension = "x"} : () -> index
    %3 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %4 = muli %1, %2 : index
    %5 = addi %4, %3 : index
    %6 = cmpi "slt", %5, %c2048 : index
    scf.if %6 {
      %7 = divi_signed %5, %c64 : index
      %8 = remi_signed %5, %c64 : index
      store %cst, %0[%7, %8] : memref<32x64xf32>
    }
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After CSE
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  func @dot_ex_dispatch_0_dispatch_1() attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %c4 = constant 4 : index
    %c-1 = constant -1 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c8 = constant 8 : index
    %c-8 = constant -8 : index
    %c64 = constant 64 : index
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg0} : memref<32x1024xf32>
    %2 = iree.placeholder for "interface buffer" {binding = @legacy_io::@arg1} : memref<1024x64xf32>
    %3 = "gpu.block_id"() {dimension = "x"} : () -> index
    %4 = "gpu.block_id"() {dimension = "y"} : () -> index
    scf.for %arg0 = %c0 to %c1024 step %c4 {
      %5 = muli %4, %c8 : index
      %6 = muli %4, %c-8 : index
      %7 = addi %6, %c32 : index
      %8 = cmpi "slt", %c8, %7 : index
      %9 = select %8, %c8, %7 : index
      %10 = muli %arg0, %c-1 : index
      %11 = addi %10, %c1024 : index
      %12 = cmpi "slt", %c4, %11 : index
      %13 = select %12, %c4, %11 : index
      %14 = muli %3, %c8 : index
      %15 = muli %3, %c-8 : index
      %16 = addi %15, %c64 : index
      %17 = cmpi "slt", %c8, %16 : index
      %18 = select %17, %c8, %16 : index
      %19 = "gpu.thread_id"() {dimension = "x"} : () -> index
      %20 = "gpu.thread_id"() {dimension = "y"} : () -> index
      %21 = cmpi "slt", %20, %9 : index
      %22 = cmpi "slt", %19, %18 : index
      %23 = and %21, %22 : i1
      scf.if %23 {
        scf.for %arg1 = %c0 to %13 step %c1 {
          %24 = addi %5, %20 : index
          %25 = addi %arg0, %arg1 : index
          %26 = load %1[%24, %25] : memref<32x1024xf32>
          %27 = addi %14, %19 : index
          %28 = load %2[%25, %27] : memref<1024x64xf32>
          %29 = load %0[%24, %27] : memref<32x64xf32>
          %30 = mulf %26, %28 : f32
          %31 = addf %29, %30 : f32
          store %31, %0[%24, %27] : memref<32x64xf32>
        }
      }
    }
    return
  }
  func @dot_ex_dispatch_0_dispatch_0() attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %cst = constant 0.000000e+00 : f32
    %c2048 = constant 2048 : index
    %c64 = constant 64 : index
    %0 = iree.placeholder for "interface buffer" {binding = @legacy_io::@ret0} : memref<32x64xf32>
    %1 = "gpu.block_id"() {dimension = "x"} : () -> index
    %2 = "gpu.block_dim"() {dimension = "x"} : () -> index
    %3 = "gpu.thread_id"() {dimension = "x"} : () -> index
    %4 = muli %1, %2 : index
    %5 = addi %4, %3 : index
    %6 = cmpi "slt", %5, %c2048 : index
    scf.if %6 {
      %7 = divi_signed %5, %c64 : index
      %8 = remi_signed %5, %c64 : index
      store %cst, %0[%7, %8] : memref<32x64xf32>
    }
    return
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertToSPIRVPass
```
module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
  spv.module Logical GLSL450 {
    spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
    spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
    spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
    spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
    spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {spv.entry_point_abi = {local_size = dense<[8, 8, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 2 : i32} {
      %0 = spv.constant 4 : i32
      %1 = spv.constant -1 : i32
      %2 = spv.constant 1024 : i32
      %3 = spv.constant 32 : i32
      %4 = spv.constant 8 : i32
      %5 = spv.constant -8 : i32
      %6 = spv.constant 64 : i32
      %7 = spv.constant 0 : i32
      %8 = spv.constant 1 : i32
      %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
      %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
      %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
      %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
      %13 = spv.Load "Input" %12 : vector<3xi32>
      %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
      %15 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
      %16 = spv.Load "Input" %15 : vector<3xi32>
      %17 = spv.CompositeExtract %16[1 : i32] : vector<3xi32>
      spv.loop {
        spv.Branch ^bb1(%7 : i32)
      ^bb1(%18: i32):  // 2 preds: ^bb0, ^bb2
        %19 = spv.SLessThan %18, %2 : i32
        spv.BranchConditional %19, ^bb2, ^bb3
      ^bb2:  // pred: ^bb1
        %20 = spv.IMul %17, %4 : i32
        %21 = spv.IMul %17, %5 : i32
        %22 = spv.IAdd %21, %3 : i32
        %23 = spv.SLessThan %4, %22 : i32
        %24 = spv.Select %23, %4, %22 : i1, i32
        %25 = spv.IMul %18, %1 : i32
        %26 = spv.IAdd %25, %2 : i32
        %27 = spv.SLessThan %0, %26 : i32
        %28 = spv.Select %27, %0, %26 : i1, i32
        %29 = spv.IMul %14, %4 : i32
        %30 = spv.IMul %14, %5 : i32
        %31 = spv.IAdd %30, %6 : i32
        %32 = spv.SLessThan %4, %31 : i32
        %33 = spv.Select %32, %4, %31 : i1, i32
        %34 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
        %35 = spv.Load "Input" %34 : vector<3xi32>
        %36 = spv.CompositeExtract %35[0 : i32] : vector<3xi32>
        %37 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
        %38 = spv.Load "Input" %37 : vector<3xi32>
        %39 = spv.CompositeExtract %38[1 : i32] : vector<3xi32>
        %40 = spv.SLessThan %39, %24 : i32
        %41 = spv.SLessThan %36, %33 : i32
        %42 = spv.LogicalAnd %40, %41 : i1
        spv.selection {
          spv.BranchConditional %42, ^bb1, ^bb2
        ^bb1:  // pred: ^bb0
          spv.loop {
            spv.Branch ^bb1(%7 : i32)
          ^bb1(%44: i32):  // 2 preds: ^bb0, ^bb2
            %45 = spv.SLessThan %44, %28 : i32
            spv.BranchConditional %45, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %46 = spv.IAdd %20, %39 : i32
            %47 = spv.IAdd %18, %44 : i32
            %48 = spv.constant 0 : i32
            %49 = spv.constant 0 : i32
            %50 = spv.constant 1024 : i32
            %51 = spv.IMul %50, %46 : i32
            %52 = spv.IAdd %49, %51 : i32
            %53 = spv.constant 1 : i32
            %54 = spv.IMul %53, %47 : i32
            %55 = spv.IAdd %52, %54 : i32
            %56 = spv.AccessChain %10[%48, %55] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
            %57 = spv.Load "StorageBuffer" %56 : f32
            %58 = spv.IAdd %29, %36 : i32
            %59 = spv.constant 0 : i32
            %60 = spv.constant 0 : i32
            %61 = spv.constant 64 : i32
            %62 = spv.IMul %61, %47 : i32
            %63 = spv.IAdd %60, %62 : i32
            %64 = spv.constant 1 : i32
            %65 = spv.IMul %64, %58 : i32
            %66 = spv.IAdd %63, %65 : i32
            %67 = spv.AccessChain %11[%59, %66] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
            %68 = spv.Load "StorageBuffer" %67 : f32
            %69 = spv.constant 0 : i32
            %70 = spv.constant 0 : i32
            %71 = spv.constant 64 : i32
            %72 = spv.IMul %71, %46 : i32
            %73 = spv.IAdd %70, %72 : i32
            %74 = spv.constant 1 : i32
            %75 = spv.IMul %74, %58 : i32
            %76 = spv.IAdd %73, %75 : i32
            %77 = spv.AccessChain %9[%69, %76] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
            %78 = spv.Load "StorageBuffer" %77 : f32
            %79 = spv.FMul %57, %68 : f32
            %80 = spv.FAdd %78, %79 : f32
            %81 = spv.constant 0 : i32
            %82 = spv.constant 0 : i32
            %83 = spv.constant 64 : i32
            %84 = spv.IMul %83, %46 : i32
            %85 = spv.IAdd %82, %84 : i32
            %86 = spv.constant 1 : i32
            %87 = spv.IMul %86, %58 : i32
            %88 = spv.IAdd %85, %87 : i32
            %89 = spv.AccessChain %9[%81, %88] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
            spv.Store "StorageBuffer" %89, %80 : f32
            %90 = spv.IAdd %44, %8 : i32
            spv.Branch ^bb1(%90 : i32)
          ^bb3:  // pred: ^bb1
            spv._merge
          }
          spv.Branch ^bb2
        ^bb2:  // 2 preds: ^bb0, ^bb1
          spv._merge
        }
        %43 = spv.IAdd %18, %0 : i32
        spv.Branch ^bb1(%43 : i32)
      ^bb3:  // pred: ^bb1
        spv._merge
      }
      spv.Return
    }
    spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {spv.entry_point_abi = {local_size = dense<[32, 1, 1]> : vector<3xi32>}, vkspv.workgroup_count_from_result_shape = 1 : i32} {
      %0 = spv.constant 0.000000e+00 : f32
      %1 = spv.constant 2048 : i32
      %2 = spv.constant 64 : i32
      %3 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
      %4 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
      %5 = spv.Load "Input" %4 : vector<3xi32>
      %6 = spv.CompositeExtract %5[0 : i32] : vector<3xi32>
      %7 = spv.constant 32 : i32
      %8 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
      %9 = spv.Load "Input" %8 : vector<3xi32>
      %10 = spv.CompositeExtract %9[0 : i32] : vector<3xi32>
      %11 = spv.IMul %6, %7 : i32
      %12 = spv.IAdd %11, %10 : i32
      %13 = spv.SLessThan %12, %1 : i32
      spv.selection {
        spv.BranchConditional %13, ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        %14 = spv.SDiv %12, %2 : i32
        %15 = spv.GLSL.SAbs %12 : i32
        %16 = spv.GLSL.SAbs %2 : i32
        %17 = spv.UMod %15, %16 : i32
        %18 = spv.IEqual %12, %15 : i32
        %19 = spv.SNegate %17 : i32
        %20 = spv.Select %18, %17, %19 : i1, i32
        %21 = spv.constant 0 : i32
        %22 = spv.constant 0 : i32
        %23 = spv.constant 64 : i32
        %24 = spv.IMul %23, %14 : i32
        %25 = spv.IAdd %22, %24 : i32
        %26 = spv.constant 1 : i32
        %27 = spv.IMul %26, %20 : i32
        %28 = spv.IAdd %25, %27 : i32
        %29 = spv.AccessChain %3[%21, %28] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
        spv.Store "StorageBuffer" %29, %0 : f32
        spv.Branch ^bb2
      ^bb2:  // 2 preds: ^bb0, ^bb1
        spv._merge
      }
      spv.Return
    }
  }
  hal.interface @legacy_io attributes {sym_visibility = "private"} {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
}

```
### IR Dump After SPIRVLowerABIAttributes
```
spv.module Logical GLSL450 {
  spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
  spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %0 = spv.constant 4 : i32
    %1 = spv.constant -1 : i32
    %2 = spv.constant 1024 : i32
    %3 = spv.constant 32 : i32
    %4 = spv.constant 8 : i32
    %5 = spv.constant -8 : i32
    %6 = spv.constant 64 : i32
    %7 = spv.constant 0 : i32
    %8 = spv.constant 1 : i32
    %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
    %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
    %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %13 = spv.Load "Input" %12 : vector<3xi32>
    %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
    %15 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %16 = spv.Load "Input" %15 : vector<3xi32>
    %17 = spv.CompositeExtract %16[1 : i32] : vector<3xi32>
    spv.loop {
      spv.Branch ^bb1(%7 : i32)
    ^bb1(%18: i32):  // 2 preds: ^bb0, ^bb2
      %19 = spv.SLessThan %18, %2 : i32
      spv.BranchConditional %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = spv.IMul %17, %4 : i32
      %21 = spv.IMul %17, %5 : i32
      %22 = spv.IAdd %21, %3 : i32
      %23 = spv.SLessThan %4, %22 : i32
      %24 = spv.Select %23, %4, %22 : i1, i32
      %25 = spv.IMul %18, %1 : i32
      %26 = spv.IAdd %25, %2 : i32
      %27 = spv.SLessThan %0, %26 : i32
      %28 = spv.Select %27, %0, %26 : i1, i32
      %29 = spv.IMul %14, %4 : i32
      %30 = spv.IMul %14, %5 : i32
      %31 = spv.IAdd %30, %6 : i32
      %32 = spv.SLessThan %4, %31 : i32
      %33 = spv.Select %32, %4, %31 : i1, i32
      %34 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
      %35 = spv.Load "Input" %34 : vector<3xi32>
      %36 = spv.CompositeExtract %35[0 : i32] : vector<3xi32>
      %37 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
      %38 = spv.Load "Input" %37 : vector<3xi32>
      %39 = spv.CompositeExtract %38[1 : i32] : vector<3xi32>
      %40 = spv.SLessThan %39, %24 : i32
      %41 = spv.SLessThan %36, %33 : i32
      %42 = spv.LogicalAnd %40, %41 : i1
      spv.selection {
        spv.BranchConditional %42, ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        spv.loop {
          spv.Branch ^bb1(%7 : i32)
        ^bb1(%44: i32):  // 2 preds: ^bb0, ^bb2
          %45 = spv.SLessThan %44, %28 : i32
          spv.BranchConditional %45, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %46 = spv.IAdd %20, %39 : i32
          %47 = spv.IAdd %18, %44 : i32
          %48 = spv.constant 0 : i32
          %49 = spv.constant 0 : i32
          %50 = spv.constant 1024 : i32
          %51 = spv.IMul %50, %46 : i32
          %52 = spv.IAdd %49, %51 : i32
          %53 = spv.constant 1 : i32
          %54 = spv.IMul %53, %47 : i32
          %55 = spv.IAdd %52, %54 : i32
          %56 = spv.AccessChain %10[%48, %55] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %57 = spv.Load "StorageBuffer" %56 : f32
          %58 = spv.IAdd %29, %36 : i32
          %59 = spv.constant 0 : i32
          %60 = spv.constant 0 : i32
          %61 = spv.constant 64 : i32
          %62 = spv.IMul %61, %47 : i32
          %63 = spv.IAdd %60, %62 : i32
          %64 = spv.constant 1 : i32
          %65 = spv.IMul %64, %58 : i32
          %66 = spv.IAdd %63, %65 : i32
          %67 = spv.AccessChain %11[%59, %66] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %68 = spv.Load "StorageBuffer" %67 : f32
          %69 = spv.constant 0 : i32
          %70 = spv.constant 0 : i32
          %71 = spv.constant 64 : i32
          %72 = spv.IMul %71, %46 : i32
          %73 = spv.IAdd %70, %72 : i32
          %74 = spv.constant 1 : i32
          %75 = spv.IMul %74, %58 : i32
          %76 = spv.IAdd %73, %75 : i32
          %77 = spv.AccessChain %9[%69, %76] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %78 = spv.Load "StorageBuffer" %77 : f32
          %79 = spv.FMul %57, %68 : f32
          %80 = spv.FAdd %78, %79 : f32
          %81 = spv.constant 0 : i32
          %82 = spv.constant 0 : i32
          %83 = spv.constant 64 : i32
          %84 = spv.IMul %83, %46 : i32
          %85 = spv.IAdd %82, %84 : i32
          %86 = spv.constant 1 : i32
          %87 = spv.IMul %86, %58 : i32
          %88 = spv.IAdd %85, %87 : i32
          %89 = spv.AccessChain %9[%81, %88] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          spv.Store "StorageBuffer" %89, %80 : f32
          %90 = spv.IAdd %44, %8 : i32
          spv.Branch ^bb1(%90 : i32)
        ^bb3:  // pred: ^bb1
          spv._merge
        }
        spv.Branch ^bb2
      ^bb2:  // 2 preds: ^bb0, ^bb1
        spv._merge
      }
      %43 = spv.IAdd %18, %0 : i32
      spv.Branch ^bb1(%43 : i32)
    ^bb3:  // pred: ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %0 = spv.constant 0.000000e+00 : f32
    %1 = spv.constant 2048 : i32
    %2 = spv.constant 64 : i32
    %3 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %4 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %5 = spv.Load "Input" %4 : vector<3xi32>
    %6 = spv.CompositeExtract %5[0 : i32] : vector<3xi32>
    %7 = spv.constant 32 : i32
    %8 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
    %9 = spv.Load "Input" %8 : vector<3xi32>
    %10 = spv.CompositeExtract %9[0 : i32] : vector<3xi32>
    %11 = spv.IMul %6, %7 : i32
    %12 = spv.IAdd %11, %10 : i32
    %13 = spv.SLessThan %12, %1 : i32
    spv.selection {
      spv.BranchConditional %13, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %14 = spv.SDiv %12, %2 : i32
      %15 = spv.GLSL.SAbs %12 : i32
      %16 = spv.GLSL.SAbs %2 : i32
      %17 = spv.UMod %15, %16 : i32
      %18 = spv.IEqual %12, %15 : i32
      %19 = spv.SNegate %17 : i32
      %20 = spv.Select %18, %17, %19 : i1, i32
      %21 = spv.constant 0 : i32
      %22 = spv.constant 0 : i32
      %23 = spv.constant 64 : i32
      %24 = spv.IMul %23, %14 : i32
      %25 = spv.IAdd %22, %24 : i32
      %26 = spv.constant 1 : i32
      %27 = spv.IMul %26, %20 : i32
      %28 = spv.IAdd %25, %27 : i32
      %29 = spv.AccessChain %3[%21, %28] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
      spv.Store "StorageBuffer" %29, %0 : f32
      spv.Branch ^bb2
    ^bb2:  // 2 preds: ^bb0, ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
}

```
### IR Dump After Canonicalizer
```
spv.module Logical GLSL450 {
  spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
  spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %0 = spv.constant 4 : i32
    %1 = spv.constant -1 : i32
    %2 = spv.constant 32 : i32
    %3 = spv.constant 8 : i32
    %4 = spv.constant -8 : i32
    %5 = spv.constant 1 : i32
    %6 = spv.constant 1024 : i32
    %7 = spv.constant 0 : i32
    %8 = spv.constant 64 : i32
    %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
    %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
    %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %13 = spv.Load "Input" %12 : vector<3xi32>
    %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
    %15 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %16 = spv.Load "Input" %15 : vector<3xi32>
    %17 = spv.CompositeExtract %16[1 : i32] : vector<3xi32>
    spv.loop {
      spv.Branch ^bb1(%7 : i32)
    ^bb1(%18: i32):  // 2 preds: ^bb0, ^bb2
      %19 = spv.SLessThan %18, %6 : i32
      spv.BranchConditional %19, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %20 = spv.IMul %17, %3 : i32
      %21 = spv.IMul %17, %4 : i32
      %22 = spv.IAdd %21, %2 : i32
      %23 = spv.SLessThan %3, %22 : i32
      %24 = spv.Select %23, %3, %22 : i1, i32
      %25 = spv.IMul %18, %1 : i32
      %26 = spv.IAdd %25, %6 : i32
      %27 = spv.SLessThan %0, %26 : i32
      %28 = spv.Select %27, %0, %26 : i1, i32
      %29 = spv.IMul %14, %3 : i32
      %30 = spv.IMul %14, %4 : i32
      %31 = spv.IAdd %30, %8 : i32
      %32 = spv.SLessThan %3, %31 : i32
      %33 = spv.Select %32, %3, %31 : i1, i32
      %34 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
      %35 = spv.Load "Input" %34 : vector<3xi32>
      %36 = spv.CompositeExtract %35[0 : i32] : vector<3xi32>
      %37 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
      %38 = spv.Load "Input" %37 : vector<3xi32>
      %39 = spv.CompositeExtract %38[1 : i32] : vector<3xi32>
      %40 = spv.SLessThan %39, %24 : i32
      %41 = spv.SLessThan %36, %33 : i32
      %42 = spv.LogicalAnd %40, %41 : i1
      spv.selection {
        spv.BranchConditional %42, ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        spv.loop {
          spv.Branch ^bb1(%7 : i32)
        ^bb1(%44: i32):  // 2 preds: ^bb0, ^bb2
          %45 = spv.SLessThan %44, %28 : i32
          spv.BranchConditional %45, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %46 = spv.IAdd %20, %39 : i32
          %47 = spv.IAdd %18, %44 : i32
          %48 = spv.IMul %46, %6 : i32
          %49 = spv.IAdd %48, %47 : i32
          %50 = spv.AccessChain %10[%7, %49] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %51 = spv.Load "StorageBuffer" %50 : f32
          %52 = spv.IAdd %29, %36 : i32
          %53 = spv.IMul %47, %8 : i32
          %54 = spv.IAdd %53, %52 : i32
          %55 = spv.AccessChain %11[%7, %54] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %56 = spv.Load "StorageBuffer" %55 : f32
          %57 = spv.IMul %46, %8 : i32
          %58 = spv.IAdd %57, %52 : i32
          %59 = spv.AccessChain %9[%7, %58] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %60 = spv.Load "StorageBuffer" %59 : f32
          %61 = spv.FMul %51, %56 : f32
          %62 = spv.FAdd %60, %61 : f32
          %63 = spv.IMul %46, %8 : i32
          %64 = spv.IAdd %63, %52 : i32
          %65 = spv.AccessChain %9[%7, %64] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          spv.Store "StorageBuffer" %65, %62 : f32
          %66 = spv.IAdd %44, %5 : i32
          spv.Branch ^bb1(%66 : i32)
        ^bb3:  // pred: ^bb1
          spv._merge
        }
        spv.Branch ^bb2
      ^bb2:  // 2 preds: ^bb0, ^bb1
        spv._merge
      }
      %43 = spv.IAdd %18, %0 : i32
      spv.Branch ^bb1(%43 : i32)
    ^bb3:  // pred: ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %0 = spv.constant 0.000000e+00 : f32
    %1 = spv.constant 2048 : i32
    %2 = spv.constant 32 : i32
    %3 = spv.constant 0 : i32
    %4 = spv.constant 64 : i32
    %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %7 = spv.Load "Input" %6 : vector<3xi32>
    %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
    %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
    %10 = spv.Load "Input" %9 : vector<3xi32>
    %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
    %12 = spv.IMul %8, %2 : i32
    %13 = spv.IAdd %12, %11 : i32
    %14 = spv.SLessThan %13, %1 : i32
    spv.selection {
      spv.BranchConditional %14, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %15 = spv.SDiv %13, %4 : i32
      %16 = spv.GLSL.SAbs %13 : i32
      %17 = spv.GLSL.SAbs %4 : i32
      %18 = spv.UMod %16, %17 : i32
      %19 = spv.IEqual %13, %16 : i32
      %20 = spv.SNegate %18 : i32
      %21 = spv.Select %19, %18, %20 : i1, i32
      %22 = spv.IMul %15, %4 : i32
      %23 = spv.IAdd %22, %21 : i32
      %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
      spv.Store "StorageBuffer" %24, %0 : f32
      spv.Branch ^bb2
    ^bb2:  // 2 preds: ^bb0, ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
}

```
### IR Dump After CSE
```
spv.module Logical GLSL450 {
  spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
  spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %0 = spv.constant 4 : i32
    %1 = spv.constant -1 : i32
    %2 = spv.constant 32 : i32
    %3 = spv.constant 8 : i32
    %4 = spv.constant -8 : i32
    %5 = spv.constant 1 : i32
    %6 = spv.constant 1024 : i32
    %7 = spv.constant 0 : i32
    %8 = spv.constant 64 : i32
    %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
    %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
    %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %13 = spv.Load "Input" %12 : vector<3xi32>
    %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
    %15 = spv.Load "Input" %12 : vector<3xi32>
    %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
    spv.loop {
      spv.Branch ^bb1(%7 : i32)
    ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
      %18 = spv.SLessThan %17, %6 : i32
      spv.BranchConditional %18, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %19 = spv.IMul %16, %3 : i32
      %20 = spv.IMul %16, %4 : i32
      %21 = spv.IAdd %20, %2 : i32
      %22 = spv.SLessThan %3, %21 : i32
      %23 = spv.Select %22, %3, %21 : i1, i32
      %24 = spv.IMul %17, %1 : i32
      %25 = spv.IAdd %24, %6 : i32
      %26 = spv.SLessThan %0, %25 : i32
      %27 = spv.Select %26, %0, %25 : i1, i32
      %28 = spv.IMul %14, %3 : i32
      %29 = spv.IMul %14, %4 : i32
      %30 = spv.IAdd %29, %8 : i32
      %31 = spv.SLessThan %3, %30 : i32
      %32 = spv.Select %31, %3, %30 : i1, i32
      %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
      %34 = spv.Load "Input" %33 : vector<3xi32>
      %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
      %36 = spv.Load "Input" %33 : vector<3xi32>
      %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
      %38 = spv.SLessThan %37, %23 : i32
      %39 = spv.SLessThan %35, %32 : i32
      %40 = spv.LogicalAnd %38, %39 : i1
      spv.selection {
        spv.BranchConditional %40, ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        spv.loop {
          spv.Branch ^bb1(%7 : i32)
        ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
          %43 = spv.SLessThan %42, %27 : i32
          spv.BranchConditional %43, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %44 = spv.IAdd %19, %37 : i32
          %45 = spv.IAdd %17, %42 : i32
          %46 = spv.IMul %44, %6 : i32
          %47 = spv.IAdd %46, %45 : i32
          %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %49 = spv.Load "StorageBuffer" %48 : f32
          %50 = spv.IAdd %28, %35 : i32
          %51 = spv.IMul %45, %8 : i32
          %52 = spv.IAdd %51, %50 : i32
          %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %54 = spv.Load "StorageBuffer" %53 : f32
          %55 = spv.IMul %44, %8 : i32
          %56 = spv.IAdd %55, %50 : i32
          %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %58 = spv.Load "StorageBuffer" %57 : f32
          %59 = spv.FMul %49, %54 : f32
          %60 = spv.FAdd %58, %59 : f32
          spv.Store "StorageBuffer" %57, %60 : f32
          %61 = spv.IAdd %42, %5 : i32
          spv.Branch ^bb1(%61 : i32)
        ^bb3:  // pred: ^bb1
          spv._merge
        }
        spv.Branch ^bb2
      ^bb2:  // 2 preds: ^bb0, ^bb1
        spv._merge
      }
      %41 = spv.IAdd %17, %0 : i32
      spv.Branch ^bb1(%41 : i32)
    ^bb3:  // pred: ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %0 = spv.constant 0.000000e+00 : f32
    %1 = spv.constant 2048 : i32
    %2 = spv.constant 32 : i32
    %3 = spv.constant 0 : i32
    %4 = spv.constant 64 : i32
    %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %7 = spv.Load "Input" %6 : vector<3xi32>
    %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
    %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
    %10 = spv.Load "Input" %9 : vector<3xi32>
    %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
    %12 = spv.IMul %8, %2 : i32
    %13 = spv.IAdd %12, %11 : i32
    %14 = spv.SLessThan %13, %1 : i32
    spv.selection {
      spv.BranchConditional %14, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %15 = spv.SDiv %13, %4 : i32
      %16 = spv.GLSL.SAbs %13 : i32
      %17 = spv.GLSL.SAbs %4 : i32
      %18 = spv.UMod %16, %17 : i32
      %19 = spv.IEqual %13, %16 : i32
      %20 = spv.SNegate %18 : i32
      %21 = spv.Select %19, %18, %20 : i1, i32
      %22 = spv.IMul %15, %4 : i32
      %23 = spv.IAdd %22, %21 : i32
      %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
      spv.Store "StorageBuffer" %24, %0 : f32
      spv.Branch ^bb2
    ^bb2:  // 2 preds: ^bb0, ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
}

```
### IR Dump After SPIRVUpdateVCE
```
spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
  spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
  spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
  spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
  spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
    %0 = spv.constant 4 : i32
    %1 = spv.constant -1 : i32
    %2 = spv.constant 32 : i32
    %3 = spv.constant 8 : i32
    %4 = spv.constant -8 : i32
    %5 = spv.constant 1 : i32
    %6 = spv.constant 1024 : i32
    %7 = spv.constant 0 : i32
    %8 = spv.constant 64 : i32
    %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
    %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
    %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %13 = spv.Load "Input" %12 : vector<3xi32>
    %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
    %15 = spv.Load "Input" %12 : vector<3xi32>
    %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
    spv.loop {
      spv.Branch ^bb1(%7 : i32)
    ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
      %18 = spv.SLessThan %17, %6 : i32
      spv.BranchConditional %18, ^bb2, ^bb3
    ^bb2:  // pred: ^bb1
      %19 = spv.IMul %16, %3 : i32
      %20 = spv.IMul %16, %4 : i32
      %21 = spv.IAdd %20, %2 : i32
      %22 = spv.SLessThan %3, %21 : i32
      %23 = spv.Select %22, %3, %21 : i1, i32
      %24 = spv.IMul %17, %1 : i32
      %25 = spv.IAdd %24, %6 : i32
      %26 = spv.SLessThan %0, %25 : i32
      %27 = spv.Select %26, %0, %25 : i1, i32
      %28 = spv.IMul %14, %3 : i32
      %29 = spv.IMul %14, %4 : i32
      %30 = spv.IAdd %29, %8 : i32
      %31 = spv.SLessThan %3, %30 : i32
      %32 = spv.Select %31, %3, %30 : i1, i32
      %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
      %34 = spv.Load "Input" %33 : vector<3xi32>
      %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
      %36 = spv.Load "Input" %33 : vector<3xi32>
      %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
      %38 = spv.SLessThan %37, %23 : i32
      %39 = spv.SLessThan %35, %32 : i32
      %40 = spv.LogicalAnd %38, %39 : i1
      spv.selection {
        spv.BranchConditional %40, ^bb1, ^bb2
      ^bb1:  // pred: ^bb0
        spv.loop {
          spv.Branch ^bb1(%7 : i32)
        ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
          %43 = spv.SLessThan %42, %27 : i32
          spv.BranchConditional %43, ^bb2, ^bb3
        ^bb2:  // pred: ^bb1
          %44 = spv.IAdd %19, %37 : i32
          %45 = spv.IAdd %17, %42 : i32
          %46 = spv.IMul %44, %6 : i32
          %47 = spv.IAdd %46, %45 : i32
          %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %49 = spv.Load "StorageBuffer" %48 : f32
          %50 = spv.IAdd %28, %35 : i32
          %51 = spv.IMul %45, %8 : i32
          %52 = spv.IAdd %51, %50 : i32
          %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %54 = spv.Load "StorageBuffer" %53 : f32
          %55 = spv.IMul %44, %8 : i32
          %56 = spv.IAdd %55, %50 : i32
          %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
          %58 = spv.Load "StorageBuffer" %57 : f32
          %59 = spv.FMul %49, %54 : f32
          %60 = spv.FAdd %58, %59 : f32
          spv.Store "StorageBuffer" %57, %60 : f32
          %61 = spv.IAdd %42, %5 : i32
          spv.Branch ^bb1(%61 : i32)
        ^bb3:  // pred: ^bb1
          spv._merge
        }
        spv.Branch ^bb2
      ^bb2:  // 2 preds: ^bb0, ^bb1
        spv._merge
      }
      %41 = spv.IAdd %17, %0 : i32
      spv.Branch ^bb1(%41 : i32)
    ^bb3:  // pred: ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
    %0 = spv.constant 0.000000e+00 : f32
    %1 = spv.constant 2048 : i32
    %2 = spv.constant 32 : i32
    %3 = spv.constant 0 : i32
    %4 = spv.constant 64 : i32
    %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
    %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
    %7 = spv.Load "Input" %6 : vector<3xi32>
    %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
    %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
    %10 = spv.Load "Input" %9 : vector<3xi32>
    %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
    %12 = spv.IMul %8, %2 : i32
    %13 = spv.IAdd %12, %11 : i32
    %14 = spv.SLessThan %13, %1 : i32
    spv.selection {
      spv.BranchConditional %14, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %15 = spv.SDiv %13, %4 : i32
      %16 = spv.GLSL.SAbs %13 : i32
      %17 = spv.GLSL.SAbs %4 : i32
      %18 = spv.UMod %16, %17 : i32
      %19 = spv.IEqual %13, %16 : i32
      %20 = spv.SNegate %18 : i32
      %21 = spv.Select %19, %18, %20 : i1, i32
      %22 = spv.IMul %15, %4 : i32
      %23 = spv.IAdd %22, %21 : i32
      %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
      spv.Store "StorageBuffer" %24, %0 : f32
      spv.Branch ^bb2
    ^bb2:  // 2 preds: ^bb0, ^bb1
      spv._merge
    }
    spv.Return
  }
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
  spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
  spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::TranslateExecutablesPass
```
hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
  hal.interface @legacy_io {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
  hal.executable.target @vulkan_spirv, filter="vulkan*" {
    hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
    module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
      spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
        spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
        spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
        spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
        spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
        spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
        spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
          %0 = spv.constant 4 : i32
          %1 = spv.constant -1 : i32
          %2 = spv.constant 32 : i32
          %3 = spv.constant 8 : i32
          %4 = spv.constant -8 : i32
          %5 = spv.constant 1 : i32
          %6 = spv.constant 1024 : i32
          %7 = spv.constant 0 : i32
          %8 = spv.constant 64 : i32
          %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
          %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
          %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
          %13 = spv.Load "Input" %12 : vector<3xi32>
          %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
          %15 = spv.Load "Input" %12 : vector<3xi32>
          %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
          spv.loop {
            spv.Branch ^bb1(%7 : i32)
          ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
            %18 = spv.SLessThan %17, %6 : i32
            spv.BranchConditional %18, ^bb2, ^bb3
          ^bb2:  // pred: ^bb1
            %19 = spv.IMul %16, %3 : i32
            %20 = spv.IMul %16, %4 : i32
            %21 = spv.IAdd %20, %2 : i32
            %22 = spv.SLessThan %3, %21 : i32
            %23 = spv.Select %22, %3, %21 : i1, i32
            %24 = spv.IMul %17, %1 : i32
            %25 = spv.IAdd %24, %6 : i32
            %26 = spv.SLessThan %0, %25 : i32
            %27 = spv.Select %26, %0, %25 : i1, i32
            %28 = spv.IMul %14, %3 : i32
            %29 = spv.IMul %14, %4 : i32
            %30 = spv.IAdd %29, %8 : i32
            %31 = spv.SLessThan %3, %30 : i32
            %32 = spv.Select %31, %3, %30 : i1, i32
            %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
            %34 = spv.Load "Input" %33 : vector<3xi32>
            %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
            %36 = spv.Load "Input" %33 : vector<3xi32>
            %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
            %38 = spv.SLessThan %37, %23 : i32
            %39 = spv.SLessThan %35, %32 : i32
            %40 = spv.LogicalAnd %38, %39 : i1
            spv.selection {
              spv.BranchConditional %40, ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              spv.loop {
                spv.Branch ^bb1(%7 : i32)
              ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
                %43 = spv.SLessThan %42, %27 : i32
                spv.BranchConditional %43, ^bb2, ^bb3
              ^bb2:  // pred: ^bb1
                %44 = spv.IAdd %19, %37 : i32
                %45 = spv.IAdd %17, %42 : i32
                %46 = spv.IMul %44, %6 : i32
                %47 = spv.IAdd %46, %45 : i32
                %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                %49 = spv.Load "StorageBuffer" %48 : f32
                %50 = spv.IAdd %28, %35 : i32
                %51 = spv.IMul %45, %8 : i32
                %52 = spv.IAdd %51, %50 : i32
                %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                %54 = spv.Load "StorageBuffer" %53 : f32
                %55 = spv.IMul %44, %8 : i32
                %56 = spv.IAdd %55, %50 : i32
                %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                %58 = spv.Load "StorageBuffer" %57 : f32
                %59 = spv.FMul %49, %54 : f32
                %60 = spv.FAdd %58, %59 : f32
                spv.Store "StorageBuffer" %57, %60 : f32
                %61 = spv.IAdd %42, %5 : i32
                spv.Branch ^bb1(%61 : i32)
              ^bb3:  // pred: ^bb1
                spv._merge
              }
              spv.Branch ^bb2
            ^bb2:  // 2 preds: ^bb0, ^bb1
              spv._merge
            }
            %41 = spv.IAdd %17, %0 : i32
            spv.Branch ^bb1(%41 : i32)
          ^bb3:  // pred: ^bb1
            spv._merge
          }
          spv.Return
        }
        spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
          %0 = spv.constant 0.000000e+00 : f32
          %1 = spv.constant 2048 : i32
          %2 = spv.constant 32 : i32
          %3 = spv.constant 0 : i32
          %4 = spv.constant 64 : i32
          %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
          %7 = spv.Load "Input" %6 : vector<3xi32>
          %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
          %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
          %10 = spv.Load "Input" %9 : vector<3xi32>
          %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
          %12 = spv.IMul %8, %2 : i32
          %13 = spv.IAdd %12, %11 : i32
          %14 = spv.SLessThan %13, %1 : i32
          spv.selection {
            spv.BranchConditional %14, ^bb1, ^bb2
          ^bb1:  // pred: ^bb0
            %15 = spv.SDiv %13, %4 : i32
            %16 = spv.GLSL.SAbs %13 : i32
            %17 = spv.GLSL.SAbs %4 : i32
            %18 = spv.UMod %16, %17 : i32
            %19 = spv.IEqual %13, %16 : i32
            %20 = spv.SNegate %18 : i32
            %21 = spv.Select %19, %18, %20 : i1, i32
            %22 = spv.IMul %15, %4 : i32
            %23 = spv.IAdd %22, %21 : i32
            %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
            spv.Store "StorageBuffer" %24, %0 : f32
            spv.Branch ^bb2
          ^bb2:  // 2 preds: ^bb0, ^bb1
            spv._merge
          }
          spv.Return
        }
        spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
        spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
        spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
        spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
      }
      hal.interface @legacy_io attributes {sym_visibility = "private"} {
        hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
        hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
        hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
      }
    }
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::LinkExecutablesPass
```

module {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vulkan_spirv, filter="vulkan*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
        spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
          spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
            %0 = spv.constant 4 : i32
            %1 = spv.constant -1 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 8 : i32
            %4 = spv.constant -8 : i32
            %5 = spv.constant 1 : i32
            %6 = spv.constant 1024 : i32
            %7 = spv.constant 0 : i32
            %8 = spv.constant 64 : i32
            %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
            %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
            %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %13 = spv.Load "Input" %12 : vector<3xi32>
            %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
            %15 = spv.Load "Input" %12 : vector<3xi32>
            %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
            spv.loop {
              spv.Branch ^bb1(%7 : i32)
            ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
              %18 = spv.SLessThan %17, %6 : i32
              spv.BranchConditional %18, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %19 = spv.IMul %16, %3 : i32
              %20 = spv.IMul %16, %4 : i32
              %21 = spv.IAdd %20, %2 : i32
              %22 = spv.SLessThan %3, %21 : i32
              %23 = spv.Select %22, %3, %21 : i1, i32
              %24 = spv.IMul %17, %1 : i32
              %25 = spv.IAdd %24, %6 : i32
              %26 = spv.SLessThan %0, %25 : i32
              %27 = spv.Select %26, %0, %25 : i1, i32
              %28 = spv.IMul %14, %3 : i32
              %29 = spv.IMul %14, %4 : i32
              %30 = spv.IAdd %29, %8 : i32
              %31 = spv.SLessThan %3, %30 : i32
              %32 = spv.Select %31, %3, %30 : i1, i32
              %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
              %34 = spv.Load "Input" %33 : vector<3xi32>
              %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
              %36 = spv.Load "Input" %33 : vector<3xi32>
              %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
              %38 = spv.SLessThan %37, %23 : i32
              %39 = spv.SLessThan %35, %32 : i32
              %40 = spv.LogicalAnd %38, %39 : i1
              spv.selection {
                spv.BranchConditional %40, ^bb1, ^bb2
              ^bb1:  // pred: ^bb0
                spv.loop {
                  spv.Branch ^bb1(%7 : i32)
                ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
                  %43 = spv.SLessThan %42, %27 : i32
                  spv.BranchConditional %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = spv.IAdd %19, %37 : i32
                  %45 = spv.IAdd %17, %42 : i32
                  %46 = spv.IMul %44, %6 : i32
                  %47 = spv.IAdd %46, %45 : i32
                  %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %49 = spv.Load "StorageBuffer" %48 : f32
                  %50 = spv.IAdd %28, %35 : i32
                  %51 = spv.IMul %45, %8 : i32
                  %52 = spv.IAdd %51, %50 : i32
                  %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %54 = spv.Load "StorageBuffer" %53 : f32
                  %55 = spv.IMul %44, %8 : i32
                  %56 = spv.IAdd %55, %50 : i32
                  %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %58 = spv.Load "StorageBuffer" %57 : f32
                  %59 = spv.FMul %49, %54 : f32
                  %60 = spv.FAdd %58, %59 : f32
                  spv.Store "StorageBuffer" %57, %60 : f32
                  %61 = spv.IAdd %42, %5 : i32
                  spv.Branch ^bb1(%61 : i32)
                ^bb3:  // pred: ^bb1
                  spv._merge
                }
                spv.Branch ^bb2
              ^bb2:  // 2 preds: ^bb0, ^bb1
                spv._merge
              }
              %41 = spv.IAdd %17, %0 : i32
              spv.Branch ^bb1(%41 : i32)
            ^bb3:  // pred: ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
            %0 = spv.constant 0.000000e+00 : f32
            %1 = spv.constant 2048 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 0 : i32
            %4 = spv.constant 64 : i32
            %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %7 = spv.Load "Input" %6 : vector<3xi32>
            %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
            %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
            %10 = spv.Load "Input" %9 : vector<3xi32>
            %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
            %12 = spv.IMul %8, %2 : i32
            %13 = spv.IAdd %12, %11 : i32
            %14 = spv.SLessThan %13, %1 : i32
            spv.selection {
              spv.BranchConditional %14, ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              %15 = spv.SDiv %13, %4 : i32
              %16 = spv.GLSL.SAbs %13 : i32
              %17 = spv.GLSL.SAbs %4 : i32
              %18 = spv.UMod %16, %17 : i32
              %19 = spv.IEqual %13, %16 : i32
              %20 = spv.SNegate %18 : i32
              %21 = spv.Select %19, %18, %20 : i1, i32
              %22 = spv.IMul %15, %4 : i32
              %23 = spv.IAdd %22, %21 : i32
              %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
              spv.Store "StorageBuffer" %24, %0 : f32
              spv.Branch ^bb2
            ^bb2:  // 2 preds: ^bb0, ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: tensor<32x1024xf32> {iree.reflection = {}}, %arg1: tensor<1024x64xf32> {iree.reflection = {}}) -> (tensor<32x64xf32> {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %0 = flow.ex.stream.fragment(%arg2 = %c2048 : index, %arg3 = %arg0 : tensor<32x1024xf32>, %arg4 = %arg1 : tensor<1024x64xf32>) -> tensor<32x64xf32> {
      %1 = flow.dispatch @dot_ex_dispatch_0::@dot_ex_dispatch_0[%arg2 : index](%arg3, %arg4) : (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>
      flow.return %1 : tensor<32x64xf32>
    }
    return %0 : tensor<32x64xf32>
  }
}

```
### IR Dump After mlir::iree_compiler::{anonymous}::ConvertFlowToHALPass
```

module {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vulkan_spirv, filter="vulkan*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
        spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
          spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
            %0 = spv.constant 4 : i32
            %1 = spv.constant -1 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 8 : i32
            %4 = spv.constant -8 : i32
            %5 = spv.constant 1 : i32
            %6 = spv.constant 1024 : i32
            %7 = spv.constant 0 : i32
            %8 = spv.constant 64 : i32
            %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
            %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
            %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %13 = spv.Load "Input" %12 : vector<3xi32>
            %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
            %15 = spv.Load "Input" %12 : vector<3xi32>
            %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
            spv.loop {
              spv.Branch ^bb1(%7 : i32)
            ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
              %18 = spv.SLessThan %17, %6 : i32
              spv.BranchConditional %18, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %19 = spv.IMul %16, %3 : i32
              %20 = spv.IMul %16, %4 : i32
              %21 = spv.IAdd %20, %2 : i32
              %22 = spv.SLessThan %3, %21 : i32
              %23 = spv.Select %22, %3, %21 : i1, i32
              %24 = spv.IMul %17, %1 : i32
              %25 = spv.IAdd %24, %6 : i32
              %26 = spv.SLessThan %0, %25 : i32
              %27 = spv.Select %26, %0, %25 : i1, i32
              %28 = spv.IMul %14, %3 : i32
              %29 = spv.IMul %14, %4 : i32
              %30 = spv.IAdd %29, %8 : i32
              %31 = spv.SLessThan %3, %30 : i32
              %32 = spv.Select %31, %3, %30 : i1, i32
              %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
              %34 = spv.Load "Input" %33 : vector<3xi32>
              %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
              %36 = spv.Load "Input" %33 : vector<3xi32>
              %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
              %38 = spv.SLessThan %37, %23 : i32
              %39 = spv.SLessThan %35, %32 : i32
              %40 = spv.LogicalAnd %38, %39 : i1
              spv.selection {
                spv.BranchConditional %40, ^bb1, ^bb2
              ^bb1:  // pred: ^bb0
                spv.loop {
                  spv.Branch ^bb1(%7 : i32)
                ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
                  %43 = spv.SLessThan %42, %27 : i32
                  spv.BranchConditional %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = spv.IAdd %19, %37 : i32
                  %45 = spv.IAdd %17, %42 : i32
                  %46 = spv.IMul %44, %6 : i32
                  %47 = spv.IAdd %46, %45 : i32
                  %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %49 = spv.Load "StorageBuffer" %48 : f32
                  %50 = spv.IAdd %28, %35 : i32
                  %51 = spv.IMul %45, %8 : i32
                  %52 = spv.IAdd %51, %50 : i32
                  %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %54 = spv.Load "StorageBuffer" %53 : f32
                  %55 = spv.IMul %44, %8 : i32
                  %56 = spv.IAdd %55, %50 : i32
                  %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %58 = spv.Load "StorageBuffer" %57 : f32
                  %59 = spv.FMul %49, %54 : f32
                  %60 = spv.FAdd %58, %59 : f32
                  spv.Store "StorageBuffer" %57, %60 : f32
                  %61 = spv.IAdd %42, %5 : i32
                  spv.Branch ^bb1(%61 : i32)
                ^bb3:  // pred: ^bb1
                  spv._merge
                }
                spv.Branch ^bb2
              ^bb2:  // 2 preds: ^bb0, ^bb1
                spv._merge
              }
              %41 = spv.IAdd %17, %0 : i32
              spv.Branch ^bb1(%41 : i32)
            ^bb3:  // pred: ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
            %0 = spv.constant 0.000000e+00 : f32
            %1 = spv.constant 2048 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 0 : i32
            %4 = spv.constant 64 : i32
            %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %7 = spv.Load "Input" %6 : vector<3xi32>
            %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
            %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
            %10 = spv.Load "Input" %9 : vector<3xi32>
            %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
            %12 = spv.IMul %8, %2 : i32
            %13 = spv.IAdd %12, %11 : i32
            %14 = spv.SLessThan %13, %1 : i32
            spv.selection {
              spv.BranchConditional %14, ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              %15 = spv.SDiv %13, %4 : i32
              %16 = spv.GLSL.SAbs %13 : i32
              %17 = spv.GLSL.SAbs %4 : i32
              %18 = spv.UMod %16, %17 : i32
              %19 = spv.IEqual %13, %16 : i32
              %20 = spv.SNegate %18 : i32
              %21 = spv.Select %19, %18, %20 : i1, i32
              %22 = spv.IMul %15, %4 : i32
              %23 = spv.IAdd %22, %21 : i32
              %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
              spv.Store "StorageBuffer" %24, %0 : f32
              spv.Branch ^bb2
            ^bb2:  // 2 preds: ^bb0, ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c2048 = constant 2048 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    hal.ex.defer_release %buffer : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
    %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
    %c0 = constant 0 : index
    %c32_0 = constant 32 : index
    %c1024 = constant 1024 : index
    %allocator_1 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_2 = hal.allocator.compute_size %allocator_1, shape = [%c32_0, %c1024], element_type = 50331680
    %c1024_3 = constant 1024 : index
    %c64_4 = constant 64 : index
    %allocator_5 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_6 = hal.allocator.compute_size %allocator_5, shape = [%c1024_3, %c64_4], element_type = 50331680
    %c32_7 = constant 32 : index
    %c64_8 = constant 64 : index
    %allocator_9 = hal.buffer.allocator %buffer : !hal.allocator
    %sz_10 = hal.allocator.compute_size %allocator_9, shape = [%c32_7, %c64_8], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_2), 1 = (%arg1, %c0, %sz_6), 2 = (%buffer, %c0, %sz_10)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
      %c32_11 = constant 32 : index
      %c1 = constant 1 : index
      %c1_12 = constant 1 : index
      %c32_13 = constant 32 : index
      %c64_14 = constant 64 : index
      %c1_15 = constant 1 : index
      %0 = muli %c1_15, %c32_13 : index
      %1 = muli %0, %c64_14 : index
      %2 = subi %c32_11, %c1_15 : index
      %3 = addi %1, %2 : index
      %4 = divi_signed %3, %c32_11 : index
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%4, %c1_15, %c1_15]
      %memory_barrier_16 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
      hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_16]
      %c8 = constant 8 : index
      %c8_17 = constant 8 : index
      %c1_18 = constant 1 : index
      %c32_19 = constant 32 : index
      %c64_20 = constant 64 : index
      %c1_21 = constant 1 : index
      %5 = subi %c8, %c1_21 : index
      %6 = addi %c64_20, %5 : index
      %7 = divi_signed %6, %c8 : index
      %8 = subi %c8_17, %c1_21 : index
      %9 = addi %c32_19, %8 : index
      %10 = divi_signed %9, %c8_17 : index
      %11 = subi %c1_18, %c1_21 : index
      %12 = addi %c1_21, %11 : index
      %13 = divi_signed %12, %c1_18 : index
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%7, %10, %13]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
}

```
### IR Dump After mlir::iree_compiler::Shape::{anonymous}::ExpandFunctionRankedShapeDimsPass
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  %c0 = constant 0 : index
  %c32_0 = constant 32 : index
  %c1024 = constant 1024 : index
  %allocator_1 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_2 = hal.allocator.compute_size %allocator_1, shape = [%c32_0, %c1024], element_type = 50331680
  %c1024_3 = constant 1024 : index
  %c64_4 = constant 64 : index
  %allocator_5 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_6 = hal.allocator.compute_size %allocator_5, shape = [%c1024_3, %c64_4], element_type = 50331680
  %c32_7 = constant 32 : index
  %c64_8 = constant 64 : index
  %allocator_9 = hal.buffer.allocator %buffer : !hal.allocator
  %sz_10 = hal.allocator.compute_size %allocator_9, shape = [%c32_7, %c64_8], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_2), 1 = (%arg1, %c0, %sz_6), 2 = (%buffer, %c0, %sz_10)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
    %c32_11 = constant 32 : index
    %c1 = constant 1 : index
    %c1_12 = constant 1 : index
    %c32_13 = constant 32 : index
    %c64_14 = constant 64 : index
    %c1_15 = constant 1 : index
    %0 = muli %c1_15, %c32_13 : index
    %1 = muli %0, %c64_14 : index
    %2 = subi %c32_11, %c1_15 : index
    %3 = addi %1, %2 : index
    %4 = divi_signed %3, %c32_11 : index
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%4, %c1_15, %c1_15]
    %memory_barrier_16 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_16]
    %c8 = constant 8 : index
    %c8_17 = constant 8 : index
    %c1_18 = constant 1 : index
    %c32_19 = constant 32 : index
    %c64_20 = constant 64 : index
    %c1_21 = constant 1 : index
    %5 = subi %c8, %c1_21 : index
    %6 = addi %c64_20, %5 : index
    %7 = divi_signed %6, %c8 : index
    %8 = subi %c8_17, %c1_21 : index
    %9 = addi %c32_19, %8 : index
    %10 = divi_signed %9, %c8_17 : index
    %11 = subi %c1_18, %c1_21 : index
    %12 = addi %c1_21, %11 : index
    %13 = divi_signed %12, %c1_18 : index
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%7, %10, %13]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
  %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
  %sz_4 = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz_4)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
    %c64_5 = constant 64 : index
    %c8 = constant 8 : index
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%c64_5, %c1, %c1]
    %memory_barrier_6 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_6]
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After CSE
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export, iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
  %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
    %c64_4 = constant 64 : index
    %c8 = constant 8 : index
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
    %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_5]
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::{anonymous}::PublicABIGenerationPass
```

module {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vulkan_spirv, filter="vulkan*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
        spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
          spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
            %0 = spv.constant 4 : i32
            %1 = spv.constant -1 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 8 : i32
            %4 = spv.constant -8 : i32
            %5 = spv.constant 1 : i32
            %6 = spv.constant 1024 : i32
            %7 = spv.constant 0 : i32
            %8 = spv.constant 64 : i32
            %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
            %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
            %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %13 = spv.Load "Input" %12 : vector<3xi32>
            %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
            %15 = spv.Load "Input" %12 : vector<3xi32>
            %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
            spv.loop {
              spv.Branch ^bb1(%7 : i32)
            ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
              %18 = spv.SLessThan %17, %6 : i32
              spv.BranchConditional %18, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %19 = spv.IMul %16, %3 : i32
              %20 = spv.IMul %16, %4 : i32
              %21 = spv.IAdd %20, %2 : i32
              %22 = spv.SLessThan %3, %21 : i32
              %23 = spv.Select %22, %3, %21 : i1, i32
              %24 = spv.IMul %17, %1 : i32
              %25 = spv.IAdd %24, %6 : i32
              %26 = spv.SLessThan %0, %25 : i32
              %27 = spv.Select %26, %0, %25 : i1, i32
              %28 = spv.IMul %14, %3 : i32
              %29 = spv.IMul %14, %4 : i32
              %30 = spv.IAdd %29, %8 : i32
              %31 = spv.SLessThan %3, %30 : i32
              %32 = spv.Select %31, %3, %30 : i1, i32
              %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
              %34 = spv.Load "Input" %33 : vector<3xi32>
              %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
              %36 = spv.Load "Input" %33 : vector<3xi32>
              %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
              %38 = spv.SLessThan %37, %23 : i32
              %39 = spv.SLessThan %35, %32 : i32
              %40 = spv.LogicalAnd %38, %39 : i1
              spv.selection {
                spv.BranchConditional %40, ^bb1, ^bb2
              ^bb1:  // pred: ^bb0
                spv.loop {
                  spv.Branch ^bb1(%7 : i32)
                ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
                  %43 = spv.SLessThan %42, %27 : i32
                  spv.BranchConditional %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = spv.IAdd %19, %37 : i32
                  %45 = spv.IAdd %17, %42 : i32
                  %46 = spv.IMul %44, %6 : i32
                  %47 = spv.IAdd %46, %45 : i32
                  %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %49 = spv.Load "StorageBuffer" %48 : f32
                  %50 = spv.IAdd %28, %35 : i32
                  %51 = spv.IMul %45, %8 : i32
                  %52 = spv.IAdd %51, %50 : i32
                  %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %54 = spv.Load "StorageBuffer" %53 : f32
                  %55 = spv.IMul %44, %8 : i32
                  %56 = spv.IAdd %55, %50 : i32
                  %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %58 = spv.Load "StorageBuffer" %57 : f32
                  %59 = spv.FMul %49, %54 : f32
                  %60 = spv.FAdd %58, %59 : f32
                  spv.Store "StorageBuffer" %57, %60 : f32
                  %61 = spv.IAdd %42, %5 : i32
                  spv.Branch ^bb1(%61 : i32)
                ^bb3:  // pred: ^bb1
                  spv._merge
                }
                spv.Branch ^bb2
              ^bb2:  // 2 preds: ^bb0, ^bb1
                spv._merge
              }
              %41 = spv.IAdd %17, %0 : i32
              spv.Branch ^bb1(%41 : i32)
            ^bb3:  // pred: ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
            %0 = spv.constant 0.000000e+00 : f32
            %1 = spv.constant 2048 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 0 : i32
            %4 = spv.constant 64 : i32
            %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %7 = spv.Load "Input" %6 : vector<3xi32>
            %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
            %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
            %10 = spv.Load "Input" %9 : vector<3xi32>
            %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
            %12 = spv.IMul %8, %2 : i32
            %13 = spv.IAdd %12, %11 : i32
            %14 = spv.SLessThan %13, %1 : i32
            spv.selection {
              spv.BranchConditional %14, ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              %15 = spv.SDiv %13, %4 : i32
              %16 = spv.GLSL.SAbs %13 : i32
              %17 = spv.GLSL.SAbs %4 : i32
              %18 = spv.UMod %16, %17 : i32
              %19 = spv.IEqual %13, %16 : i32
              %20 = spv.SNegate %18 : i32
              %21 = spv.Select %19, %18, %20 : i1, i32
              %22 = spv.IMul %15, %4 : i32
              %23 = spv.IAdd %22, %21 : i32
              %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
              spv.Store "StorageBuffer" %24, %0 : f32
              spv.Branch ^bb2
            ^bb2:  // 2 preds: ^bb0, ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    hal.ex.defer_release %buffer : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
    %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
    %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
    %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
      %c64_4 = constant 64 : index
      %c8 = constant 8 : index
      %c4 = constant 4 : index
      %c1 = constant 1 : index
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
      %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
      hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_5]
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::ResolveEntryPointOrdinalsPass
```

module {
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vulkan_spirv, filter="vulkan*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
        spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
          spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
            %0 = spv.constant 4 : i32
            %1 = spv.constant -1 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 8 : i32
            %4 = spv.constant -8 : i32
            %5 = spv.constant 1 : i32
            %6 = spv.constant 1024 : i32
            %7 = spv.constant 0 : i32
            %8 = spv.constant 64 : i32
            %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
            %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
            %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %13 = spv.Load "Input" %12 : vector<3xi32>
            %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
            %15 = spv.Load "Input" %12 : vector<3xi32>
            %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
            spv.loop {
              spv.Branch ^bb1(%7 : i32)
            ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
              %18 = spv.SLessThan %17, %6 : i32
              spv.BranchConditional %18, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %19 = spv.IMul %16, %3 : i32
              %20 = spv.IMul %16, %4 : i32
              %21 = spv.IAdd %20, %2 : i32
              %22 = spv.SLessThan %3, %21 : i32
              %23 = spv.Select %22, %3, %21 : i1, i32
              %24 = spv.IMul %17, %1 : i32
              %25 = spv.IAdd %24, %6 : i32
              %26 = spv.SLessThan %0, %25 : i32
              %27 = spv.Select %26, %0, %25 : i1, i32
              %28 = spv.IMul %14, %3 : i32
              %29 = spv.IMul %14, %4 : i32
              %30 = spv.IAdd %29, %8 : i32
              %31 = spv.SLessThan %3, %30 : i32
              %32 = spv.Select %31, %3, %30 : i1, i32
              %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
              %34 = spv.Load "Input" %33 : vector<3xi32>
              %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
              %36 = spv.Load "Input" %33 : vector<3xi32>
              %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
              %38 = spv.SLessThan %37, %23 : i32
              %39 = spv.SLessThan %35, %32 : i32
              %40 = spv.LogicalAnd %38, %39 : i1
              spv.selection {
                spv.BranchConditional %40, ^bb1, ^bb2
              ^bb1:  // pred: ^bb0
                spv.loop {
                  spv.Branch ^bb1(%7 : i32)
                ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
                  %43 = spv.SLessThan %42, %27 : i32
                  spv.BranchConditional %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = spv.IAdd %19, %37 : i32
                  %45 = spv.IAdd %17, %42 : i32
                  %46 = spv.IMul %44, %6 : i32
                  %47 = spv.IAdd %46, %45 : i32
                  %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %49 = spv.Load "StorageBuffer" %48 : f32
                  %50 = spv.IAdd %28, %35 : i32
                  %51 = spv.IMul %45, %8 : i32
                  %52 = spv.IAdd %51, %50 : i32
                  %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %54 = spv.Load "StorageBuffer" %53 : f32
                  %55 = spv.IMul %44, %8 : i32
                  %56 = spv.IAdd %55, %50 : i32
                  %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %58 = spv.Load "StorageBuffer" %57 : f32
                  %59 = spv.FMul %49, %54 : f32
                  %60 = spv.FAdd %58, %59 : f32
                  spv.Store "StorageBuffer" %57, %60 : f32
                  %61 = spv.IAdd %42, %5 : i32
                  spv.Branch ^bb1(%61 : i32)
                ^bb3:  // pred: ^bb1
                  spv._merge
                }
                spv.Branch ^bb2
              ^bb2:  // 2 preds: ^bb0, ^bb1
                spv._merge
              }
              %41 = spv.IAdd %17, %0 : i32
              spv.Branch ^bb1(%41 : i32)
            ^bb3:  // pred: ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
            %0 = spv.constant 0.000000e+00 : f32
            %1 = spv.constant 2048 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 0 : i32
            %4 = spv.constant 64 : i32
            %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %7 = spv.Load "Input" %6 : vector<3xi32>
            %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
            %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
            %10 = spv.Load "Input" %9 : vector<3xi32>
            %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
            %12 = spv.IMul %8, %2 : i32
            %13 = spv.IAdd %12, %11 : i32
            %14 = spv.SLessThan %13, %1 : i32
            spv.selection {
              spv.BranchConditional %14, ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              %15 = spv.SDiv %13, %4 : i32
              %16 = spv.GLSL.SAbs %13 : i32
              %17 = spv.GLSL.SAbs %4 : i32
              %18 = spv.UMod %16, %17 : i32
              %19 = spv.IEqual %13, %16 : i32
              %20 = spv.SNegate %18 : i32
              %21 = spv.Select %19, %18, %20 : i1, i32
              %22 = spv.IMul %15, %4 : i32
              %23 = spv.IAdd %22, %21 : i32
              %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
              spv.Store "StorageBuffer" %24, %0 : f32
              spv.Branch ^bb2
            ^bb2:  // 2 preds: ^bb0, ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    hal.ex.defer_release %buffer : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
    %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
    %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
    %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
      %c64_4 = constant 64 : index
      %c8 = constant 8 : index
      %c4 = constant 4 : index
      %c1 = constant 1 : index
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
      %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
      hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_5]
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
  %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
    %c64_4 = constant 64 : index
    %c8 = constant 8 : index
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
    %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_5]
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After CSE
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %exe = hal.executable.lookup %dev, @dot_ex_dispatch_0 : !hal.executable
  %executable_layout = hal.executable_layout.lookup %dev, set_layouts = [[#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">]] : !hal.executable_layout
  %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
  %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %executable_layout, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
  hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %exe : !hal.executable) {
    %c64_4 = constant 64 : index
    %c8 = constant 8 : index
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
    %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_5]
    hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
    hal.return
  }
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After Canonicalizer
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After Canonicalizer
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::MaterializeResourceCachesPass
```

module {
  hal.variable @_executable_dot_ex_dispatch_0 mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func @_executable_layout_0_initializer() -> !hal.executable_layout attributes {sym_visibility = "private"} {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func @_executable_cache_initializer() -> !hal.executable_cache attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %executable_dot_ex_dispatch_0 = hal.executable_cache.prepare %executable_cache_default, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @dot_ex_dispatch_0 : !hal.executable
    hal.variable.store %executable_dot_ex_dispatch_0, @_executable_dot_ex_dispatch_0 : !hal.executable
    return %executable_cache_default : !hal.executable_cache
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vulkan_spirv, filter="vulkan*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
        spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
          spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
            %0 = spv.constant 4 : i32
            %1 = spv.constant -1 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 8 : i32
            %4 = spv.constant -8 : i32
            %5 = spv.constant 1 : i32
            %6 = spv.constant 1024 : i32
            %7 = spv.constant 0 : i32
            %8 = spv.constant 64 : i32
            %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
            %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
            %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %13 = spv.Load "Input" %12 : vector<3xi32>
            %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
            %15 = spv.Load "Input" %12 : vector<3xi32>
            %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
            spv.loop {
              spv.Branch ^bb1(%7 : i32)
            ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
              %18 = spv.SLessThan %17, %6 : i32
              spv.BranchConditional %18, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %19 = spv.IMul %16, %3 : i32
              %20 = spv.IMul %16, %4 : i32
              %21 = spv.IAdd %20, %2 : i32
              %22 = spv.SLessThan %3, %21 : i32
              %23 = spv.Select %22, %3, %21 : i1, i32
              %24 = spv.IMul %17, %1 : i32
              %25 = spv.IAdd %24, %6 : i32
              %26 = spv.SLessThan %0, %25 : i32
              %27 = spv.Select %26, %0, %25 : i1, i32
              %28 = spv.IMul %14, %3 : i32
              %29 = spv.IMul %14, %4 : i32
              %30 = spv.IAdd %29, %8 : i32
              %31 = spv.SLessThan %3, %30 : i32
              %32 = spv.Select %31, %3, %30 : i1, i32
              %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
              %34 = spv.Load "Input" %33 : vector<3xi32>
              %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
              %36 = spv.Load "Input" %33 : vector<3xi32>
              %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
              %38 = spv.SLessThan %37, %23 : i32
              %39 = spv.SLessThan %35, %32 : i32
              %40 = spv.LogicalAnd %38, %39 : i1
              spv.selection {
                spv.BranchConditional %40, ^bb1, ^bb2
              ^bb1:  // pred: ^bb0
                spv.loop {
                  spv.Branch ^bb1(%7 : i32)
                ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
                  %43 = spv.SLessThan %42, %27 : i32
                  spv.BranchConditional %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = spv.IAdd %19, %37 : i32
                  %45 = spv.IAdd %17, %42 : i32
                  %46 = spv.IMul %44, %6 : i32
                  %47 = spv.IAdd %46, %45 : i32
                  %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %49 = spv.Load "StorageBuffer" %48 : f32
                  %50 = spv.IAdd %28, %35 : i32
                  %51 = spv.IMul %45, %8 : i32
                  %52 = spv.IAdd %51, %50 : i32
                  %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %54 = spv.Load "StorageBuffer" %53 : f32
                  %55 = spv.IMul %44, %8 : i32
                  %56 = spv.IAdd %55, %50 : i32
                  %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %58 = spv.Load "StorageBuffer" %57 : f32
                  %59 = spv.FMul %49, %54 : f32
                  %60 = spv.FAdd %58, %59 : f32
                  spv.Store "StorageBuffer" %57, %60 : f32
                  %61 = spv.IAdd %42, %5 : i32
                  spv.Branch ^bb1(%61 : i32)
                ^bb3:  // pred: ^bb1
                  spv._merge
                }
                spv.Branch ^bb2
              ^bb2:  // 2 preds: ^bb0, ^bb1
                spv._merge
              }
              %41 = spv.IAdd %17, %0 : i32
              spv.Branch ^bb1(%41 : i32)
            ^bb3:  // pred: ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
            %0 = spv.constant 0.000000e+00 : f32
            %1 = spv.constant 2048 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 0 : i32
            %4 = spv.constant 64 : i32
            %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %7 = spv.Load "Input" %6 : vector<3xi32>
            %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
            %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
            %10 = spv.Load "Input" %9 : vector<3xi32>
            %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
            %12 = spv.IMul %8, %2 : i32
            %13 = spv.IAdd %12, %11 : i32
            %14 = spv.SLessThan %13, %1 : i32
            spv.selection {
              spv.BranchConditional %14, ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              %15 = spv.SDiv %13, %4 : i32
              %16 = spv.GLSL.SAbs %13 : i32
              %17 = spv.GLSL.SAbs %4 : i32
              %18 = spv.UMod %16, %17 : i32
              %19 = spv.IEqual %13, %16 : i32
              %20 = spv.SNegate %18 : i32
              %21 = spv.Select %19, %18, %20 : i1, i32
              %22 = spv.IMul %15, %4 : i32
              %23 = spv.IAdd %22, %21 : i32
              %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
              spv.Store "StorageBuffer" %24, %0 : f32
              spv.Branch ^bb2
            ^bb2:  // 2 preds: ^bb0, ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    hal.ex.defer_release %buffer : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
    %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %1, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
    hal.device.switch(%dev : !hal.device)
    #hal.device.match.id<"vulkan*">(%arg2 = %c2048 : index, %arg3 = %cmd : !hal.command_buffer, %arg4 = %0 : !hal.executable) {
      %c64_4 = constant 64 : index
      %c8 = constant 8 : index
      %c4 = constant 4 : index
      %c1 = constant 1 : index
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
      %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
      hal.command_buffer.execution_barrier %arg3, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier_5]
      hal.command_buffer.dispatch %arg3, %arg4, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
      hal.return
    }
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @_executable_layout_0_initializer() -> !hal.executable_layout attributes {sym_visibility = "private"} {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %dev = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @_executable_cache_initializer() -> !hal.executable_cache attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
  %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %executable_dot_ex_dispatch_0 = hal.executable_cache.prepare %executable_cache_default, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @dot_ex_dispatch_0 : !hal.executable
  hal.variable.store %executable_dot_ex_dispatch_0, @_executable_dot_ex_dispatch_0 : !hal.executable
  return %executable_cache_default : !hal.executable_cache
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
  %c2048 = constant 2048 : index
  %c0 = constant 0 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %0 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
  %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %1, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
  %2 = hal.device.match.id %dev, pattern = ["vulkan*"] : (!hal.device) -> i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %c64_4 = constant 64 : index
  %c8 = constant 8 : index
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  hal.command_buffer.dispatch %cmd, %0, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.dispatch %cmd, %0, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
  br ^bb3
^bb2:  // pred: ^bb0
  iree.unreachable
^bb3:  // pred: ^bb1
  %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier_5]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::InlineDeviceSwitchesPass
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::MemoizeDeviceQueriesPass
```

module {
  func @_device_match_id_0_initializer() -> i1 attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id %dev, pattern = ["vulkan*"] : (!hal.device) -> i1
    return %0 : i1
  }
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  hal.variable @_executable_dot_ex_dispatch_0 mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func @_executable_layout_0_initializer() -> !hal.executable_layout attributes {sym_visibility = "private"} {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func @_executable_cache_initializer() -> !hal.executable_cache attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %executable_dot_ex_dispatch_0 = hal.executable_cache.prepare %executable_cache_default, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @dot_ex_dispatch_0 : !hal.executable
    hal.variable.store %executable_dot_ex_dispatch_0, @_executable_dot_ex_dispatch_0 : !hal.executable
    return %executable_cache_default : !hal.executable_cache
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.target @vulkan_spirv, filter="vulkan*" {
      hal.executable.entry_point @dot_ex_dispatch_0 attributes {interface = @legacy_io, ordinal = 0 : i32, signature = (tensor<32x1024xf32>, tensor<1024x64xf32>) -> tensor<32x64xf32>}
      module attributes {spv.target_env = #spv.target_env<#spv.vce<v1.3, [Shader], [SPV_KHR_storage_buffer_storage_class]>, {max_compute_workgroup_invocations = 128 : i32, max_compute_workgroup_size = dense<[128, 128, 64]> : vector<3xi32>}>, vkspv.entry_point_schedule = ["dot_ex_dispatch_0_dispatch_0", "dot_ex_dispatch_0_dispatch_1"]} {
        spv.module Logical GLSL450 requires #spv.vce<v1.0, [Shader], [SPV_KHR_storage_buffer_storage_class]> {
          spv.globalVariable @__builtin_var_LocalInvocationId__ built_in("LocalInvocationId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__builtin_var_WorkgroupId__ built_in("WorkgroupId") : !spv.ptr<vector<3xi32>, Input>
          spv.globalVariable @__resource_var_0_1__ bind(0, 1) : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_0__ bind(0, 0) : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
          spv.globalVariable @__resource_var_0_2__ bind(0, 2) : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
          spv.func @dot_ex_dispatch_0_dispatch_1() "None" attributes {vkspv.workgroup_count_from_result_shape = 2 : i32} {
            %0 = spv.constant 4 : i32
            %1 = spv.constant -1 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 8 : i32
            %4 = spv.constant -8 : i32
            %5 = spv.constant 1 : i32
            %6 = spv.constant 1024 : i32
            %7 = spv.constant 0 : i32
            %8 = spv.constant 64 : i32
            %9 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %10 = spv._address_of @__resource_var_0_0__ : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>
            %11 = spv._address_of @__resource_var_0_1__ : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>
            %12 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %13 = spv.Load "Input" %12 : vector<3xi32>
            %14 = spv.CompositeExtract %13[0 : i32] : vector<3xi32>
            %15 = spv.Load "Input" %12 : vector<3xi32>
            %16 = spv.CompositeExtract %15[1 : i32] : vector<3xi32>
            spv.loop {
              spv.Branch ^bb1(%7 : i32)
            ^bb1(%17: i32):  // 2 preds: ^bb0, ^bb2
              %18 = spv.SLessThan %17, %6 : i32
              spv.BranchConditional %18, ^bb2, ^bb3
            ^bb2:  // pred: ^bb1
              %19 = spv.IMul %16, %3 : i32
              %20 = spv.IMul %16, %4 : i32
              %21 = spv.IAdd %20, %2 : i32
              %22 = spv.SLessThan %3, %21 : i32
              %23 = spv.Select %22, %3, %21 : i1, i32
              %24 = spv.IMul %17, %1 : i32
              %25 = spv.IAdd %24, %6 : i32
              %26 = spv.SLessThan %0, %25 : i32
              %27 = spv.Select %26, %0, %25 : i1, i32
              %28 = spv.IMul %14, %3 : i32
              %29 = spv.IMul %14, %4 : i32
              %30 = spv.IAdd %29, %8 : i32
              %31 = spv.SLessThan %3, %30 : i32
              %32 = spv.Select %31, %3, %30 : i1, i32
              %33 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
              %34 = spv.Load "Input" %33 : vector<3xi32>
              %35 = spv.CompositeExtract %34[0 : i32] : vector<3xi32>
              %36 = spv.Load "Input" %33 : vector<3xi32>
              %37 = spv.CompositeExtract %36[1 : i32] : vector<3xi32>
              %38 = spv.SLessThan %37, %23 : i32
              %39 = spv.SLessThan %35, %32 : i32
              %40 = spv.LogicalAnd %38, %39 : i1
              spv.selection {
                spv.BranchConditional %40, ^bb1, ^bb2
              ^bb1:  // pred: ^bb0
                spv.loop {
                  spv.Branch ^bb1(%7 : i32)
                ^bb1(%42: i32):  // 2 preds: ^bb0, ^bb2
                  %43 = spv.SLessThan %42, %27 : i32
                  spv.BranchConditional %43, ^bb2, ^bb3
                ^bb2:  // pred: ^bb1
                  %44 = spv.IAdd %19, %37 : i32
                  %45 = spv.IAdd %17, %42 : i32
                  %46 = spv.IMul %44, %6 : i32
                  %47 = spv.IAdd %46, %45 : i32
                  %48 = spv.AccessChain %10[%7, %47] : !spv.ptr<!spv.struct<!spv.array<32768 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %49 = spv.Load "StorageBuffer" %48 : f32
                  %50 = spv.IAdd %28, %35 : i32
                  %51 = spv.IMul %45, %8 : i32
                  %52 = spv.IAdd %51, %50 : i32
                  %53 = spv.AccessChain %11[%7, %52] : !spv.ptr<!spv.struct<!spv.array<65536 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %54 = spv.Load "StorageBuffer" %53 : f32
                  %55 = spv.IMul %44, %8 : i32
                  %56 = spv.IAdd %55, %50 : i32
                  %57 = spv.AccessChain %9[%7, %56] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
                  %58 = spv.Load "StorageBuffer" %57 : f32
                  %59 = spv.FMul %49, %54 : f32
                  %60 = spv.FAdd %58, %59 : f32
                  spv.Store "StorageBuffer" %57, %60 : f32
                  %61 = spv.IAdd %42, %5 : i32
                  spv.Branch ^bb1(%61 : i32)
                ^bb3:  // pred: ^bb1
                  spv._merge
                }
                spv.Branch ^bb2
              ^bb2:  // 2 preds: ^bb0, ^bb1
                spv._merge
              }
              %41 = spv.IAdd %17, %0 : i32
              spv.Branch ^bb1(%41 : i32)
            ^bb3:  // pred: ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.func @dot_ex_dispatch_0_dispatch_0() "None" attributes {vkspv.workgroup_count_from_result_shape = 1 : i32} {
            %0 = spv.constant 0.000000e+00 : f32
            %1 = spv.constant 2048 : i32
            %2 = spv.constant 32 : i32
            %3 = spv.constant 0 : i32
            %4 = spv.constant 64 : i32
            %5 = spv._address_of @__resource_var_0_2__ : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>
            %6 = spv._address_of @__builtin_var_WorkgroupId__ : !spv.ptr<vector<3xi32>, Input>
            %7 = spv.Load "Input" %6 : vector<3xi32>
            %8 = spv.CompositeExtract %7[0 : i32] : vector<3xi32>
            %9 = spv._address_of @__builtin_var_LocalInvocationId__ : !spv.ptr<vector<3xi32>, Input>
            %10 = spv.Load "Input" %9 : vector<3xi32>
            %11 = spv.CompositeExtract %10[0 : i32] : vector<3xi32>
            %12 = spv.IMul %8, %2 : i32
            %13 = spv.IAdd %12, %11 : i32
            %14 = spv.SLessThan %13, %1 : i32
            spv.selection {
              spv.BranchConditional %14, ^bb1, ^bb2
            ^bb1:  // pred: ^bb0
              %15 = spv.SDiv %13, %4 : i32
              %16 = spv.GLSL.SAbs %13 : i32
              %17 = spv.GLSL.SAbs %4 : i32
              %18 = spv.UMod %16, %17 : i32
              %19 = spv.IEqual %13, %16 : i32
              %20 = spv.SNegate %18 : i32
              %21 = spv.Select %19, %18, %20 : i1, i32
              %22 = spv.IMul %15, %4 : i32
              %23 = spv.IAdd %22, %21 : i32
              %24 = spv.AccessChain %5[%3, %23] : !spv.ptr<!spv.struct<!spv.array<2048 x f32, stride=4> [0]>, StorageBuffer>, i32, i32
              spv.Store "StorageBuffer" %24, %0 : f32
              spv.Branch ^bb2
            ^bb2:  // 2 preds: ^bb0, ^bb1
              spv._merge
            }
            spv.Return
          }
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_1, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_1 "LocalSize", 8, 8, 1
          spv.EntryPoint "GLCompute" @dot_ex_dispatch_0_dispatch_0, @__builtin_var_WorkgroupId__, @__builtin_var_LocalInvocationId__
          spv.ExecutionMode @dot_ex_dispatch_0_dispatch_0 "LocalSize", 32, 1, 1
        }
        hal.interface @legacy_io attributes {sym_visibility = "private"} {
          hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
          hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
          hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
        }
      }
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
    %c2048 = constant 2048 : index
    %c0 = constant 0 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    hal.ex.defer_release %buffer : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
    %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %1, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %c64_4 = constant 64 : index
    %c8 = constant 8 : index
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    hal.command_buffer.dispatch %cmd, %0, entry_point = 0, workgroup_xyz = [%c64_4, %c1, %c1]
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.dispatch %cmd, %0, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
    br ^bb3
  ^bb2:  // pred: ^bb0
    iree.unreachable
  ^bb3:  // pred: ^bb1
    %memory_barrier_5 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier_5]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After Canonicalizer
```
func @_device_match_id_0_initializer() -> i1 attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id %dev, pattern = ["vulkan*"] : (!hal.device) -> i1
  return %0 : i1
}

```
### IR Dump After CSE
```
func @_device_match_id_0_initializer() -> i1 attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %0 = hal.device.match.id %dev, pattern = ["vulkan*"] : (!hal.device) -> i1
  return %0 : i1
}

```
### IR Dump After Canonicalizer
```
func @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
### IR Dump After CSE
```
func @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
  return %descriptor_set_layout : !hal.descriptor_set_layout
}

```
### IR Dump After Canonicalizer
```
func @_executable_layout_0_initializer() -> !hal.executable_layout attributes {sym_visibility = "private"} {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %dev = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
### IR Dump After CSE
```
func @_executable_layout_0_initializer() -> !hal.executable_layout attributes {sym_visibility = "private"} {
  %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
  %dev = hal.ex.shared_device : !hal.device
  %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
  return %executable_layout : !hal.executable_layout
}

```
### IR Dump After Canonicalizer
```
func @_executable_cache_initializer() -> !hal.executable_cache attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
  %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %executable_dot_ex_dispatch_0 = hal.executable_cache.prepare %executable_cache_default, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @dot_ex_dispatch_0 : !hal.executable
  hal.variable.store %executable_dot_ex_dispatch_0, @_executable_dot_ex_dispatch_0 : !hal.executable
  return %executable_cache_default : !hal.executable_cache
}

```
### IR Dump After CSE
```
func @_executable_cache_initializer() -> !hal.executable_cache attributes {sym_visibility = "private"} {
  %dev = hal.ex.shared_device : !hal.device
  %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
  %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %executable_dot_ex_dispatch_0 = hal.executable_cache.prepare %executable_cache_default, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @dot_ex_dispatch_0 : !hal.executable
  hal.variable.store %executable_dot_ex_dispatch_0, @_executable_dot_ex_dispatch_0 : !hal.executable
  return %executable_cache_default : !hal.executable_cache
}

```
### IR Dump After mlir::iree_compiler::IREE::HAL::SerializeExecutablesPass
```
hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
  hal.interface @legacy_io {
    hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
    hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
    hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
  }
  hal.executable.binary attributes {data = opaque<"", "0xDEADBEEF"> : vector<3092xi8>, format = 1397773893 : i32} {
  }
}

```
### IR Dump After Canonicalizer
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
  %c0 = constant 0 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c8 = constant 8 : index
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %0 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
  %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %1, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  hal.command_buffer.dispatch %cmd, %0, entry_point = 0, workgroup_xyz = [%c64, %c1, %c1]
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.dispatch %cmd, %0, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
  %memory_barrier_4 = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier_4]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable
}

```
### IR Dump After CSE
```
func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
  %c0 = constant 0 : index
  %c1024 = constant 1024 : index
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %c8 = constant 8 : index
  %c4 = constant 4 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %allocator = hal.device.allocator %dev : !hal.allocator
  %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
  %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
  hal.ex.defer_release %buffer : !hal.buffer
  %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
  hal.command_buffer.begin %cmd
  %0 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
  %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
  %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
  %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
  %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
  %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
  hal.command_buffer.push_descriptor_set %cmd, %1, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
  %2 = hal.variable.load @_device_match_id_0 : i1
  cond_br %2, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  hal.command_buffer.dispatch %cmd, %0, entry_point = 0, workgroup_xyz = [%c64, %c1, %c1]
  %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
  hal.command_buffer.execution_barrier %cmd, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.dispatch %cmd, %0, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
  hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
  hal.command_buffer.end %cmd
  hal.ex.submit_and_wait %dev, %cmd
  return %buffer : !hal.buffer
^bb2:  // pred: ^bb0
  iree.unreachable
}

```
### IR Dump After Canonicalizer
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
  %c32 = constant 32 : index
  %c64 = constant 64 : index
  %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
  hal.check_success %0, "semaphore wait failed"
  %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
  %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
  %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
  %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
  hal.semaphore.signal %arg4, value = %arg5
  return %view : !hal.buffer_view
}

```
### IR Dump After Canonicalizer
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After CSE
```
func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
  %c0 = constant 0 : index
  %c1 = constant 1 : index
  %dev = hal.ex.shared_device : !hal.device
  %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
  %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
  %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
  hal.check_success %1, "semaphore wait failed"
  return %0 : !hal.buffer_view
}

```
### IR Dump After SymbolDCE
```

module {
  func @_device_match_id_0_initializer() -> i1 attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id %dev, pattern = ["vulkan*"] : (!hal.device) -> i1
    return %0 : i1
  }
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  hal.variable @_executable_dot_ex_dispatch_0 mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func @_executable_layout_0_initializer() -> !hal.executable_layout attributes {sym_visibility = "private"} {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func @_executable_cache_initializer() -> !hal.executable_cache attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %executable_dot_ex_dispatch_0 = hal.executable_cache.prepare %executable_cache_default, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @dot_ex_dispatch_0 : !hal.executable
    hal.variable.store %executable_dot_ex_dispatch_0, @_executable_dot_ex_dispatch_0 : !hal.executable
    return %executable_cache_default : !hal.executable_cache
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary attributes {data = opaque<"", "0xDEADBEEF"> : vector<3092xi8>, format = 1397773893 : i32} {
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
    %c0 = constant 0 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %c8 = constant 8 : index
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    hal.ex.defer_release %buffer : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
    %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %1, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    hal.command_buffer.dispatch %cmd, %0, entry_point = 0, workgroup_xyz = [%c64, %c1, %c1]
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.dispatch %cmd, %0, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After Canonicalizer
```

module {
  func @_device_match_id_0_initializer() -> i1 attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %0 = hal.device.match.id %dev, pattern = ["vulkan*"] : (!hal.device) -> i1
    return %0 : i1
  }
  hal.variable @_device_match_id_0 init(@_device_match_id_0_initializer) : i1 attributes {sym_visibility = "private"}
  hal.variable @_executable_dot_ex_dispatch_0 mutable : !hal.executable attributes {sym_visibility = "private"}
  hal.variable @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !hal.descriptor_set_layout attributes {sym_visibility = "private"}
  func @_descriptor_set_layout_0_initializer() -> !hal.descriptor_set_layout attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %descriptor_set_layout = hal.descriptor_set_layout.create %dev, "PushOnly", bindings = [#hal.descriptor_set_layout_binding<0, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<1, "StorageBuffer", "Read">, #hal.descriptor_set_layout_binding<2, "StorageBuffer", "Write|Discard">] : !hal.descriptor_set_layout
    return %descriptor_set_layout : !hal.descriptor_set_layout
  }
  hal.variable @_executable_layout_0 init(@_executable_layout_0_initializer) : !hal.executable_layout attributes {sym_visibility = "private"}
  func @_executable_layout_0_initializer() -> !hal.executable_layout attributes {sym_visibility = "private"} {
    %0 = hal.variable.load @_descriptor_set_layout_0 : !hal.descriptor_set_layout
    %dev = hal.ex.shared_device : !hal.device
    %executable_layout = hal.executable_layout.create %dev, set_layouts = [%0], push_constants = 0 : !hal.executable_layout
    return %executable_layout : !hal.executable_layout
  }
  hal.variable @_executable_cache init(@_executable_cache_initializer) : !hal.executable_cache
  func @_executable_cache_initializer() -> !hal.executable_cache attributes {sym_visibility = "private"} {
    %dev = hal.ex.shared_device : !hal.device
    %executable_cache_default = hal.executable_cache.create %dev, identifier = "default" : !hal.executable_cache
    %0 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %executable_dot_ex_dispatch_0 = hal.executable_cache.prepare %executable_cache_default, layout = %0, caching_mode = "AliasProvidedData|AllowPersistentCaching|AllowOptimization", @dot_ex_dispatch_0 : !hal.executable
    hal.variable.store %executable_dot_ex_dispatch_0, @_executable_dot_ex_dispatch_0 : !hal.executable
    return %executable_cache_default : !hal.executable_cache
  }
  hal.executable @dot_ex_dispatch_0 attributes {sym_visibility = "private"} {
    hal.interface @legacy_io {
      hal.interface.binding @arg0, set=0, binding=0, type="StorageBuffer", access="Read"
      hal.interface.binding @arg1, set=0, binding=1, type="StorageBuffer", access="Read"
      hal.interface.binding @ret0, set=0, binding=2, type="StorageBuffer", access="Write|Discard"
    }
    hal.executable.binary attributes {data = opaque<"", "0xDEADBEEF"> : vector<3092xi8>, format = 1397773893 : i32} {
    }
  }
  func @dot(%arg0: !hal.buffer {iree.reflection = {}}, %arg1: !hal.buffer {iree.reflection = {}}) -> (!hal.buffer {iree.reflection = {}}) attributes {iree.module.export = "dot$raw"} {
    %c0 = constant 0 : index
    %c1024 = constant 1024 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %c8 = constant 8 : index
    %c4 = constant 4 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %allocator = hal.device.allocator %dev : !hal.allocator
    %sz = hal.allocator.compute_size %allocator, shape = [%c32, %c64], element_type = 50331680
    %buffer = hal.allocator.allocate %allocator, "HostVisible|DeviceVisible|DeviceLocal", "Constant|Transfer|Mapping|Dispatch", %sz : !hal.buffer
    hal.ex.defer_release %buffer : !hal.buffer
    %cmd = hal.command_buffer.create %dev, "OneShot", "Transfer|Dispatch" : !hal.command_buffer
    hal.command_buffer.begin %cmd
    %0 = hal.variable.load @_executable_dot_ex_dispatch_0 : !hal.executable
    %1 = hal.variable.load @_executable_layout_0 : !hal.executable_layout
    %allocator_0 = hal.buffer.allocator %arg0 : !hal.allocator
    %sz_1 = hal.allocator.compute_size %allocator_0, shape = [%c32, %c1024], element_type = 50331680
    %allocator_2 = hal.buffer.allocator %arg1 : !hal.allocator
    %sz_3 = hal.allocator.compute_size %allocator_2, shape = [%c1024, %c64], element_type = 50331680
    hal.command_buffer.push_descriptor_set %cmd, %1, set=0, bindings=[0 = (%arg0, %c0, %sz_1), 1 = (%arg1, %c0, %sz_3), 2 = (%buffer, %c0, %sz)]
    %2 = hal.variable.load @_device_match_id_0 : i1
    cond_br %2, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    hal.command_buffer.dispatch %cmd, %0, entry_point = 0, workgroup_xyz = [%c64, %c1, %c1]
    %memory_barrier = hal.make_memory_barrier "DispatchWrite", "DispatchRead" : tuple<i32, i32>
    hal.command_buffer.execution_barrier %cmd, "Dispatch", "Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.dispatch %cmd, %0, entry_point = 1, workgroup_xyz = [%c8, %c4, %c1]
    hal.command_buffer.execution_barrier %cmd, "Dispatch|CommandRetire", "CommandIssue|Dispatch", memory_barriers=[%memory_barrier]
    hal.command_buffer.end %cmd
    hal.ex.submit_and_wait %dev, %cmd
    return %buffer : !hal.buffer
  ^bb2:  // pred: ^bb0
    iree.unreachable
  }
  func @dot$async(%arg0: !hal.semaphore, %arg1: index, %arg2: !hal.buffer_view, %arg3: !hal.buffer_view, %arg4: !hal.semaphore, %arg5: index) -> !hal.buffer_view attributes {iree.module.export = "dot$async"} {
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %0 = hal.semaphore.await %arg0, min_value = %arg1 : i32
    hal.check_success %0, "semaphore wait failed"
    %buffer = hal.buffer_view.buffer %arg2 : !hal.buffer
    %buffer_0 = hal.buffer_view.buffer %arg3 : !hal.buffer
    %1 = call @dot(%buffer, %buffer_0) : (!hal.buffer, !hal.buffer) -> !hal.buffer
    %view = hal.buffer_view.create %1, shape = [%c32, %c64], element_type = 50331680 : !hal.buffer_view
    hal.semaphore.signal %arg4, value = %arg5
    return %view : !hal.buffer_view
  }
  func @dot$sync(%arg0: !hal.buffer_view, %arg1: !hal.buffer_view) -> !hal.buffer_view attributes {iree.abi.stub, iree.module.export = "dot", iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %c0 = constant 0 : index
    %c1 = constant 1 : index
    %dev = hal.ex.shared_device : !hal.device
    %semaphore = hal.semaphore.create %dev, initial_value = %c0 : !hal.semaphore
    %0 = call @dot$async(%semaphore, %c0, %arg0, %arg1, %semaphore, %c1) : (!hal.semaphore, index, !hal.buffer_view, !hal.buffer_view, !hal.semaphore, index) -> !hal.buffer_view
    %1 = hal.semaphore.await %semaphore, min_value = %c1 : i32
    hal.check_success %1, "semaphore wait failed"
    return %0 : !hal.buffer_view
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::VM::ConversionPass
```

module {
  vm.module @module {
    vm.rodata @_utf8_vulkan_7197BF52A22CAFD7 dense<[118, 117, 108, 107, 97, 110, 42]> : vector<7xi8>
    vm.func @_device_match_id_0_initializer() -> i32 attributes {sym_visibility = "private"} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vulkan_7197BF52A22CAFD7 = vm.const.ref.rodata @_utf8_vulkan_7197BF52A22CAFD7 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vulkan_7197BF52A22CAFD7) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.return %0 : i32
    }
    vm.global.i32 @_device_match_id_0 init(@_device_match_id_0_initializer) : i32
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 init(@_descriptor_set_layout_0_initializer) : !vm.ref<!hal.descriptor_set_layout>
    vm.func @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> attributes {sym_visibility = "private"} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %c1 = vm.const.i32 1 : i32
      %zero = vm.const.i32.zero : i32
      %c7 = vm.const.i32 7 : i32
      %c1_0 = vm.const.i32 1 : i32
      %c1_1 = vm.const.i32 1 : i32
      %c7_2 = vm.const.i32 7 : i32
      %c1_3 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c7_4 = vm.const.i32 7 : i32
      %c6 = vm.const.i32 6 : i32
      %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
    }
    vm.global.ref @_executable_layout_0 init(@_executable_layout_0_initializer) : !vm.ref<!hal.executable_layout>
    vm.func @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> attributes {sym_visibility = "private"} {
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %zero = vm.const.i32.zero : i32
      %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.return %ref_0 : !vm.ref<!hal.executable_layout>
    }
    vm.global.ref @_executable_cache init(@_executable_cache_initializer) : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @_dot_ex_dispatch_0_binary_spirv opaque<"", "0xDEADBEEF"> : vector<3092xi8>
    vm.func @_executable_cache_initializer() -> !vm.ref<!hal.executable_cache> attributes {sym_visibility = "private"} {
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_0 = vm.call @hal.executable_cache.create(%ref, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %c1397773893 = vm.const.i32 1397773893 : i32
      %0 = vm.call.variadic @hal.executable_cache.select_format(%ref_0, [%c1397773893]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_dot_ex_dispatch_0_binary_spirv = vm.const.ref.rodata @_dot_ex_dispatch_0_binary_spirv : !vm.ref<!iree.byte_buffer>
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %ref_1 = vm.switch.ref %0[%_dot_ex_dispatch_0_binary_spirv] else %null : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %ref_2 = vm.call @hal.executable_cache.prepare(%ref_0, %_executable_layout_0, %c7, %ref_1) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_2, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.return %ref_0 : !vm.ref<!hal.executable_cache>
    }
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> {
      %zero = vm.const.i32.zero : i32
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call.variadic @hal.allocator.compute_size(%ref_0, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %0) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_1) : (!vm.ref<!hal.buffer>) -> ()
      %c1_2 = vm.const.i32 1 : i32
      %c3 = vm.const.i32 3 : i32
      %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.buffer.allocator(%arg0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %c50331680_5 = vm.const.i32 50331680 : i32
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c32, %c1024], %c50331680_5) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_6 = vm.call @hal.buffer.allocator(%arg1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %c50331680_7 = vm.const.i32 50331680 : i32
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_6, [%c1024, %c64], %c50331680_7) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %zero_8 = vm.const.i32.zero : i32
      %zero_9 = vm.const.i32.zero : i32
      %c1_10 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero_8, [%zero_9, %c1_10, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%1, %2, %0]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      %zero_11 = vm.const.i32.zero : i32
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_dot_ex_dispatch_0, %zero_11, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c4_12 = vm.const.i32 4 : i32
      %c4_13 = vm.const.i32 4 : i32
      %c8_14 = vm.const.i32 8 : i32
      %c4_15 = vm.const.i32 4 : i32
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_3, %c4_12, %c4_13, [%c8_14], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      %c1_16 = vm.const.i32 1 : i32
      vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_dot_ex_dispatch_0, %c1_16, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8_17 = vm.const.i32 8 : i32
      %c4_18 = vm.const.i32 4 : i32
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, [%c8_17], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      %c2_19 = vm.const.i32 2 : i32
      vm.fail %c2_19, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
      %c50331680 = vm.const.i32 50331680 : i32
      %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_2 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
      %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_fail %0, "semaphore wait failed"
      vm.return %ref_1 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.defer_release(%operand : !vm.ref<?>) attributes {sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.compute_size(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.compute_offset(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.compute_range(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate.const(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %shape : i32 ..., %element_type : i32, %value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::VM::GlobalInitializationPass
```
vm.module @module {
  vm.rodata @_utf8_vulkan_7197BF52A22CAFD7 dense<[118, 117, 108, 107, 97, 110, 42]> : vector<7xi8>
  vm.func @_device_match_id_0_initializer() -> i32 attributes {sym_visibility = "private"} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_vulkan_7197BF52A22CAFD7 = vm.const.ref.rodata @_utf8_vulkan_7197BF52A22CAFD7 : !vm.ref<!iree.byte_buffer>
    %0 = vm.call @hal.device.match.id(%ref, %_utf8_vulkan_7197BF52A22CAFD7) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
    vm.return %0 : i32
  }
  vm.global.i32 @_device_match_id_0 mutable : i32
  vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
  vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
  vm.func @_descriptor_set_layout_0_initializer() -> !vm.ref<!hal.descriptor_set_layout> attributes {sym_visibility = "private"} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %c1 = vm.const.i32 1 : i32
    %zero = vm.const.i32.zero : i32
    %c7 = vm.const.i32 7 : i32
    %c1_0 = vm.const.i32 1 : i32
    %c1_1 = vm.const.i32 1 : i32
    %c7_2 = vm.const.i32 7 : i32
    %c1_3 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    %c7_4 = vm.const.i32 7 : i32
    %c6 = vm.const.i32 6 : i32
    %ref_5 = vm.call.variadic @hal.descriptor_set_layout.create(%ref, %c1, [(%zero, %c7, %c1_0), (%c1_1, %c7_2, %c1_3), (%c2, %c7_4, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
    vm.return %ref_5 : !vm.ref<!hal.descriptor_set_layout>
  }
  vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
  vm.func @_executable_layout_0_initializer() -> !vm.ref<!hal.executable_layout> attributes {sym_visibility = "private"} {
    %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %zero = vm.const.i32.zero : i32
    %ref_0 = vm.call.variadic @hal.executable_layout.create(%ref, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
    vm.return %ref_0 : !vm.ref<!hal.executable_layout>
  }
  vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
  vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
  vm.rodata @_dot_ex_dispatch_0_binary_spirv opaque<"", "0xDEADBEEF"> : vector<3092xi8>
  vm.func @_executable_cache_initializer() -> !vm.ref<!hal.executable_cache> attributes {sym_visibility = "private"} {
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
    %ref_0 = vm.call @hal.executable_cache.create(%ref, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %c1397773893 = vm.const.i32 1397773893 : i32
    %0 = vm.call.variadic @hal.executable_cache.select_format(%ref_0, [%c1397773893]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
    %_dot_ex_dispatch_0_binary_spirv = vm.const.ref.rodata @_dot_ex_dispatch_0_binary_spirv : !vm.ref<!iree.byte_buffer>
    %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
    %ref_1 = vm.switch.ref %0[%_dot_ex_dispatch_0_binary_spirv] else %null : !vm.ref<!iree.byte_buffer>
    %c7 = vm.const.i32 7 : i32
    %ref_2 = vm.call @hal.executable_cache.prepare(%ref_0, %_executable_layout_0, %c7, %ref_1) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
    vm.global.store.ref %ref_2, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
    vm.return %ref_0 : !vm.ref<!hal.executable_cache>
  }
  vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> {
    %zero = vm.const.i32.zero : i32
    %c1024 = vm.const.i32 1024 : i32
    %c32 = vm.const.i32 32 : i32
    %c64 = vm.const.i32 64 : i32
    %c8 = vm.const.i32 8 : i32
    %c4 = vm.const.i32 4 : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
    %c50331680 = vm.const.i32 50331680 : i32
    %0 = vm.call.variadic @hal.allocator.compute_size(%ref_0, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
    %c50 = vm.const.i32 50 : i32
    %c15 = vm.const.i32 15 : i32
    %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %0) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
    vm.call @hal.ex.defer_release(%ref_1) : (!vm.ref<!hal.buffer>) -> ()
    %c1_2 = vm.const.i32 1 : i32
    %c3 = vm.const.i32 3 : i32
    %ref_3 = vm.call @hal.command_buffer.create(%ref, %c1_2, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
    vm.call @hal.command_buffer.begin(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
    %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_4 = vm.call @hal.buffer.allocator(%arg0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
    %c50331680_5 = vm.const.i32 50331680 : i32
    %1 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c32, %c1024], %c50331680_5) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
    %ref_6 = vm.call @hal.buffer.allocator(%arg1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
    %c50331680_7 = vm.const.i32 50331680 : i32
    %2 = vm.call.variadic @hal.allocator.compute_size(%ref_6, [%c1024, %c64], %c50331680_7) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
    %zero_8 = vm.const.i32.zero : i32
    %zero_9 = vm.const.i32.zero : i32
    %c1_10 = vm.const.i32 1 : i32
    %c2 = vm.const.i32 2 : i32
    vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_3, %_executable_layout_0, %zero_8, [%zero_9, %c1_10, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%1, %2, %0]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
    %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
    vm.cond_br %_device_match_id_0, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %zero_11 = vm.const.i32.zero : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_dot_ex_dispatch_0, %zero_11, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c4_12 = vm.const.i32 4 : i32
    %c4_13 = vm.const.i32 4 : i32
    %c8_14 = vm.const.i32 8 : i32
    %c4_15 = vm.const.i32 4 : i32
    vm.call.variadic @hal.command_buffer.execution_barrier(%ref_3, %c4_12, %c4_13, [%c8_14], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
    %c1_16 = vm.const.i32 1 : i32
    vm.call @hal.command_buffer.dispatch(%ref_3, %_executable_dot_ex_dispatch_0, %c1_16, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
    %c20 = vm.const.i32 20 : i32
    %c5 = vm.const.i32 5 : i32
    %c8_17 = vm.const.i32 8 : i32
    %c4_18 = vm.const.i32 4 : i32
    vm.call.variadic @hal.command_buffer.execution_barrier(%ref_3, %c20, %c5, [%c8_17], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
    vm.call @hal.command_buffer.end(%ref_3) : (!vm.ref<!hal.command_buffer>) -> ()
    vm.call @hal.ex.submit_and_wait(%ref, %ref_3) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
    vm.return %ref_1 : !vm.ref<!hal.buffer>
  ^bb2:  // pred: ^bb0
    %c2_19 = vm.const.i32 2 : i32
    vm.fail %c2_19, "unreachable location reached"
  }
  vm.export @dot as("dot$raw")
  vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
    %c32 = vm.const.i32 32 : i32
    %c64 = vm.const.i32 64 : i32
    %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
    %ref_1 = vm.call @dot(%ref, %ref_0) : (!vm.ref<!hal.buffer>, !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer>
    %c50331680 = vm.const.i32 50331680 : i32
    %ref_2 = vm.call.variadic @hal.buffer_view.create(%ref_1, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
    vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
    vm.return %ref_2 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$async
  vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
    %zero = vm.const.i32.zero : i32
    %c1 = vm.const.i32 1 : i32
    %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
    %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
    %ref_1 = vm.call @dot$async(%ref_0, %zero, %arg0, %arg1, %ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.buffer_view>, !vm.ref<!hal.semaphore>, i32) -> !vm.ref<!hal.buffer_view>
    %0 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
    vm.cond_fail %0, "semaphore wait failed"
    vm.return %ref_1 : !vm.ref<!hal.buffer_view>
  }
  vm.export @dot$sync as("dot")
  vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.ex.defer_release(%operand : !vm.ref<?>) attributes {sym_visibility = "private"}
  vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.allocator.compute_size(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.allocator.compute_offset(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.allocator.compute_range(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.allocator.allocate.const(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %shape : i32 ..., %element_type : i32, %value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
  vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
  vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
  vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
  vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
  vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
  vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
  vm.func @__init() {
    %0 = vm.call @_device_match_id_0_initializer() : () -> i32
    vm.global.store.i32 %0, @_device_match_id_0 : i32
    %ref = vm.call @_descriptor_set_layout_0_initializer() : () -> !vm.ref<!hal.descriptor_set_layout>
    vm.global.store.ref %ref, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
    %ref_0 = vm.call @_executable_layout_0_initializer() : () -> !vm.ref<!hal.executable_layout>
    vm.global.store.ref %ref_0, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
    %ref_1 = vm.call @_executable_cache_initializer() : () -> !vm.ref<!hal.executable_cache>
    vm.global.store.ref %ref_1, @_executable_cache : !vm.ref<!hal.executable_cache>
    vm.return
  }
  vm.export @__init
}

```
### IR Dump After Inliner
```

module {
  vm.module @module {
    vm.rodata @_utf8_vulkan_7197BF52A22CAFD7 dense<[118, 117, 108, 107, 97, 110, 42]> : vector<7xi8>
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @_dot_ex_dispatch_0_binary_spirv opaque<"", "0xDEADBEEF"> : vector<3092xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.call.variadic @hal.allocator.compute_size(%ref_0, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %0) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_1) : (!vm.ref<!hal.buffer>) -> ()
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_3 = vm.call @hal.buffer.allocator(%arg0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_3, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_4 = vm.call @hal.buffer.allocator(%arg1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%1, %2, %0]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_2 = vm.call @hal.device.allocator(%ref_1) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_2, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_3 = vm.call @hal.allocator.allocate(%ref_2, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_3) : (!vm.ref<!hal.buffer>) -> ()
      %ref_4 = vm.call @hal.command_buffer.create(%ref_1, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_5 = vm.call @hal.buffer.allocator(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_5, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_6 = vm.call @hal.buffer.allocator(%ref_0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_6, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_4, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref, %ref_0, %ref_3], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // pred: ^bb0
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_1, %ref_4) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_7 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_7 : !vm.ref<!hal.buffer_view>
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_4 = vm.call @hal.device.allocator(%ref_3) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_5 = vm.call @hal.allocator.allocate(%ref_4, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_5) : (!vm.ref<!hal.buffer>) -> ()
      %ref_6 = vm.call @hal.command_buffer.create(%ref_3, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_7 = vm.call @hal.buffer.allocator(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_7, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_8 = vm.call @hal.buffer.allocator(%ref_2) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_8, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_6, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref_1, %ref_2, %ref_5], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // 2 preds: ^bb0, ^bb3
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_3, %ref_6) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_9 = vm.call.variadic @hal.buffer_view.create(%ref_5, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb5
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    ^bb5:  // pred: ^bb3
      vm.return %ref_9 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.defer_release(%operand : !vm.ref<?>) attributes {sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.compute_size(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.compute_offset(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.compute_range(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate.const(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %shape : i32 ..., %element_type : i32, %value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c1397773893 = vm.const.i32 1397773893 : i32
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vulkan_7197BF52A22CAFD7 = vm.const.ref.rodata @_utf8_vulkan_7197BF52A22CAFD7 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vulkan_7197BF52A22CAFD7) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1397773893]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_dot_ex_dispatch_0_binary_spirv = vm.const.ref.rodata @_dot_ex_dispatch_0_binary_spirv : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_dot_ex_dispatch_0_binary_spirv] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    }
    vm.export @__init
  }
}

```
### IR Dump After CSE
```

module {
  vm.module @module {
    vm.rodata @_utf8_vulkan_7197BF52A22CAFD7 dense<[118, 117, 108, 107, 97, 110, 42]> : vector<7xi8>
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @_dot_ex_dispatch_0_binary_spirv opaque<"", "0xDEADBEEF"> : vector<3092xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.call.variadic @hal.allocator.compute_size(%ref_0, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %0) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_1) : (!vm.ref<!hal.buffer>) -> ()
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_3 = vm.call @hal.buffer.allocator(%arg0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_3, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_4 = vm.call @hal.buffer.allocator(%arg1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%1, %2, %0]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_2 = vm.call @hal.device.allocator(%ref_1) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_2, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_3 = vm.call @hal.allocator.allocate(%ref_2, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_3) : (!vm.ref<!hal.buffer>) -> ()
      %ref_4 = vm.call @hal.command_buffer.create(%ref_1, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_5 = vm.call @hal.buffer.allocator(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_5, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_6 = vm.call @hal.buffer.allocator(%ref_0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_6, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_4, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref, %ref_0, %ref_3], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // pred: ^bb0
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_1, %ref_4) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_7 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_7 : !vm.ref<!hal.buffer_view>
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_4 = vm.call @hal.device.allocator(%ref_3) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_5 = vm.call @hal.allocator.allocate(%ref_4, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_5) : (!vm.ref<!hal.buffer>) -> ()
      %ref_6 = vm.call @hal.command_buffer.create(%ref_3, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_7 = vm.call @hal.buffer.allocator(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_7, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_8 = vm.call @hal.buffer.allocator(%ref_2) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_8, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_6, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref_1, %ref_2, %ref_5], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // 2 preds: ^bb0, ^bb3
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_3, %ref_6) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_9 = vm.call.variadic @hal.buffer_view.create(%ref_5, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb5
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    ^bb5:  // pred: ^bb3
      vm.return %ref_9 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.defer_release(%operand : !vm.ref<?>) attributes {sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.compute_size(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.compute_offset(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.compute_range(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.allocator.allocate.const(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %shape : i32 ..., %element_type : i32, %value : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.subspan(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.fill(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.read_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!iree.mutable_byte_buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.write_data(%target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %source_buffer : !vm.ref<!iree.byte_buffer>, %source_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.copy_data(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer.load(%source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %length : i32) -> i32 attributes {sym_visibility = "private"}
    vm.import @hal.buffer.store(%value : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.subview(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.byte_length(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_offset(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.compute_range(%buffer_view : !vm.ref<!hal.buffer_view>, %indices : i32 ..., %lengths : i32 ...) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.rank(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dim(%buffer_view : !vm.ref<!hal.buffer_view>, %index : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.1(%buffer_view : !vm.ref<!hal.buffer_view>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.2(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.3(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.dims.4(%buffer_view : !vm.ref<!hal.buffer_view>) -> (i32, i32, i32, i32) attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.trace(%operands : !vm.ref<!hal.buffer_view> ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.fill_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32, %pattern : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.copy_buffer(%command_buffer : !vm.ref<!hal.command_buffer>, %source_buffer : !vm.ref<!hal.buffer>, %source_offset : i32, %target_buffer : !vm.ref<!hal.buffer>, %target_offset : i32, %length : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_constants(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %offset : i32, %values : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.bind_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %descriptor_set : !vm.ref<!hal.descriptor_set>, %dynamic_offsets : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch.indirect(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroups_buffer : !vm.ref<!hal.buffer>, %workgroups_offset : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set.create(%device : !vm.ref<!hal.device>, %set_layout : !vm.ref<!hal.descriptor_set_layout>, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) -> !vm.ref<!hal.descriptor_set> attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.query(%semaphore : !vm.ref<!hal.semaphore>) -> (i32, i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.fail(%semaphore : !vm.ref<!hal.semaphore>, %status : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c1397773893 = vm.const.i32 1397773893 : i32
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vulkan_7197BF52A22CAFD7 = vm.const.ref.rodata @_utf8_vulkan_7197BF52A22CAFD7 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vulkan_7197BF52A22CAFD7) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1397773893]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_dot_ex_dispatch_0_binary_spirv = vm.const.ref.rodata @_dot_ex_dispatch_0_binary_spirv : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_dot_ex_dispatch_0_binary_spirv] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    }
    vm.export @__init
  }
}

```
### IR Dump After SymbolDCE
```

module {
  vm.module @module {
    vm.rodata @_utf8_vulkan_7197BF52A22CAFD7 dense<[118, 117, 108, 107, 97, 110, 42]> : vector<7xi8>
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @_dot_ex_dispatch_0_binary_spirv opaque<"", "0xDEADBEEF"> : vector<3092xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.call.variadic @hal.allocator.compute_size(%ref_0, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %0) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_1) : (!vm.ref<!hal.buffer>) -> ()
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_3 = vm.call @hal.buffer.allocator(%arg0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_3, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_4 = vm.call @hal.buffer.allocator(%arg1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%1, %2, %0]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_2 = vm.call @hal.device.allocator(%ref_1) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_2, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_3 = vm.call @hal.allocator.allocate(%ref_2, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_3) : (!vm.ref<!hal.buffer>) -> ()
      %ref_4 = vm.call @hal.command_buffer.create(%ref_1, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_5 = vm.call @hal.buffer.allocator(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_5, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_6 = vm.call @hal.buffer.allocator(%ref_0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_6, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_4, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref, %ref_0, %ref_3], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // pred: ^bb0
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_1, %ref_4) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_7 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_7 : !vm.ref<!hal.buffer_view>
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_4 = vm.call @hal.device.allocator(%ref_3) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_5 = vm.call @hal.allocator.allocate(%ref_4, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_5) : (!vm.ref<!hal.buffer>) -> ()
      %ref_6 = vm.call @hal.command_buffer.create(%ref_3, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_7 = vm.call @hal.buffer.allocator(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_7, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_8 = vm.call @hal.buffer.allocator(%ref_2) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_8, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_6, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref_1, %ref_2, %ref_5], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // 2 preds: ^bb0, ^bb3
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_3, %ref_6) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_9 = vm.call.variadic @hal.buffer_view.create(%ref_5, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb5
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    ^bb5:  // pred: ^bb3
      vm.return %ref_9 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.defer_release(%operand : !vm.ref<?>) attributes {sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.compute_size(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c1397773893 = vm.const.i32 1397773893 : i32
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vulkan_7197BF52A22CAFD7 = vm.const.ref.rodata @_utf8_vulkan_7197BF52A22CAFD7 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vulkan_7197BF52A22CAFD7) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1397773893]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_dot_ex_dispatch_0_binary_spirv = vm.const.ref.rodata @_dot_ex_dispatch_0_binary_spirv : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_dot_ex_dispatch_0_binary_spirv] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    }
    vm.export @__init
  }
}

```
### IR Dump After mlir::iree_compiler::IREE::DropCompilerHintsPass
```

module {
  vm.module @module {
    vm.rodata @_utf8_vulkan_7197BF52A22CAFD7 dense<[118, 117, 108, 107, 97, 110, 42]> : vector<7xi8>
    vm.global.i32 @_device_match_id_0 mutable : i32
    vm.global.ref @_executable_dot_ex_dispatch_0 mutable : !vm.ref<!hal.executable>
    vm.global.ref @_descriptor_set_layout_0 mutable : !vm.ref<!hal.descriptor_set_layout>
    vm.global.ref @_executable_layout_0 mutable : !vm.ref<!hal.executable_layout>
    vm.global.ref @_executable_cache mutable : !vm.ref<!hal.executable_cache>
    vm.rodata @_utf8_default_7FD5254DFCA3A5D0 dense<[100, 101, 102, 97, 117, 108, 116]> : vector<7xi8>
    vm.rodata @_dot_ex_dispatch_0_binary_spirv opaque<"", "0xDEADBEEF"> : vector<3092xi8>
    vm.func @dot(%arg0: !vm.ref<!hal.buffer>, %arg1: !vm.ref<!hal.buffer>) -> !vm.ref<!hal.buffer> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.device.allocator(%ref) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %0 = vm.call.variadic @hal.allocator.compute_size(%ref_0, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_1 = vm.call @hal.allocator.allocate(%ref_0, %c50, %c15, %0) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_1) : (!vm.ref<!hal.buffer>) -> ()
      %ref_2 = vm.call @hal.command_buffer.create(%ref, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_3 = vm.call @hal.buffer.allocator(%arg0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_3, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_4 = vm.call @hal.buffer.allocator(%arg1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_2, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%arg0, %arg1, %ref_1], [%zero, %zero, %zero], [%1, %2, %0]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb1, ^bb2
    ^bb1:  // pred: ^bb0
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_2, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_2, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_2) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref, %ref_2) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      vm.return %ref_1 : !vm.ref<!hal.buffer>
    ^bb2:  // pred: ^bb0
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot as("dot$raw")
    vm.func @dot$async(%arg0: !vm.ref<!hal.semaphore>, %arg1: i32, %arg2: !vm.ref<!hal.buffer_view>, %arg3: !vm.ref<!hal.buffer_view>, %arg4: !vm.ref<!hal.semaphore>, %arg5: i32) -> !vm.ref<!hal.buffer_view> {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %0 = vm.call @hal.semaphore.await(%arg0, %arg1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref = vm.call @hal.buffer_view.buffer(%arg2) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_0 = vm.call @hal.buffer_view.buffer(%arg3) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_1 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_2 = vm.call @hal.device.allocator(%ref_1) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_2, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_3 = vm.call @hal.allocator.allocate(%ref_2, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_3) : (!vm.ref<!hal.buffer>) -> ()
      %ref_4 = vm.call @hal.command_buffer.create(%ref_1, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_5 = vm.call @hal.buffer.allocator(%ref) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_5, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_6 = vm.call @hal.buffer.allocator(%ref_0) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_6, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_4, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref, %ref_0, %ref_3], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // pred: ^bb0
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_4, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_4, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_4) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_1, %ref_4) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_7 = vm.call.variadic @hal.buffer_view.create(%ref_3, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%arg4, %arg5) : (!vm.ref<!hal.semaphore>, i32) -> ()
      vm.return %ref_7 : !vm.ref<!hal.buffer_view>
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    }
    vm.export @dot$async
    vm.func @dot$sync(%arg0: !vm.ref<!hal.buffer_view>, %arg1: !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer_view> attributes {iree.reflection = {f = "I23!B9!d32d1024B9!d1024d64R10!B7!d32d64", fv = "1"}} {
      %c1024 = vm.const.i32 1024 : i32
      %c32 = vm.const.i32 32 : i32
      %c64 = vm.const.i32 64 : i32
      %c50 = vm.const.i32 50 : i32
      %c15 = vm.const.i32 15 : i32
      %c3 = vm.const.i32 3 : i32
      %zero = vm.const.i32.zero : i32
      %c1 = vm.const.i32 1 : i32
      %c20 = vm.const.i32 20 : i32
      %c5 = vm.const.i32 5 : i32
      %c8 = vm.const.i32 8 : i32
      %c4 = vm.const.i32 4 : i32
      %c2 = vm.const.i32 2 : i32
      %c50331680 = vm.const.i32 50331680 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_0 = vm.call @hal.semaphore.create(%ref, %zero) : (!vm.ref<!hal.device>, i32) -> !vm.ref<!hal.semaphore>
      %0 = vm.call @hal.semaphore.await(%ref_0, %zero) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %0, ^bb2(%0 : i32), ^bb1
    ^bb1:  // pred: ^bb0
      %ref_1 = vm.call @hal.buffer_view.buffer(%arg0) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_2 = vm.call @hal.buffer_view.buffer(%arg1) : (!vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer>
      %ref_3 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_4 = vm.call @hal.device.allocator(%ref_3) : (!vm.ref<!hal.device>) -> !vm.ref<!hal.allocator>
      %1 = vm.call.variadic @hal.allocator.compute_size(%ref_4, [%c32, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_5 = vm.call @hal.allocator.allocate(%ref_4, %c50, %c15, %1) : (!vm.ref<!hal.allocator>, i32, i32, i32) -> !vm.ref<!hal.buffer>
      vm.call @hal.ex.defer_release(%ref_5) : (!vm.ref<!hal.buffer>) -> ()
      %ref_6 = vm.call @hal.command_buffer.create(%ref_3, %c1, %c3) : (!vm.ref<!hal.device>, i32, i32) -> !vm.ref<!hal.command_buffer>
      vm.call @hal.command_buffer.begin(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      %_executable_dot_ex_dispatch_0 = vm.global.load.ref @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_7 = vm.call @hal.buffer.allocator(%ref_1) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %2 = vm.call.variadic @hal.allocator.compute_size(%ref_7, [%c32, %c1024], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      %ref_8 = vm.call @hal.buffer.allocator(%ref_2) : (!vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator>
      %3 = vm.call.variadic @hal.allocator.compute_size(%ref_8, [%c1024, %c64], %c50331680) : (!vm.ref<!hal.allocator>, i32 ..., i32) -> i32
      vm.call.variadic @hal.command_buffer.push_descriptor_set(%ref_6, %_executable_layout_0, %zero, [%zero, %c1, %c2], [%ref_1, %ref_2, %ref_5], [%zero, %zero, %zero], [%2, %3, %1]) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable_layout>, i32, i32 ..., !vm.ref<!hal.buffer> ..., i32 ..., i32 ...)
      %_device_match_id_0 = vm.global.load.i32 @_device_match_id_0 : i32
      vm.cond_br %_device_match_id_0, ^bb3, ^bb4
    ^bb2(%4: i32):  // 2 preds: ^bb0, ^bb3
      vm.fail %4, "semaphore wait failed"
    ^bb3:  // pred: ^bb1
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %zero, %c64, %c1, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c4, %c4, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.dispatch(%ref_6, %_executable_dot_ex_dispatch_0, %c1, %c8, %c4, %c1) : (!vm.ref<!hal.command_buffer>, !vm.ref<!hal.executable>, i32, i32, i32, i32) -> ()
      vm.call.variadic @hal.command_buffer.execution_barrier(%ref_6, %c20, %c5, [%c8], []) : (!vm.ref<!hal.command_buffer>, i32, i32, i32 ..., i32 ...)
      vm.call @hal.command_buffer.end(%ref_6) : (!vm.ref<!hal.command_buffer>) -> ()
      vm.call @hal.ex.submit_and_wait(%ref_3, %ref_6) : (!vm.ref<!hal.device>, !vm.ref<!hal.command_buffer>) -> ()
      %ref_9 = vm.call.variadic @hal.buffer_view.create(%ref_5, [%c32, %c64], %c50331680) : (!vm.ref<!hal.buffer>, i32 ..., i32) -> !vm.ref<!hal.buffer_view>
      vm.call @hal.semaphore.signal(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> ()
      %5 = vm.call @hal.semaphore.await(%ref_0, %c1) : (!vm.ref<!hal.semaphore>, i32) -> i32
      vm.cond_br %5, ^bb2(%5 : i32), ^bb5
    ^bb4:  // pred: ^bb1
      vm.fail %c2, "unreachable location reached"
    ^bb5:  // pred: ^bb3
      vm.return %ref_9 : !vm.ref<!hal.buffer_view>
    }
    vm.export @dot$sync as("dot")
    vm.import @hal.ex.shared_device() -> !vm.ref<!hal.device> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.ex.defer_release(%operand : !vm.ref<?>) attributes {sym_visibility = "private"}
    vm.import @hal.ex.submit_and_wait(%device : !vm.ref<!hal.device>, %command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.allocator.compute_size(%allocator : !vm.ref<!hal.allocator>, %shape : i32 ..., %element_type : i32) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.allocator.allocate(%allocator : !vm.ref<!hal.allocator>, %memory_types : i32, %buffer_usage : i32, %allocation_size : i32) -> !vm.ref<!hal.buffer> attributes {sym_visibility = "private"}
    vm.import @hal.buffer.allocator(%buffer : !vm.ref<!hal.buffer>) -> !vm.ref<!hal.allocator> attributes {sym_visibility = "private"}
    vm.import @hal.buffer_view.create(%buffer : !vm.ref<!hal.buffer>, %shape : i32 ..., %element_type : i32) -> !vm.ref<!hal.buffer_view> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.buffer_view.buffer(%buffer_view : !vm.ref<!hal.buffer_view>) -> !vm.ref<!hal.buffer> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.command_buffer.create(%device : !vm.ref<!hal.device>, %modes : i32, %command_categories : i32) -> !vm.ref<!hal.command_buffer> attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.begin(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.end(%command_buffer : !vm.ref<!hal.command_buffer>) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.execution_barrier(%command_buffer : !vm.ref<!hal.command_buffer>, %source_stage_mask : i32, %target_stage_mask : i32, %memory_barriers : i32 ..., %buffer_barriers : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.push_descriptor_set(%command_buffer : !vm.ref<!hal.command_buffer>, %executable_layout : !vm.ref<!hal.executable_layout>, %set : i32, %bindings : i32 ..., %binding_buffers : !vm.ref<!hal.buffer> ..., %binding_offsets : i32 ..., %binding_lengths : i32 ...) attributes {sym_visibility = "private"}
    vm.import @hal.command_buffer.dispatch(%command_buffer : !vm.ref<!hal.command_buffer>, %executable : !vm.ref<!hal.executable>, %entry_point : i32, %workgroup_x : i32, %workgroup_y : i32, %workgroup_z : i32) attributes {sym_visibility = "private"}
    vm.import @hal.descriptor_set_layout.create(%device : !vm.ref<!hal.device>, %usage_type : i32, %bindings : tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.allocator(%device : !vm.ref<!hal.device>) -> !vm.ref<!hal.allocator> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.device.match.id(%device : !vm.ref<!hal.device>, %pattern : !vm.ref<!iree.byte_buffer>) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.create(%device : !vm.ref<!hal.device>, %identifier : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.select_format(%executable_cache : !vm.ref<!hal.executable_cache>, %available_formats : i32 ...) -> i32 attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_cache.prepare(%executable_cache : !vm.ref<!hal.executable_cache>, %executable_layout : !vm.ref<!hal.executable_layout>, %caching_mode : i32, %executable_data : !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.executable_layout.create(%device : !vm.ref<!hal.device>, %set_layouts : !vm.ref<!hal.descriptor_set_layout> ..., %push_constants : i32) -> !vm.ref<!hal.executable_layout> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.create(%device : !vm.ref<!hal.device>, %initial_value : i32) -> !vm.ref<!hal.semaphore> attributes {nosideeffects, sym_visibility = "private"}
    vm.import @hal.semaphore.signal(%semaphore : !vm.ref<!hal.semaphore>, %new_value : i32) attributes {sym_visibility = "private"}
    vm.import @hal.semaphore.await(%semaphore : !vm.ref<!hal.semaphore>, %min_value : i32) -> i32 attributes {sym_visibility = "private"}
    vm.func @__init() {
      %c1 = vm.const.i32 1 : i32
      %c2 = vm.const.i32 2 : i32
      %c6 = vm.const.i32 6 : i32
      %zero = vm.const.i32.zero : i32
      %c1397773893 = vm.const.i32 1397773893 : i32
      %null = vm.const.ref.zero : !vm.ref<!iree.byte_buffer>
      %c7 = vm.const.i32 7 : i32
      %ref = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_vulkan_7197BF52A22CAFD7 = vm.const.ref.rodata @_utf8_vulkan_7197BF52A22CAFD7 : !vm.ref<!iree.byte_buffer>
      %0 = vm.call @hal.device.match.id(%ref, %_utf8_vulkan_7197BF52A22CAFD7) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> i32
      vm.global.store.i32 %0, @_device_match_id_0 : i32
      %ref_0 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_1 = vm.call.variadic @hal.descriptor_set_layout.create(%ref_0, %c1, [(%zero, %c7, %c1), (%c1, %c7, %c1), (%c2, %c7, %c6)]) : (!vm.ref<!hal.device>, i32, tuple<i32, i32, i32> ...) -> !vm.ref<!hal.descriptor_set_layout>
      vm.global.store.ref %ref_1, @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %_descriptor_set_layout_0 = vm.global.load.ref @_descriptor_set_layout_0 : !vm.ref<!hal.descriptor_set_layout>
      %ref_2 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %ref_3 = vm.call.variadic @hal.executable_layout.create(%ref_2, [%_descriptor_set_layout_0], %zero) : (!vm.ref<!hal.device>, !vm.ref<!hal.descriptor_set_layout> ..., i32) -> !vm.ref<!hal.executable_layout>
      vm.global.store.ref %ref_3, @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %ref_4 = vm.call @hal.ex.shared_device() : () -> !vm.ref<!hal.device>
      %_utf8_default_7FD5254DFCA3A5D0 = vm.const.ref.rodata @_utf8_default_7FD5254DFCA3A5D0 : !vm.ref<!iree.byte_buffer>
      %ref_5 = vm.call @hal.executable_cache.create(%ref_4, %_utf8_default_7FD5254DFCA3A5D0) : (!vm.ref<!hal.device>, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable_cache>
      %_executable_layout_0 = vm.global.load.ref @_executable_layout_0 : !vm.ref<!hal.executable_layout>
      %1 = vm.call.variadic @hal.executable_cache.select_format(%ref_5, [%c1397773893]) : (!vm.ref<!hal.executable_cache>, i32 ...) -> i32
      %_dot_ex_dispatch_0_binary_spirv = vm.const.ref.rodata @_dot_ex_dispatch_0_binary_spirv : !vm.ref<!iree.byte_buffer>
      %ref_6 = vm.switch.ref %1[%_dot_ex_dispatch_0_binary_spirv] else %null : !vm.ref<!iree.byte_buffer>
      %ref_7 = vm.call @hal.executable_cache.prepare(%ref_5, %_executable_layout_0, %c7, %ref_6) : (!vm.ref<!hal.executable_cache>, !vm.ref<!hal.executable_layout>, i32, !vm.ref<!iree.byte_buffer>) -> !vm.ref<!hal.executable>
      vm.global.store.ref %ref_7, @_executable_dot_ex_dispatch_0 : !vm.ref<!hal.executable>
      vm.global.store.ref %ref_5, @_executable_cache : !vm.ref<!hal.executable_cache>
      vm.return
    }
    vm.export @__init
  }
}

```